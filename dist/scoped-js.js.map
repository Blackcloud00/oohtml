{
  "version": 3,
  "sources": ["../../stateful-js/src/params.js", "../../stateful-js/node_modules/@webqit/observer/src/main.js", "../../stateful-js/node_modules/@webqit/util/js/isObject.js", "../../stateful-js/node_modules/@webqit/util/js/getType.js", "../../stateful-js/node_modules/@webqit/util/js/isArray.js", "../../stateful-js/node_modules/@webqit/util/arr/intersect.js", "../../stateful-js/node_modules/@webqit/util/js/internals.js", "../../stateful-js/node_modules/@webqit/util/js/isTypeFunction.js", "../../stateful-js/node_modules/@webqit/util/js/isNull.js", "../../stateful-js/node_modules/@webqit/util/js/isUndefined.js", "../../stateful-js/node_modules/@webqit/util/js/isTypeObject.js", "../../stateful-js/node_modules/@webqit/util/js/isEmpty.js", "../../stateful-js/node_modules/@webqit/util/js/isFunction.js", "../../stateful-js/node_modules/@webqit/util/js/isString.js", "../../stateful-js/node_modules/@webqit/util/js/isTypeArray.js", "../../stateful-js/node_modules/@webqit/util/arr/from.js", "../../stateful-js/node_modules/@webqit/observer/src/util.js", "../../stateful-js/node_modules/@webqit/observer/src/core/Registration.js", "../../stateful-js/node_modules/@webqit/observer/src/core/ListenerRegistration.js", "../../stateful-js/node_modules/@webqit/observer/src/core/Registry.js", "../../stateful-js/node_modules/@webqit/observer/src/core/Descriptor.js", "../../stateful-js/node_modules/@webqit/observer/src/core/ListenerRegistry.js", "../../stateful-js/node_modules/@webqit/observer/src/core/TrapsRegistration.js", "../../stateful-js/node_modules/@webqit/observer/src/core/TrapsRegistry.js", "../../stateful-js/node_modules/@webqit/observer/src/actors.js", "../../stateful-js/node_modules/@webqit/observer/src/index.js", "../../stateful-js/src/util.js", "../../stateful-js/src/runtime/hot-module-registry.js", "../../stateful-js/src/runtime/EventTarget.js", "../../stateful-js/src/runtime/Signal.js", "../../stateful-js/src/runtime/Scope.js", "../../stateful-js/src/runtime/Autorun.js", "../../stateful-js/src/runtime/AutoIterator.js", "../../stateful-js/src/runtime/AutoAsyncIterator.js", "../../stateful-js/src/runtime/State.js", "../../stateful-js/src/runtime/Runtime.js", "../../stateful-js/src/runtime/index.js", "../../stateful-js/src/AbstractStatefulScript.js", "../../stateful-js/src/index.async.js", "../node_modules/@webqit/observer/src/main.js", "../node_modules/@webqit/util/js/isObject.js", "../node_modules/@webqit/util/js/getType.js", "../node_modules/@webqit/util/js/isArray.js", "../node_modules/@webqit/util/arr/intersect.js", "../node_modules/@webqit/util/js/internals.js", "../node_modules/@webqit/util/js/isTypeFunction.js", "../node_modules/@webqit/util/js/isNull.js", "../node_modules/@webqit/util/js/isUndefined.js", "../node_modules/@webqit/util/js/isTypeObject.js", "../node_modules/@webqit/util/js/isEmpty.js", "../node_modules/@webqit/util/js/isFunction.js", "../node_modules/@webqit/util/js/isNumber.js", "../node_modules/@webqit/util/js/isNumeric.js", "../node_modules/@webqit/util/js/isString.js", "../node_modules/@webqit/util/js/isTypeArray.js", "../node_modules/@webqit/util/arr/pushUnique.js", "../node_modules/@webqit/util/obj/getPrototypeChain.js", "../node_modules/@webqit/util/obj/getAllPropertyNames.js", "../node_modules/@webqit/util/obj/mergeCallback.js", "../node_modules/@webqit/util/obj/merge.js", "../node_modules/@webqit/util/arr/from.js", "../node_modules/@webqit/observer/src/util.js", "../node_modules/@webqit/observer/src/core/Registration.js", "../node_modules/@webqit/observer/src/core/ListenerRegistration.js", "../node_modules/@webqit/observer/src/core/Registry.js", "../node_modules/@webqit/observer/src/core/Descriptor.js", "../node_modules/@webqit/observer/src/core/ListenerRegistry.js", "../node_modules/@webqit/observer/src/core/TrapsRegistration.js", "../node_modules/@webqit/observer/src/core/TrapsRegistry.js", "../node_modules/@webqit/observer/src/actors.js", "../node_modules/@webqit/observer/src/index.js", "../src/scoped-js/Hash.js", "../node_modules/@webqit/util/obj/get.js", "../node_modules/@webqit/util/obj/set.js", "../node_modules/@webqit/realdom/src/Scheduler.js", "../node_modules/@webqit/realdom/src/realtime/Xpath.js", "../node_modules/@webqit/realdom/src/realtime/DOMSpec.js", "../node_modules/@webqit/realdom/src/realtime/Realtime.js", "../node_modules/@webqit/realdom/src/realtime/AttrRealtime.js", "../node_modules/@webqit/realdom/src/realtime/DOMRealtime.js", "../node_modules/@webqit/realdom/src/polyfills.js", "../node_modules/@webqit/realdom/src/index.js", "../src/util.js", "../src/scoped-js/index.js", "../src/scoped-js/targets.browser.js"],
  "sourcesContent": ["\n/**\n * @exports\n */\nexport function resolveParams( ...extensions ) {\n    let extension, params = { runtimeParams, compilerParams, parserParams };\n    while( extension = extensions.shift() ) {\n        const {\n            runtimeParams: _runtimeParams = {},\n            compilerParams: { globalsNoObserve: _globalsNoObserve = [], globalsOnlyPathsExcept: _globalsOnlyPathsExcept = [], ..._compilerParams } = {},\n            parserParams: _parserParams = {},\n        } = extension;\n        params = {\n            runtimeParams: { ...params.runtimeParams, ..._runtimeParams },\n            compilerParams: { ...params.compilerParams, globalsNoObserve: [ ...params.compilerParams.globalsNoObserve, ..._globalsNoObserve ], globalsOnlyPathsExcept: [ ...params.compilerParams.globalsOnlyPathsExcept, ..._globalsOnlyPathsExcept ], ..._compilerParams },\n            parserParams: { ...params.parserParams, ..._parserParams },\n        };\n        if ( extensions.devMode ) { /* shortcut for devMode configs */ }\n    }\n    return params;\n}\nexport const parserParams = {\n    ecmaVersion: 'latest',\n    allowReturnOutsideFunction: true,\n    allowAwaitOutsideFunction: false,\n    allowSuperOutsideMethod: false,\n    preserveParens: false,\n    locations: true,\n};\nexport const compilerParams = {\n    globalsNoObserve: [ 'arguments', 'debugger', ],\n    globalsOnlyPathsExcept: [],\n    originalSource: true,\n    locations: true,\n    compact: 2,\n};\nexport const runtimeParams = {\n    apiVersion: 3,\n};\n", "\n/**\n * @imports\n */\nimport { _isObject, _isTypeObject, _isFunction, _getType } from '@webqit/util/js/index.js';\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport { _, _await, other as otherUtil } from './util.js';\nimport ListenerRegistry from './core/ListenerRegistry.js';\nimport TrapsRegistry from './core/TrapsRegistry.js';\nimport Descriptor from './core/Descriptor.js';\nimport { unproxy } from './actors.js';\n\n/* ---------------SPECIAL APIs--------------- */\n\n/**\n * Creates a Path array instance from arguments.\n * \n * @param Array\t            ...segments\n *\n * @return Path\n */\nclass Path extends Array {}\nexport function path( ...segments ) {\n    return new Path( ...segments );\n}\n\n/**\n * Reduces a path array against handler.\n * \n * @param Array|Object\t    target\n * @param Array\t            path\n * @param Function\t        receiver\n * @param Function\t        final\n * @param Object\t        params\n * \n * @example reduce( object, [ segement1, segement2 ], observe, ( value, flags ) => {}, params );\n *\n * @return Any\n */\nexport function reduce( target, path, receiver, final = x => x, params = {} ) {\n    if ( !path.length ) return;\n    return ( function eat( target, path, $params ) {\n        const segment = path[ $params.level ];\n        const isLastSegment = $params.level === path.length - 1;\n        if ( target instanceof Descriptor && target.operation !== 'get' ) {\n            // Always probe event-generated trees\n            $params = { ...$params, probe: 'always' };\n        } else if ( $params.probe !== 'always' ) {\n            // Probe until (before) last segment\n            $params = { ...$params, probe: !isLastSegment };\n        }\n        // ---------------\n        return receiver( target, segment, ( result, ...args ) => {\n            // -----------\n            const addTrail = desc => {\n                if ( !( desc instanceof Descriptor ) ) return;\n                desc.path = [ desc.key ];\n                if ( target instanceof Descriptor ) {\n                    desc.path = target.path.concat( desc.key );\n                    Object.defineProperty( desc, 'context', { get: () => target, configurable: true } );\n                }\n            };\n            const advance = result => {\n                const $value = resolveObj( result/* a Descriptor who's value could be proxied */, false );\n                return _await( $value/* could be a promise */, $value => {\n                    if ( result instanceof Descriptor ) {\n                        result.value = $value; // Update to (fulfilled), unproxied, value\n                    } else {\n                        result = $value;\n                    }\n                    const flags = args[ 0 ] || {};\n                    return eat( result, path, { ...$params, ...flags, level: $params.level + 1, } );\n                } );\n            };\n            // -----------\n            if ( isPropsList( segment ) && Array.isArray( result ) ) {\n                result.forEach( addTrail );\n                if ( isLastSegment ) return final( result, ...args );\n                return result.map( advance );\n            }\n            // -----------\n            addTrail( result );\n            if ( isLastSegment ) return final( result, ...args );\n            return advance( result );\n            // -----------\n        }, $params );\n    } )( target, path.slice( 0 ), { ...params, level: 0 } );\n}\n\n/**\n * Adds an observer to a target's registry.\n *\n * @param Array|Object\t    target\n * @param String|Object\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return AbortController\n */\nexport function observe( target, prop, receiver, params = {} ) {\n    // ---------------\n    target = resolveObj( target, !params.level );\n\tif ( _isFunction( arguments[ 1 ] ) ) {\n        [ , receiver, params = {} ] = arguments;\n        prop = Infinity;\n\t}\n\tif ( !_isFunction( receiver ) ) throw new Error( `Handler must be a function; \"${ _getType( receiver ) }\" given!` );\n    if ( prop instanceof Path ) return reduce( target, prop, observe, receiver, params );\n    // ---------------\n    params = { ...params, descripted: true };\n    delete params.live;\n    if ( !_isTypeObject( target ) ) return params.probe && get( target, prop, receiver, params );\n    // ---------------\n    const emit = bind( target, prop, receiver, params );\n    if ( params.probe ) {\n        return get( target, prop, emit, params );\n    }\n    return emit();\n}\n\n/**\n * Adds an interceptor object to a target's registry.\n *\n * @param Array|Object\t    target\n * @param Object\t        traps\n * @param Object\t\t    params\n *\n * @return AbortRegistry\n */\nexport function intercept( target, traps, params = {} ) {\n    // ---------------\n    target = resolveObj( target );\n    if ( !_isObject( traps ) ) {\n        [ /*target*/, /*operation*/, /*handler*/, params = {} ] = arguments;\n        traps = { [ arguments[ 1 ] ]: arguments[ 2 ] };\n    }\n    // ---------------\n    return TrapsRegistry.getInstance( target, true, params.namespace ).addRegistration( { traps, params } );\n}\n\n/* ---------------QUERY APIs--------------- */\n\n/**\n * Performs a \"getOwnPropertyDescriptor\" operation.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getOwnPropertyDescriptor( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'getOwnPropertyDescriptor', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a \"getOwnPropertyDescriptors\" operation.\n * @note this isn't part of the standard Reflect API.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getOwnPropertyDescriptors( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'getOwnPropertyDescriptors', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a \"getPrototypeOf\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getPrototypeOf( target, receiver = x => x, params = {} ) {\n    return exec( target, 'getPrototypeOf', {}, receiver, params );\n}\n\n/**\n * Performs a \"isExtensible\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function isExtensible( target, receiver = x => x, params = {} ) {\n    return exec( target, 'isExtensible', {}, receiver, params );\n}\n\n/**\n * Performs a \"ownKeys\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function ownKeys( target, receiver = x => x, params = {} ) {\n    return exec( target, 'ownKeys', {}, receiver, params );\n}\n\n/**\n * Performs an operation of the given \"type\".\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function has( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'has', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a get operation.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function get( target, prop, receiver = x => x, params = {} ) {\n    // ---------------\n    let isLive;\n    const originalTarget = resolveObj( target, !params.level );\n    if ( _isObject( receiver ) ) { [ params, receiver ] = [ receiver, x => x ]; }\n    else if ( params.live ) { isLive = true; }\n    if ( prop instanceof Path ) return reduce( originalTarget, prop, get, receiver, params );\n    // ---------------\n    return resolveProps( originalTarget, prop, props => {\n        const related = [ ...props ];\n        return ( function next( results, _props, _done ) {\n            if ( !_props.length ) return _done( results );\n            const prop = _props.shift();\n            if ( ![ 'string', 'number', 'symbol' ].includes( typeof prop ) ) {\n                throw new Error( `Property name/key ${ prop } invalid.` );\n            }\n            // ---------\n            function defaultGet( descriptor, value = undefined ) {\n                const _next = value => ( descriptor.value = value, next( [ ...results, params.live || params.descripted ? descriptor : value ]/** not using concat() as value may be an array */, _props, _done ) );\n                if ( arguments.length > 1 ) return _next( value );\n                if ( !_isTypeObject( originalTarget ) ) return _next( originalTarget?.[ descriptor.key ] );\n                const accessorizedProps = _( originalTarget, 'accessorizedProps', false );\n                const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n                if ( accessorization && accessorization.intact() ) {\n                    return _next( accessorization.getValue( params.withPropertyDescriptors ) );\n                }\n                if ( params.withPropertyDescriptors ) {\n                    const desc = Object.getOwnPropertyDescriptor( originalTarget, descriptor.key );\n                    if ( 'forceValue' in params &&  'value' in desc ) { desc.value = params.forceValue; }\n                    return _next( desc );\n                }\n                if ( 'forceValue' in params ) { return _next( params.forceValue ); }\n                return _next( Reflect.get( originalTarget, descriptor.key, ...( params.receiver ? [ params.receiver ] : [] ) ) );\n            }\n            // ---------\n            const descriptor = new Descriptor( originalTarget, {\n                type: 'get',\n                key: prop,\n                value: undefined,\n                operation: 'get',\n                related,\n            } );\n            if ( !_isTypeObject( originalTarget ) ) return defaultGet( descriptor );\n            const trapsRegistry = TrapsRegistry.getInstance( originalTarget, false, params.namespace );\n            if ( trapsRegistry ) {\n                return trapsRegistry.emit( descriptor, defaultGet );\n            }\n            return defaultGet( descriptor );\n        } )( [], props.slice( 0 ), results => {\n            const result_s = isPropsList( prop/*original*/ ) ? results : results[ 0 ];\n            if ( isLive && _isTypeObject( originalTarget ) ) {\n                const emit = bind( originalTarget, prop, receiver, params );\n                return emit( result_s );\n            }\n            return receiver( result_s );\n        } );\n    }, params );\n}\n\n/* ---------------MUTATION APIs--------------- */\n\n/**\n * Performs a batch operation.\n * \n * @param Object\t        target\n * @param Function\t        callback\n * @param Object\t        params\n *\n * @return Void\n */\nexport function batch( target, callback, params = {} ) {\n    target = resolveObj( target );\n    return ListenerRegistry.getInstance( target, true, params.namespace ).batch( callback );\n}\n\n/**\n * Performs a mirror operation.\n * \n * @param Object\t        source\n * @param Object\t        target\n * @param Object\t        params\n *\n * @return Void\n */\nexport function read( source, target, params = {} ) {\n    target = resolveObj( target );\n    source = resolveObj( source );\n    const only = ( params.only || [] ).slice( 0 ), except = ( params.except || [] ).slice( 0 );\n    const sourceKeys = ownKeys( params.spread ? [ ...source ] : source ).map( k => !isNaN( k ) ? parseInt( k ) : k );\n    const filteredKeys = only.length ? only.filter( k => sourceKeys.includes( k ) ) : sourceKeys.filter( k => !except.includes( k ) );\n    const resolveKey = k => {\n        if ( !Array.isArray( target ) || isNaN( k ) ) return k;\n        return k - except.filter( i => i < k ).length;\n    };\n    const doSet = key => {\n        const descriptor = getOwnPropertyDescriptor( source, key, params );\n        if ( ( 'value' in descriptor ) && descriptor.writable && descriptor.enumerable && descriptor.configurable ) {\n            set( target, resolveKey( key ), descriptor.value, params );\n        } else if ( descriptor.enumerable || params.onlyEnumerable === false ) { defineProperty( target, key, { ...descriptor, configurable: true }, params ); }\n    };\n    batch( target, () => {\n        filteredKeys.forEach( doSet );\n    } );\n    return observe( source, mutations => {\n        //batch( target, () => {\n            mutations.filter( m => only.length ? only.includes( m.key ) : !except.includes( m.key ) ).forEach( m => {\n                if ( m.operation === 'deleteProperty' ) return deleteProperty( target, resolveKey( m.key ), params );\n                if ( m.operation === 'defineProperty' ) {\n                    if ( m.value.enumerable || params.onlyEnumerable === false ) {\n                        defineProperty( target, resolveKey( m.key ), { ...m.value, configurable: true }, params );\n                    }\n                    return;\n                }\n                doSet( m.key );\n            } );\n        //}, params );\n    }, { ...params, withPropertyDescriptors: true } );\n}\n\n/**\n * Performs a set operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Any\t            value\n * @param Function\t        receiver\n * @param Object\t        params\n * @param Bool\t            def\n *\n * @return Any\n */\nexport function set( target, prop, value, receiver = x => x, params = {}, def = false ) {\n    // ---------------\n    const originalTarget = resolveObj( target );\n    let entries = [ [ prop, value ] ];\n    if ( _isObject( prop ) ) {\n        [ /*target*/, /*hash*/, receiver = x => x, params = {}, def = false ] = arguments;\n        entries = Object.entries( prop );\n    }\n    if ( _isObject( receiver ) ) { [ def, params, receiver ] = [ typeof params === 'boolean' ? params : def, receiver, x => x ]; }\n    // ---------------\n    const related = entries.map( ( [ prop ] ) => prop );\n    return ( function next( descriptors, entries, _done ) {\n        if ( !entries.length ) return _done( descriptors );\n        const [ prop, value ] = entries.shift();\n        // ---------\n        function defaultSet( descriptor, status = undefined ) {\n            const _next = status => ( descriptor.status = status, next( descriptors.concat( descriptor ), entries, _done ) );\n            if ( arguments.length > 1 ) return _next( descriptor, status );\n            const accessorizedProps = _( originalTarget, 'accessorizedProps', false );\n            const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n            if ( descriptor.operation === 'defineProperty' ) {\n                if ( accessorization && !accessorization.restore() ) _next( false );\n                Object.defineProperty( originalTarget, descriptor.key, descriptor.value );\n                return _next( true );\n            }\n            if ( accessorization && accessorization.intact() ) {\n                return _next( accessorization.setValue( descriptor.value ) );\n            }\n            return _next( Reflect.set( originalTarget, descriptor.key, descriptor.value ) );\n        }\n        // ---------\n        function exec( isUpdate, oldValue ) {\n            if ( params.diff && value === oldValue ) return next( descriptors, entries, _done );\n            const descriptor = new Descriptor( originalTarget, {\n                type: def ? 'def' : 'set',\n                key: prop,\n                value,\n                isUpdate,\n                oldValue,\n                related: [ ...related ],\n                operation: def ? 'defineProperty' : 'set',\n                detail: params.detail,\n            } );\n            const trapsRegistry = TrapsRegistry.getInstance( originalTarget, false, params.namespace );\n            return trapsRegistry \n                ? trapsRegistry.emit( descriptor, defaultSet ) \n                : defaultSet( descriptor );\n        }\n        // ---------\n        return has( originalTarget, prop, exists => {\n            if ( !exists ) return exec( exists );\n            const $params = { ...params, withPropertyDescriptors: def };\n            if ( 'forceOldValue' in params ) { $params.forceValue = params.forceOldValue; }\n            return get( originalTarget, prop, oldValue => exec( exists, oldValue ), $params );\n        }, params );\n        // ---------\n    } )( [], entries.slice( 0 ), descriptors => {\n        const listenerRegistry = ListenerRegistry.getInstance( originalTarget, false, params.namespace );\n        if ( listenerRegistry ) listenerRegistry.emit( descriptors, def );\n        return receiver(\n            isPropsList( prop/*original*/ ) ? descriptors.map( opr => opr.status ) : descriptors[ 0 ]?.status\n        );\n    } );\n}\n\n/**\n * Performs a defineProperty operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Object\t        descriptor\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function defineProperty( target, prop, descriptor, receiver = x => x, params = {} ) {\n    return set( target, prop, descriptor, receiver, params, true/*def*/ );\n}\n\n/**\n * Performs a defineProperties operation.\n * @note this isn't part of the standard Reflect API.\n * \n * @param Object\t        target\n * @param Object\t        descriptors\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function defineProperties( target, descriptors, receiver = x => x, params = {} ) {\n    return set( target, descriptors, receiver, params, true/*def*/ );\n}\n\n/**\n * Performs a delete operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function deleteProperty( target, prop, receiver = x => x, params = {} ) {\n    // ---------------\n    target = resolveObj( target );\n    if ( _isObject( receiver ) ) { [ params, receiver ] = [ receiver, x => x ]; }\n    // ---------------\n    const props = _arrFrom( prop, false ), related = [ ...props ];\n    return ( function next( descriptors, props, _done ) {\n        if ( !props.length ) return _done( descriptors );\n        const prop = props.shift();\n        // ---------\n        function defaultDel( descriptor, status = undefined ) {\n            const _next = status => ( descriptor.status = status, next( descriptors.concat( descriptor ), props, _done ) );\n            if ( arguments.length > 1 ) return _next( descriptor, status );\n            const accessorizedProps = _( target, 'accessorizedProps', false );\n            const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n            if ( accessorization && !accessorization.restore() ) _next( false );\n            return _next( Reflect.deleteProperty( target, descriptor.key ) );\n        }\n        // ---------\n        function exec( oldValue ) {\n            const descriptor = new Descriptor( target, {\n                type: 'delete',\n                key: prop,\n                oldValue,\n                related: [ ...related ],\n                operation: 'deleteProperty',\n                detail: params.detail,\n            } );\n            const listenerRegistry = TrapsRegistry.getInstance( target, false, params.namespace );\n            return listenerRegistry \n                ? listenerRegistry.emit( descriptor, defaultDel ) \n                : defaultDel( descriptor );\n        }\n        // ---------\n        return get( target, prop, exec, params );\n        // ---------\n    } )( [], props.slice( 0 ), descriptors => {\n        const listenerRegistry = ListenerRegistry.getInstance( target, false, params.namespace );\n        if ( listenerRegistry ) listenerRegistry.emit( descriptors );\n        return receiver(\n            isPropsList( prop/*original*/ ) ? descriptors.map( opr => opr.status ) : descriptors[ 0 ].status\n        );\n    } );\n}\n\n/**\n * @alias deleteProperty()\n */\nexport function deleteProperties( target, props, receiver = x => x, params = {} ) {\n    return deleteProperty( ...arguments );\n}\n\n/* ---------------EFFECT APIs--------------- */\n\n/**\n * Performs a \"construct\" operation.\n *\n * @param Array|Object\t    target\n * @param Array\t\t\t    argumentsList\n * @param Object\t\t    newTarget\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function construct( target, argumentsList, newTarget = null, receiver = x => x, params = {} ) {\n    return exec( target, 'construct', arguments.length > 2 ? { argumentsList, newTarget } : { argumentsList }, receiver, params );\n}\n\n/**\n * Performs an \"apply\" operation.\n *\n * @param Array|Object\t    target\n * @param Any\t            thisArgument\n * @param Array\t            argumentsList\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function apply( target, thisArgument, argumentsList, receiver = x => x, params = {} ) {\n    return exec( target, 'apply', { thisArgument, argumentsList }, receiver, params );\n}\n\n/**\n * Performs a \"setPrototypeOf\" operation.\n *\n * @param Array|Object\t    target\n * @param Anyr\t            proto\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function setPrototypeOf( target, proto, receiver = x => x, params = {} ) {\n    return exec( target, 'setPrototypeOf', { proto }, receiver, params );\n}\n\n/**\n * Performs a \"preventExtension\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function preventExtensions( target, receiver = x => x, params = {} ) {\n    return exec( target, 'preventExtensions', {}, receiver, params );\n}\n\n/* ---------------HELPER APIs--------------- */\n\n/**\n * Adds an observer to a target's registry.\n *\n * @param Array|Object\t    target\n * @param String|Object\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Function: AbortController\n */\nfunction bind( target, prop, receiver, params = {} ) {\n    let controller;\n    if ( !params.signal ) {\n        controller = new AbortController;\n        params = { ...params, signal: controller.signal };\n        otherUtil.setMaxListeners?.( 0, controller.signal );\n    }\n    const listenerRegistry = ListenerRegistry.getInstance( target, true, params.namespace );\n    return function emit( descriptor_s, prevRegistration = null ) {\n        prevRegistration?.remove();\n        const registrationNext = listenerRegistry.addRegistration( prop, emit, params );\n        const flags = { signal: registrationNext.signal, };\n        if ( arguments.length ) {\n            const handlerReturnValue = receiver( descriptor_s, flags );\n            if ( arguments.length > 1 ) return handlerReturnValue;\n        }\n        return controller;\n    };\n}\n\n/**\n * Performs an operation of the given \"type\".\n *\n * @param Array|Object\t    target\n * @param String\t\t    operation\n * @param Object\t\t    payload\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nfunction exec( target, operation, payload = {}, receiver = x => x, params = {} ) {\n    // ---------\n    target = resolveObj( target );\n    if ( _isObject( receiver ) ) { [ params, receiver ] = [ receiver, x => x ]; }    \n    // ---------\n    function defaultExec( descriptor, result ) {\n        if ( arguments.length > 1 ) return receiver( result );\n        return receiver( ( Reflect[ operation ] || Object[ operation ] )( target, ...Object.values( payload ) ) );\n    }\n    // ---------\n    const descriptor = new Descriptor( target, { operation, ...payload } );\n    const listenerRegistry = TrapsRegistry.getInstance( target, false, params.namespace );\n    if ( listenerRegistry ) {\n        return listenerRegistry.emit( descriptor, defaultExec );\n    }\n    return defaultExec( descriptor );\n}\n\n// Asks if prop is a multi-result field\nfunction isPropsList( prop ) {\n    return prop === Infinity || Array.isArray( prop );\n}\n\n// Resolves obj down to it's self\nfunction resolveObj( obj, assert = true ) {\n\tif ( ( !obj || !_isTypeObject( obj ) ) && assert ) throw new Error( `Object must be of type object or array! \"${ _getType( obj ) }\" given.` );\n    if ( obj instanceof Descriptor ) {\n        obj = obj.value;\n    }\n\treturn obj && unproxy( obj );\n}\n\n// Resolves prop down to actual keys\nfunction resolveProps( obj, prop, receiver, params = {} ) {\n    if ( prop === Infinity ) {\n        if ( params.level && !_isTypeObject( obj ) ) return receiver( [] );\n        return ownKeys( obj, receiver, params );\n    }\n    return receiver( _arrFrom( prop, false ) );\n}\n", "\r\n/**\r\n * Tells if val is pure object.\r\n *\r\n * @param object\t \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn !Array.isArray(val) && typeof val === 'object' && val;\r\n};\r\n", "\r\n/**\r\n * Returns the val's type.\r\n *\r\n * @param string \tval\r\n *\r\n * @return string\r\n */\r\nexport default function(val) {\r\n\treturn typeof val;\r\n};\r\n", "\r\n/**\r\n * Tells if val is of type \"array\".\r\n *\r\n * @param object\t \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn Array.isArray(val);\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isArray from '../js/isArray.js';\r\n\r\n/**\r\n * Returns the intersection of two arrays;\r\n * optionally using a custom matching function.\r\n *\r\n * @param array \tarr\r\n * @param array\t \tarr2\r\n * @param function \tcallback\r\n *\r\n * @return array\r\n */\r\nexport default function(arr, arr2, callback = null) {\r\n\treturn !_isArray(arr2) ? [] : arr.filter(val1 => callback \r\n\t\t? arr2.filter(val2 => callback(val1, val2)).length \r\n\t\t: arr2.indexOf(val1) !== -1\r\n\t);\r\n};\r\n", "/**\r\n * @imports\r\n */\r\nimport _intersect from '../arr/intersect.js';\r\n\r\n/**\r\n * Creates and/or returns an \"internals\" object for the given object.\r\n * \r\n * @param Any obj\r\n * @param String namespace\r\n * \r\n * @return Object\r\n */\r\nexport default function internals(obj, ...namespaces) {\r\n    if (!globalThis.webqit) { globalThis.webqit = {}; }\r\n    if (!globalThis.webqit.refs) {\r\n        Object.defineProperty(globalThis.webqit, 'refs', {value: new ObservableMap})\r\n    }\r\n    if (!arguments.length) return globalThis.webqit.refs;\r\n    let itnls = globalThis.webqit.refs.get(obj);\r\n    if (!itnls) {\r\n        itnls = new ObservableMap;\r\n        globalThis.webqit.refs.set(obj, itnls);\r\n    }\r\n    let _ns, _itnls;\r\n    while ((_ns = namespaces.shift())) {\r\n        if ((_itnls = itnls) && !(itnls = itnls.get(_ns))) {\r\n            itnls = new ObservableMap;\r\n            _itnls.set(_ns, itnls);\r\n        }\r\n    }\r\n    return itnls;\r\n}\r\n\r\nclass ObservableMap extends Map {\r\n    constructor( ...args ) {\r\n        super( ...args );\r\n        this.observers = new Set;\r\n    }\r\n    set( key, value ) {\r\n        let returnValue = super.set( key, value );\r\n        this.fire( 'set', key, value, key );\r\n        return returnValue;\r\n    }\r\n    delete( key ) {\r\n        let returnValue = super.delete( key );\r\n        this.fire( 'delete', key );\r\n        return returnValue;\r\n    }\r\n    has( key ) {\r\n        this.fire( 'has', key );\r\n        return super.has( key );\r\n    }\r\n    get( key ) {\r\n        this.fire( 'get', key );\r\n        return super.get( key );\r\n    }\r\n    keyNames() { return Array.from( super.keys() ); }\r\n    observe( type, key, callback ) {\r\n        const entry = { type, key, callback };\r\n        this.observers.add( entry );\r\n        return () => this.observers.delete( entry );\r\n    }\r\n    unobserve( type, key, callback ) {\r\n        if ( Array.isArray( type ) || Array.isArray( key ) ) {\r\n            throw new Error( `The \"type\" and \"key\" arguments can only be strings.` );\r\n        }\r\n        for ( let entry of this.observers ) {\r\n            if ( !( _intersection( [ type, '*' ], entry.type ) && _intersection( [ key, '*' ], entry.key ) && entry.callback === callback ) ) continue;\r\n            this.observers.delete( entry );\r\n        }\r\n    }\r\n    fire( type, key, ...args ) {\r\n        // IMPORTANT: Array.from() must be used so that new additions to this.observers\r\n        // during the loop aren't picked up!\r\n        for ( let entry of this.observers ) {\r\n            if ( !( _intersection( [ type, '*' ], entry.type ) && _intersection( [ key, '*' ], entry.key ) ) ) continue;\r\n            entry.callback( ...args );\r\n        }\r\n    }\r\n}\r\n\r\nconst _intersection = ( a, b ) => {\r\n    if ( Array.isArray( b ) ) return _intersect( a, b ).length;\r\n    return a.includes( b );\r\n}\r\n", "\r\n/**\r\n * Tells if val is of type \"function\".\r\n * This holds true for both regular functions and classes.\r\n *\r\n * @param object\t \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn typeof val === 'function';\r\n};\r\n", "\r\n/**\r\n * Tells if val is undefined or is null.\r\n *\r\n * @param string \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn val === null || val === '';\r\n};\r\n", "\r\n/**\r\n * Tells if val is undefined or is of type \"undefined\".\r\n *\r\n * @param string \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn arguments.length && (val === undefined || typeof val === 'undefined');\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isTypeFunction from './isTypeFunction.js';\r\n\r\n/**\r\n * Tells if val is of type \"object\".\r\n * This holds true for anything object, including built-ins.\r\n *\r\n * @param object\t \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn Array.isArray(val) || (typeof val === 'object' && val) || _isTypeFunction(val);\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isNull from './isNull.js';\r\nimport _isUndefined from './isUndefined.js';\r\nimport _isTypeObject from './isTypeObject.js';\r\n\r\n/**\r\n * Tells if val is empty in its own type.\r\n * This holds true for NULLs, UNDEFINED, FALSE, 0,\r\n * objects without keys, empty arrays.\r\n *\r\n * @param string \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn _isNull(val) || _isUndefined(val) || val === false || val === 0 \r\n\t\t|| (_isTypeObject(val) && !Object.keys(val).length);\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isTypeFunction from './isTypeFunction.js';\r\n\r\n/**\r\n * Tells if val is of type \"function\".\r\n *\r\n * @param object \t\tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn _isTypeFunction(val) || (val && {}.toString.call(val) === '[object function]');\r\n};\r\n", "\r\n/**\r\n * Tells if val is of type \"string\".\r\n *\r\n * @param string \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn val instanceof String || (typeof val === 'string' && val !== null);\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isString from './isString.js';\r\nimport _isUndefined from './isUndefined.js';\r\n\r\n/**\r\n * Tells if val is \"array-like\".\r\n * This holds true for anything that has a length property.\r\n *\r\n * @param object\t \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn !_isString(val) && !_isUndefined(val.length);\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isArray from '../js/isArray.js';\r\nimport _isTypeArray from '../js/isTypeArray.js';\r\nimport _isEmpty from '../js/isEmpty.js';\r\nimport _isObject from '../js/isObject.js';\r\n\r\n/**\r\n * Casts an array-like object to an array.\r\n *\r\n * @param mixed \tval\r\n * @param bool\t \tcastObject\r\n *\r\n * @return array\r\n */\r\nexport default function(val, castObject = true) {\r\n\tif (_isArray(val)) {\r\n\t\treturn val;\r\n\t};\r\n\tif (!castObject && _isObject(val)) {\r\n\t\treturn [val];\r\n\t};\r\n\tif (val !== false && val !== 0 && _isEmpty(val)) {\r\n\t\treturn [];\r\n\t};\r\n\tif (_isTypeArray(val)) {\r\n\t\treturn Array.prototype.slice.call(val);\r\n\t};\r\n\tif (_isObject(val)) {\r\n\t\treturn Object.values(val);\r\n\t};\r\n\treturn [val];\r\n};\r\n", "\n/**\n * @imports\n */\nimport { _internals } from '@webqit/util/js/index.js';\n\nexport const _ = ( ...args ) => _internals( 'observer-api', ...args );\n\nexport const _await = ( value, callback ) => value instanceof Promise ? value.then( callback ) : callback( value );\n\nexport const other = {};\n", "\n/**\n * ---------------------------\n * The Registration class\n * ---------------------------\n */\n\nexport default class Registration {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param Registry\t\t\tregistry\n\t * @param object\t\t\tdfn\n\t *\n\t * @return void\n\t */\n\tconstructor( registry, dfn ) {\n\t\tthis.registry = registry;\n\t\tObject.assign( this, { ...dfn, target: registry.target } );\n\t\tif ( this.params.signal ) {\n\t\t\tthis.params.signal.addEventListener( 'abort', () => this.remove() );\n\t\t}\n\t}\n\n\t/**\n\t * Sets a \"disconnected\" flag on the Registration.\n\t *\n\t * @return void\n\t */\n\tremove() {\n\t\tthis.removed = true;\n\t\treturn this.registry.removeRegistration( this );\n\t}\n}", "\n/**\n * @imports\n */\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport Registration from './Registration.js';\nimport { _await, other as otherUtil } from '../util.js';\n\n/**\n * ---------------------------\n * The ListenerRegistration class\n * ---------------------------\n */\n\nexport default class ListenerRegistration extends Registration {\n\t\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\tsuper( ...arguments );\n\t\tthis.emit.currentRegistration = this;\n\t\tObject.defineProperty( this, 'abortController', { value: new AbortController } );\n\t\tObject.defineProperty( this, 'signal', { value: this.abortController.signal } );\n\t\totherUtil.setMaxListeners?.( 0, this.signal );\n\t}\n\n\t/**\n\t * De-registers the instance.\n\t * \n\t * @return Void\n\t */\n\tremove() {\n\t\tthis.abortController.abort();\n\t\tsuper.remove();\n\t}\n\n\t/**\n\t * Calls the observer's handler function\n\t * on matching with the event's fields.\n\t *\n\t * @param Array\t\t\t \t\tevents\n\t *\n\t * @return Any\n\t */\n\tfire( events ) {\n\t\tif ( this.emit.recursionTarget && ![ 'inject', 'force-async', 'force-sync' ].includes( this.params.recursions ) ) return;\n\t\tlet matches = events, filter = this.filter;\n\t\tif ( filter !== Infinity && ( filter = _arrFrom( filter, false ) ) ) {\n\t\t\tmatches = events.filter( event => filter.includes( event.key ) );\n\t\t}\n\t\tif ( this.params.diff ) {\n\t\t\tmatches = matches.filter( event => event.type !== 'set' || event.value !== event.oldValue );\n\t\t}\n\t\tif ( matches.length ) {\n\t\t\tif ( this.emit.recursionTarget && this.params.recursions !== 'force-sync' ) {\n\t\t\t\tthis.emit.recursionTarget.push( ...matches );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.emit.recursionTarget = this.params.recursions === 'inject' ? matches : [];\n\t\t\tconst $ret = this.filter === Infinity || Array.isArray( this.filter )\n\t\t\t\t? this.emit( matches, this )\n\t\t\t\t: this.emit( matches[ 0 ], this );\n\t\t\t// NOTEL: on calling emit(), this registration has expired and a new one active!!!\n\t\t\treturn _await( $ret, ret => {\n\t\t\t\tconst recursions = this.emit.recursionTarget;\n\t\t\t\tdelete this.emit.recursionTarget;\n\t\t\t\tif ( this.params.recursions === 'force-async' ) {\n\t\t\t\t\tif ( recursions.length ) return this.emit.currentRegistration.fire( recursions );\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} );\n\t\t}\n\t}\n}\n", "\n/**\n * @imports\n */\nimport { _isTypeObject, _getType } from '@webqit/util/js/index.js';\nimport { _from as _arrFrom, _intersect, _equals as _arrEquals } from '@webqit/util/arr/index.js';\nimport { _ } from '../util.js';\n\n/**\n * ---------------------------\n * The Registry class\n * ---------------------------\n */\n\nexport default class Registry {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param object\ttarget\n\t * \n\t * @return void\n\t */\n\tconstructor( target ) {\n\t\tthis.target = target;\n\t\tthis.entries = [];\n\t}\n\t\n\t/**\n\t * Adds an Registration instance\n\t * with optional tags.\n\t *\n\t * @param Registration\t\tregistration\n\t *\n\t * @return Registration\n\t */\n\taddRegistration( registration ) {\n\t\tthis.entries.push( registration );\n\t\treturn registration;\n\t}\n\t\n\t/**\n\t * Removes registrations by reference.\n\t *\n\t * @param Registration\t\tregistration\n\t *\n\t * @return void\n\t */\n\tremoveRegistration( registration ) {\n\t\tthis.entries = this.entries.filter( _entry => _entry !== registration );\n\t}\n\t\t\n\t/**\n\t * Returns a observer-specific object embedded on an element.\n\t *\n\t * @param string\t\ttype\n\t * @param array|object\ttarget\n\t * @param bool      \tcreateIfNotExists\n\t * @param string      \tnamespace\n\t *\n\t * @return Registry\n\t */\n\tstatic _getInstance( type, target, createIfNotExists = true, namespace = this.__namespace ) {\n\t\tif ( !_isTypeObject( target ) ) throw new Error( `Subject must be of type object; \"${ _getType( target ) }\" given!` );\n\t\tlet ImplementationClass = this;\n\t\tif ( namespace && _( 'namespaces' ).has( type + '-' + namespace ) ) {\n\t\t\tImplementationClass = _( 'namespaces' ).get( type + '-' + namespace );\n\t\t\ttype += '-' + namespace\n\t\t}\n\t\tif ( !_( target, 'registry' ).has( type ) && createIfNotExists ) {\n\t\t\t_( target, 'registry' ).set( type, new ImplementationClass( target ) );\n\t\t}\n\t\treturn _( target, 'registry' ).get( type );\n\t}\n\n\t/**\n\t * Extend a Fireable Class with a namespace.\n\t *\n\t * @param string\t\tnamespace\n\t * @param class      \tImplementationClass\n\t *\n\t * @return void|class\n\t */\n\tstatic _namespace( type, namespace, ImplementationClass = null ) {\n\t\ttype += '-' + namespace;\n\t\tif ( arguments.length === 2 ) return _( 'namespaces' ).get( type );\n\t\tif ( !( ImplementationClass.prototype instanceof this ) ) {\n\t\t\tthrow new Error( `The implementation of the namespace ${ this.name }.${ namespace } must be a subclass of ${ this.name }.` );\n\t\t}\n\t\t_( 'namespaces' ).set( type, ImplementationClass );\n\t\tImplementationClass.__namespace = namespace;\n\t}\n}", "\n/**\n * ---------------------------\n * The Descriptor class\n * ---------------------------\n */\n\nexport default class Descriptor {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param array|object\ttarget\n\t * @param object\t\tdfn\n\t *\n\t * @return void\n\t */\n\tconstructor( target, dfn ) {\n\t\tthis.target = target;\n\t\tif ( !( dfn.operation ) ) throw new Error( 'Descriptor operation must be given in definition!' );\n\t\tObject.assign( this, dfn );\n\t}\n}", "\n/**\n * @imports\n */\nimport ListenerRegistration from './ListenerRegistration.js';\nimport Registry from './Registry.js';\nimport { _await } from '../util.js';\nimport Descriptor from './Descriptor.js';\n\n/**\n * ---------------------------\n * The ListenerRegistry class\n * ---------------------------\n */\n\nexport default class ListenerRegistry extends Registry {\n\n\tstatic getInstance( target, createIfNotExists = true, namespace = null ) {\n\t\treturn super._getInstance( 'listeners', ...arguments );\n\t}\n\n\tstatic namespace( namespace, ImplementationClass = null ) {\n\t\treturn super._namespace( 'listeners', ...arguments );\n\t}\n\n\t/**\n\t * @constructor\n\t */\n\tconstructor( target ) {\n\t\tsuper( target );\n\t\tthis.batches = [];\n\t}\n\t\n\t/**\n\t * @addRegistration\n\t */\n\taddRegistration( filter, emit, params ) {\n\t\treturn super.addRegistration( new ListenerRegistration( this, { filter, emit, params } ) );\n\t}\n\t\n\t/**\n\t * Fires all observers with the given evt (change).\n\t *\n\t * @param Arrayn events\n\t *\n\t * @return Void\n\t */\n\temit( events, isPropertyDescriptors = false ) {\n\t\tif ( this.batches.length ) {\n\t\t\tthis.batches[ 0 ].snapshots.push( { events: [ ...events ], isPropertyDescriptors } );\n\t\t\treturn\n\t\t}\n\t\tthis.$emit( this.entries, [ { events, isPropertyDescriptors } ] );\n\t}\n\n\t$emit( entries, snapshots ) {\n\t\tconst needsEventsWithDescriptors = entries.filter( listener => listener.params.withPropertyDescriptors ).length;\n\t\tconst hasEventsToTransform = snapshots.some( snapshot => snapshot.isPropertyDescriptors );\n\t\tconst eventsAsIs = [], eventsTransformed = [], entriesLength = entries.length;\n\t\tsnapshots.forEach( snapshot => {\n\t\t\t// Some need it untransformed (as-is)\n\t\t\tif ( needsEventsWithDescriptors || !hasEventsToTransform ) { eventsAsIs.push( ...snapshot.events ); }\n\t\t\t// It might not be all that need it untransformed, and there might be events to transform\n\t\t\tif ( needsEventsWithDescriptors !== entriesLength && hasEventsToTransform ) {\n\t\t\t\tif ( snapshot.isPropertyDescriptors ) {\n\t\t\t\t\teventsTransformed.push( ...snapshot.events.map( e => {\n\t\t\t\t\t\tlet { target, type, ...details } = e;\n\t\t\t\t\t\tconst desc = new Descriptor( target, { type: 'set', ...details } );\n\t\t\t\t\t\tObject.defineProperty( desc, 'value', 'get' in details.value ? { get: () => details.value.get() } : { value: details.value.value } )\n\t\t\t\t\t\tif ( details.oldValue ) {\n\t\t\t\t\t\t\tObject.defineProperty( desc, 'oldValue', 'get' in details.oldValue ? { get: () => details.oldValue.get() } : { value: details.oldValue.value } )\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn desc;\n\t\t\t\t\t} ) );\n\t\t\t\t} else { eventsTransformed.push( ...snapshot.events ); }\n\t\t\t}\n\t\t} );\n\t\tentries.forEach( listener => {\n\t\t\tif ( listener.params.withPropertyDescriptors ) {\n\t\t\t\tlistener.fire( eventsAsIs.length ? eventsAsIs : eventsTransformed );\n\t\t\t} else { listener.fire( eventsTransformed.length ? eventsTransformed : eventsAsIs ); }\n\t\t} );\n\t}\n\n\t/**\n\t * Fires all observers with the given evt (change).\n\t *\n\t * @param Arrayn events\n\t *\n\t * @return Void\n\t */\n\tbatch( callback ) {\n\t\tthis.batches.unshift( { entries: [ ...this.entries ], snapshots: [] } );\n\t\tconst returnValue = callback();\n\t\treturn _await( returnValue, returnValue => {\n\t\t\tconst batch = this.batches.shift();\n\t\t\tif ( !batch.snapshots.length ) return returnValue;\n\t\t\tthis.$emit( batch.entries, batch.snapshots );\n\t\t\treturn returnValue;\n\t\t} )\n\t}\n\n}", "\n/**\n * @imports\n */\nimport Registration from './Registration.js';\n\n/**\n * ---------------------------\n * The TrapsRegistration class\n * ---------------------------\n */\n\nexport default class TrapsRegistration extends Registration {\n\t\n\t/**\n\t * Calls the observer's handler function\n\t * on matching with the descriptor's fields.\n\t *\n\t * @param Descriptor\t\t\t \tdescriptor\n\t * @param function\t\t\t\t\tnext\n\t * @param mixed\t\t\t\t\t \trecieved\n\t *\n\t * @return void\n\t */\n\texec( descriptor, next, recieved ) {\n\t\tif ( this.running || !this.traps[ descriptor.operation ] ) {\n\t\t\treturn next( ...Array.prototype.slice.call( arguments, 2 ) );\n\t\t}\n\t\tthis.running = true;\n\t\treturn this.traps[ descriptor.operation ]( descriptor, recieved, ( ...args ) => {\n\t\t\tthis.running = false;\n\t\t\treturn next( ...args );\n\t\t} );\n\t}\n}", "\n/**\n * @imports\n */\nimport TrapsRegistration from './TrapsRegistration.js';\nimport Registry from './Registry.js';\n\n/**\n * ---------------------------\n * The TrapsRegistry class\n * ---------------------------\n */\n\nexport default class TrapsRegistry extends Registry {\n\n\tstatic getInstance( target, createIfNotExists = true, namespace = null ) {\n\t\treturn super._getInstance( 'traps', ...arguments );\n\t}\n\n\tstatic namespace( namespace, ImplementationClass = null ) {\n\t\treturn super._namespace( 'traps', ...arguments );\n\t}\n\t\n\t/**\n\t * @inheritdoc\n\t */\n\taddRegistration( dfn ) {\n\t\treturn super.addRegistration( new TrapsRegistration( this, dfn ) );\n\t}\n\n\t/**\n\t * Fires all interceptors with the given action.\n\t *\n\t * @param Descriptor\t\tdescriptor\n\t * @param function\t\t\tdefaultHandler\n\t *\n\t * @return mixed\n\t */\n\temit( descriptor, defaultHandler = null ) {\n\t\tconst $this = this;\n\t\treturn ( function next( index, ..._args ) {\n\t\t\tconst registration = $this.entries[ index ];\n\t\t\tif ( registration ) {\n\t\t\t\treturn registration.exec( descriptor, ( ...args ) => {\n\t\t\t\t\treturn next( index + 1, ...args );\n\t\t\t\t}/*next*/, ..._args );\n\t\t\t}\n\t\t\treturn defaultHandler ? defaultHandler( descriptor, ..._args ) : _args[ 0 ];\n\t\t} )( 0 );\n\t}\n}", "\n/**\n * @imports\n */\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport { _isClass, _isFunction, _isTypeObject, _getType } from '@webqit/util/js/index.js';\nimport { set, deleteProperty, has, get, ownKeys, defineProperty, getOwnPropertyDescriptor } from \"./main.js\";\nimport { batch, apply, construct, getPrototypeOf, setPrototypeOf, isExtensible, preventExtensions } from \"./main.js\";\nimport { _ } from './util.js';\n\n/* ---------------ACCESSORIZE METHODS--------------- */\n\n/**\n * Accessorizes props.\n *\n * @param Array|Object\ttarget\n * @param String|Array\tprops\n * @param Object\t\tparams\n *\n * @return Array\n */\nexport function accessorize( target, props, params = {} ) {\n    target = resolveTarget( target );\n    const accessorizedProps = _( target, 'accessorizedProps' );\n    // ---------\n    function getDescriptorDeep( prop ) {\n        let descriptor, proto = target;\n        do {\n            descriptor = Object.getOwnPropertyDescriptor( proto, prop );\n        } while ( !descriptor && ( proto = Object.getPrototypeOf( proto ) ) );\n        return descriptor \n            ? { proto, descriptor } \n            : { descriptor: { value: undefined, configurable: true, enumerable: true, writable: true } };\n    }\n    // ---------\n    function accessorizeProp( prop ) {\n        if ( accessorizedProps.has( prop + '' ) ) return true;\n        // ------------------\n        // Current Descriptor Record\n        const currentDescriptorRecord = getDescriptorDeep( prop );\n        currentDescriptorRecord.getValue = function( withPropertyDescriptors = false ) {\n            if ( withPropertyDescriptors ) return this.descriptor;\n            return this.descriptor.get ? this.descriptor.get() : this.descriptor.value;\n        };\n        currentDescriptorRecord.setValue = function( value, withPropertyDescriptors = false ) {\n            this.dirty = true;\n            if ( withPropertyDescriptors ) { this.descriptor = value; return; }\n            return this.descriptor.set ? this.descriptor.set( value ) !== false : ( this.descriptor.value = value, true );\n        };\n        currentDescriptorRecord.intact = function() {\n            const currentDescriptor = Object.getOwnPropertyDescriptor( target, prop );\n            return currentDescriptor?.get === accessorization.get \n                && currentDescriptor?.set === accessorization.set\n                && accessorizedProps.get( prop + '' ) === this;\n        };\n        currentDescriptorRecord.restore = function() {\n            if ( !this.intact() ) return false;\n            if ( ( this.proto && this.proto !== target ) || ( !this.proto && !this.dirty ) ) { delete target[ prop ]; }\n            else { Object.defineProperty( target, prop, this.descriptor ); }\n            accessorizedProps.delete( prop + '' );\n            return true;\n        };\n        accessorizedProps.set( !isNaN( prop ) ? parseInt( prop ) : prop, currentDescriptorRecord );\n        // ------------------\n        // enumerable, configurable\n        const { enumerable = true } = currentDescriptorRecord.descriptor;\n        const accessorization = { enumerable, configurable: true };\n        // set, get\n        if ( ( 'value' in currentDescriptorRecord.descriptor ) || currentDescriptorRecord.descriptor.set ) {\n            accessorization.set = function ( value ) { return set( this, prop, value, params ); };\n        }\n        if ( ( 'value' in currentDescriptorRecord.descriptor ) || currentDescriptorRecord.descriptor.get ) {\n            accessorization.get = function () { return get( this, prop, params ); };\n        }\n        try {\n            Object.defineProperty( target, prop, accessorization );\n            return true;\n        } catch( e ) {\n            accessorizedProps.delete( prop + '' );\n            return false;\n        }\n    }\n    const _props = Array.isArray( props ) ? props : (\n        props === undefined ? Object.keys( target ) : [ props ]\n    );\n    const statuses = _props.map( accessorizeProp );\n    return props === undefined || Array.isArray( props ) \n        ? statuses \n        : statuses[ 0 ];\n}\n\n/**\n * Unaccessorizes previously accessorized props.\n *\n * @param Array|Object\ttarget\n * @param String|Array\tprops\n * @param Object\t\tparams\n *\n * @return Array\n */\nexport function unaccessorize( target, props, params = {} ) {\n    target = resolveTarget( target );\n    const accessorizedProps = _( target, 'accessorizedProps' );\n    function unaccessorizeProp( prop ) {\n        if ( !accessorizedProps.has( prop + '' ) ) return true;\n        return accessorizedProps.get( prop + '' ).restore();\n    }\n    const _props = Array.isArray( props ) ? props : (\n        props === undefined ? Object.keys( target ) : [ props ]\n    );\n    const statuses = _props.map( unaccessorizeProp );\n    return props === undefined || Array.isArray( props ) \n        ? statuses \n        : statuses[ 0 ];\n}\n\n/* ---------------PROXY METHODS--------------- */\n\n/**\n * Returns an object as a proxy and binds all instance methods\n * to the proxy instead of the object itself.\n *\n * @param Array|Object\t\ttarget\n * @param Object\t\t    params\n * @param Function\t\t    extendCallback\n *\n * @return Proxy\n */\nexport function proxy( target, params = {}, extendCallback = undefined ) {\n    // Resolve target\n    const originalTarget = resolveTarget( target );\n    // Return same proxy instance?\n    if ( typeof params.membrane === 'boolean' ) throw new Error( `The params.membrane parameter cannot be of type boolean.` );\n    if ( params.membrane && _( originalTarget, 'membraneRef' ).has( params.membrane ) ) { return _( originalTarget, 'membraneRef' ).get( params.membrane ); }\n    const traps = {\n        apply( target, thisArgument, argumentsList ) {\n            if ( Array.isArray( thisArgument ) ) {\n                // Manually manage the length property\n                const originalThis = resolveTarget( thisArgument );\n                _( originalThis ).set( '$length', originalThis.length );\n                // And array methods have their operations batched\n                return batch( originalThis, () =>  apply( target, thisArgument, argumentsList ) );\n            }\n            return apply( target, unproxy( thisArgument ), argumentsList );\n        },\n        construct:  ( target, argumentsList, newTarget = null ) => construct( target, argumentsList, newTarget, params ),\n        defineProperty:  ( target, propertyKey, attributes ) => defineProperty( target, propertyKey, attributes, params ),\n        deleteProperty: ( target, propertyKey ) => deleteProperty( target, propertyKey, params ),\n        get: ( target, propertyKey, receiver = null ) => {\n            const $params = { ...params, receiver };\n            if ( Array.isArray( target ) && propertyKey === 'length' && _( target ).has( '$length' ) ) {\n                $params.forceValue = _( target ).get( '$length' );\n            }\n            const returnValue = get( target, propertyKey, $params );\n            if ( Array.isArray( target ) && typeof returnValue === 'function' ) {\n                // Return a proxy, but in terms of a membrane. \n                return proxy( returnValue, { ...params, membrane: receiver/* the instance obj that will be the thisArgument at apply(). Much like function.bind() */ } );\n            }\n            return returnValue;\n        },\n        getOwnPropertyDescriptor: ( target, propertyKey ) => getOwnPropertyDescriptor( target, propertyKey, params ),\n        getPrototypeOf: target => getPrototypeOf( target, params ),\n        has: ( target, propertyKey ) => has( target, propertyKey, params ),\n        isExtensible: target => isExtensible( target, params ),\n        ownKeys: target => ownKeys( target, params ),\n        preventExtensions: target => preventExtensions( target, params ),\n        set: ( target, propertyKey, value, receiver = null ) => {\n            const $params = { ...params, receiver };\n            if ( Array.isArray( target ) && propertyKey === 'length' ) {\n                $params.forceOldValue = _( target ).get( '$length' );\n                _( target ).set( '$length', value );\n            }\n            return set( target, propertyKey, value, $params );\n        },\n        setPrototypeOf: ( target, prototype ) => setPrototypeOf( target, prototype, params ),\n    };\n    // Extend...\n    const $traps = extendCallback?.( traps ) || traps;\n    // Create proxy\n    const $proxy = new Proxy( originalTarget, $traps );\n    if ( params.membrane ) { _( originalTarget, 'membraneRef' ).set( params.membrane, $proxy ); }\n    _( $proxy ).set( $proxy, originalTarget );\n\treturn $proxy;\n}\n\n/**\n * Returns the original object earlier proxied by proxy().\n *\n * @param Proxy|Any\t\ttarget\n *\n * @return Any\n */\nexport function unproxy( target ) {\n    // Proxy targets are mapped to their own instances internally\n    return _( target ).get( target ) || target;\n}\n\n/* ---------------HELPERS--------------- */\n\n/** \n * Ensures target object is an object or array.\n *\n * @param Array|Object\ttarget\n *\n * @return Array|Object\n */\nfunction resolveTarget( target ) {\n\tif ( !target || !_isTypeObject( target ) ) throw new Error('Target must be of type object!');\n\treturn unproxy( target );\n}\n", "\n/**\n * @imports\n */\nimport * as main from './main.js';\nimport * as actors from './actors.js';\n\nconst Observer = { ...main, ...actors };\n\nexport default Observer;", "\nexport const _call = ( _function, ...args ) => {\n    const callback = args.pop();\n    if ( _function.constructor.name === 'AsyncFunction' ) return _await( _function.call( ...args ), callback );\n    return callback( _function.call( ...args ) );\n};\n\nexport const _await = ( maybePromise, callback ) => {\n    return maybePromise instanceof Promise ? maybePromise.then( callback ) : callback( maybePromise )\n};\n\nexport const _isTypeObject = val => {\n\treturn ( typeof val === 'object' && val ) || typeof val === 'function';\n};\n\nexport function _$functionArgs( args ) {\n    const params = typeof args[ args.length - 1 ] === 'object' ? args.pop() : {};\n    const source = args.pop() || '';\n    params.functionParams = args;\n    return { source, params };\n}\n\nexport const other = {};\n", "\n/**\n * The modules registry\n */\nexport const registry = Object.create( null );", "/**\n * @imports\n */\nimport { other } from \"../util.js\";\n\nexport default class _EventTarget extends EventTarget {\n\n    managedAlways = new Set;\n    managedOnce = new Set;\n\n    constructor() {\n        super();\n        other.setMaxListeners?.( 0, this );\n    }\n\n    fire( evenName ) { return this.dispatchEvent( new Event( evenName, { cancelable: true } ) ); }\n\n    on( ...args ) {\n        this.addEventListener( ...args );\n        return () => this.removeEventListener( ...args );\n    }\n\n    abort( total = false ) {\n        this.managedAlways.forEach( x => x.abort ? x.abort( total ) : x( total ) );\n        this.managedOnce.forEach( x => x.abort ? x.abort( total ) : x( total ) );\n        this.managedOnce.clear();\n        this.fire( 'abort' );\n    }\n\n    manage( x ) { this.managedAlways.add( x ); }\n    once( x ) { this.managedOnce.add( x ); }\n\n}", "\n/**\n * @import\n */\nimport Observer from '@webqit/observer';\nimport { _isTypeObject } from '../util.js';\nimport EventTarget from './EventTarget.js';\n\nexport default class Signal extends EventTarget {\n\n    subscribers = new Set;\n    signals = new Map;\n\n    constructor( context, type, state ) {\n        super();\n        this.context = context;\n        this.context?.once( () => this.abort() );\n        this.once( () => this.watchMode( false ) );\n        this.type = type;\n        this.state = state;\n    }\n\n    get name() { return [ ...this.context?.signals.keys() || [] ].find( k => this.context.signals.get( k ) === this ); }\n   \n    signal( name, type = 'prop' ) {\n        let signal = this.signals.get( name );\n        if ( !signal ) {\n            // Initialization\n            signal = new Signal(\n                this,\n                type,\n                type === 'object' ? name : ( _isTypeObject( this.state ) ? Observer.get( this.state, name ) : undefined )\n            );\n            this.signals.set( name, signal );\n            // Self-start\n            if ( this.signals.size === 1 ) { this.watchMode(); }\n            // Cleanup\n            signal.once( () => {\n                // On being killed, auto-delete\n                this.signals.delete( name );\n                // On empty self-kill\n                if ( !this.signals.size ) { this.watchMode( false ); }\n            } );\n        }\n        return signal;\n    }\n\n    subscribe( autorun ) {\n        this.subscribers.add( autorun );\n        autorun.once( () => {\n            // Cleanup\n            this.subscribers.delete( autorun );\n            // On empty self-kill\n            if ( !this.subscribers.size ) { this.abort(); }\n        } );\n    }\n\n    watchMode( flag = true ) {\n        this.mutationsWatch?.abort();\n        if ( !flag || !this.signals.size || !_isTypeObject( this.state ) ) return;\n        this.mutationsWatch = Observer.observe( this.state, mutations => {\n            // Find subscribers and organize them by target runtime\n            const groupings = { map: new Map, add( autoruns, mutation ) {\n                for ( const autorun of autoruns ) {\n                    if ( autorun.spec.beforeSchedule?.( mutation ) === false ) continue;\n                    if ( !this.map.has( autorun.runtime ) ) { this.map.set( autorun.runtime, new Set ); }\n                    this.map.get( autorun.runtime ).add( autorun );\n                }\n            } };\n            for ( const mutation of mutations ) {\n                const signal = this.signals.get( mutation.key );\n                if ( !signal ) continue;\n                groupings.add( signal.subscribers, mutation );\n                signal.refresh( mutation.value );\n            }\n            // Dispatch to runtimes...\n            const runtimesMap = !groupings.map.size ? groupings.map : [ ...groupings.map ].sort( ( a, b ) => a.$serial > b.$serial ? -1 : 1 );\n            //const runtimesMap = groupings.map;\n            for ( const [ runtime, autoruns ] of runtimesMap ) {\n                if ( runtime.state === 'aborted' ) continue;\n                runtime.schedule( ...autoruns );\n            }\n        }, { recursions: 'force-sync' } );\n    }\n\n    refresh( newState ) {\n        this.state = newState;\n        for ( const [ name, signal ] of this.signals ) {\n            signal.refresh( Observer.get( this.state ?? {}, name ) );\n        }\n        this.watchMode();\n    }\n\n}", "\n/**\n * @import\n */\nimport Signal from './Signal.js';\n\nexport default class Scope extends Signal {\n\n    symbols = new Map;\n    constructor( context, type, state = undefined ) {\n        super( context, type, state || Object.create( null ) );\n    }\n\n}", "\n/**\n * @import\n */\nimport Observer from '@webqit/observer';\nimport { _await, _call } from '../util.js';\nimport EventTarget from './EventTarget.js';\nimport Scope from './Scope.js';\n\nexport default class Autorun extends EventTarget {\n\n    state;\n\n    constructor( context, type, spec, serial, scope, closure ) {\n        super();\n        // We are to be managed by context\n        context?.once( this );\n        this.context = context;\n        this.type = type;\n        this.spec = spec;\n        this.scope = scope;\n        if ( context?.scope !== scope ) {\n            // It's own scope, so we manage it\n            this.manage( scope );\n        }\n        this.serial = serial;\n        if ( closure ) { this.closure = closure; }\n        if ( context?.type === 'iteration' ) { this.path = context.path.concat( this.spec.index ); }\n        else if ( context?.type === 'round' ) { this.path = context.path.concat( this.serial ); }\n        else { this.path = ( context?.path || [] ).slice( 0, -1 ).concat( this.serial ); }\n        this.flowControl = new Map;\n    }\n\n    get runtime() { return this.context.runtime; }\n\n    contains( node ) { return this === node.context || ( node.context && this.contains( node.context ) ); }\n\n    order( node ) {\n        if ( !node ) return this;\n        const [ a, b ] = node.path.length < this.path.length ? [ node, this ] : [ this, node ];\n        return a.path.reduce( ( prev, key, i ) => {\n            return prev && key <= b.path[ i ];\n        }, true ) && a || b;\n    }\n\n    beforeExecute() {\n        this.state = 'running';\n        // Get record and reset\n        const flowControlBefore = this.flowControl;\n        this.flowControl = new Map;\n        return flowControlBefore;\n    }\n\n    execute( callback = null ) {\n        try {\n            this.runtime.thread.unshift( this );\n            return _await( this.beforeExecute(), stateBefore => {\n                return _call( this.closure, this, this, returnValue => {\n                    if ( this.spec.complete ) { returnValue = this.spec.complete( returnValue, this ); }\n                    this.afterExecute( stateBefore );\n                    this.runtime.thread.shift();\n                    return callback ? callback( returnValue, this ) : returnValue;\n                } );\n            } );\n        } catch( e ) {\n            // Show a nice error\n            if ( e.cause ) throw e;\n            const message = `${ e.message || e }`;\n            this.runtime.throw( message, [ this.serial, this.context?.serial ], globalThis[ e.name ] );\n        }\n    }\n\n    afterExecute( flowControlBefore ) {\n        this.state = 'complete';\n        // Compare records... and hoist differences\n        const flowControlAfter = this.flowControl;\n        // Handle downstream\n        this.handleDownstream( flowControlAfter.size, flowControlBefore.size );\n        this.handleRightstream( flowControlAfter.size, flowControlBefore.size );\n        for ( const cmd of [ 'break', 'continue', 'return' ] ) {\n            if ( flowControlAfter.has( cmd ) && !flowControlAfter.get( cmd ).endpoint ) { this.hoistFlowControl( cmd, flowControlAfter.get( cmd ).arg ); }\n            else if ( flowControlBefore.has( cmd ) && !flowControlBefore.get( cmd ).endpoint ) { this.hoistFlowControl( cmd, flowControlBefore.get( cmd ).arg, true ); }\n        }\n    }\n\n    typed( as, value, name = undefined ) {\n        const valueType = Array.isArray( value ) ? 'array' : ( value === null ? 'null' : typeof value );\n        if ( valueType === as || ( as === 'iterable' && value?.[ Symbol.iterator ] ) || ( as === 'desctructurable' && ![ 'undefined', 'null' ].includes( valueType ) ) ) return value;\n        if ( as === 'iterable' ) { throw new Error( `value is not iterable.` ); }\n        if ( as === 'desctructurable' ) { throw new Error( ( name ? `Cannot access ${ name }; ` : '' ) + `object not desctructurable.` ); }\n        throw new Error( `value must be of type ${ as }.` );\n    }\n\n    let( name, serial, closure, spec = {} ) { return this.var( name, serial, closure, { ...spec, kind: 'let' } ); }\n\n    const( name, serial, closure, spec = {} ) { return this.var( name, serial, closure, { ...spec, kind: 'const' } ); }\n\n    var( name, serial, closure, spec = {} ) {\n        spec = { kind: 'var'/* as default */, ...spec };\n        // Uninitialized declarations like: let a;\n        if ( !closure ) closure = () => undefined;\n        const $closure = !spec.restOf ? closure : ( ...args ) => {\n            try { return closure( ...args ); }\n            catch( e ) { throw new Error( `Cannot declare ${ name }; ${ e.message }` ); }\n        };\n        const complete = ( returnValue, autorun ) => {\n            let scope = spec.kind === 'var' ? this.runtime.scope : autorun.scope;\n            // For scripts, hoist all the way to the global scope... or somewhere before where its been defined\n            while ( spec.kind === 'var' && ![ 'module', 'function' ].includes( scope.type ) && !Observer.has( scope.state, name ) && scope.context ) {\n                scope = scope.context;\n            }\n            let symbolState = scope.symbols.get( name );\n            if ( symbolState && ( symbolState.kind !== spec.kind || ( spec.kind === 'let' && symbolState.serial !== serial ) ) ) {\n                throw new Error( `Identifier \"${ name }\" has already been declared.` );\n            }\n            symbolState?.reader?.abort(); // Any previous reader? Type \"var\" cannot rely on autorun lifecycle cleanup\n            symbolState = { serial, kind: spec.kind }; // New state!\n            let assignedValue = returnValue;\n            if ( spec.restOf ) {\n                if ( spec.type === 'array' ) {\n                    assignedValue = [];\n                } else { assignedValue = {}; }\n                symbolState.reader = Observer.read( returnValue, assignedValue, { except: spec.restOf, spread: spec.type === 'array' } );\n                autorun.once( symbolState.reader ); // Lifecycle cleanup\n            }\n            scope.symbols.set( name, symbolState );\n            Observer.set( scope.state, name, assignedValue );\n            return assignedValue;\n        };\n        return this.autorun( spec.kind, { complete, ...spec }, serial, $closure );\n    }\n\n    update( name, closure, spec = {} ) {\n        // Find lexical scope\n        let lexicalScope = this.scope;\n        while( lexicalScope && !Observer.has( lexicalScope.state, name ) ) { lexicalScope = lexicalScope.context; }\n        // Validation\n        if ( !lexicalScope ) { throw new ReferenceError( `${ name } is not defined.` ); }\n        let symbolState = lexicalScope.symbols.get( name );\n        if ( symbolState?.kind === 'const' ) { throw new ReferenceError( `Assignment to constant variable \"${ name }\".` ); }\n        const valueBefore = Observer.get( lexicalScope.state, name );\n        const $closure = !spec.restOf ? closure : ( ...args ) => {\n            try { return closure( ...args ); }\n            catch( e ) { throw new Error( `Cannot update ${ name }; ${ e.message }` ); }\n        };\n        return _call( $closure, undefined, valueBefore, returnValue => {\n            // Operation\n            symbolState?.reader?.abort(); // Any previous reader?\n            let assignedValue = returnValue;\n            if ( spec.restOf ) {\n                symbolState = symbolState || {}; // New state!\n                if ( spec.type === 'array' ) {\n                    assignedValue = [];\n                } else { assignedValue = {}; }\n                symbolState.reader = Observer.read( returnValue, assignedValue, { except: spec.restOf, spread: spec.type === 'array' } );\n                this.once( symbolState.reader ); // Lifecycle cleanup\n            }\n            // Set now!\n            Observer.set( lexicalScope.state, name, assignedValue );\n            return [ 'postinc', 'postdec' ].includes( spec.kind ) ? valueBefore : assignedValue;\n        } );\n    }\n\n    ref( name, ...rest ) {\n        let depth = 0, hint = {};\n        if ( typeof rest[ 0 ] === 'number' ) {\n            depth = rest.shift();\n            hint = rest.shift() || {};\n        } else if ( typeof rest[ 0 ] === 'object' ) {\n            hint = rest.shift();\n        }\n        // Find lexical scope\n        let lexicalScope = this.scope;\n        while( lexicalScope && !Observer.has( lexicalScope.state, name ) ) { lexicalScope = lexicalScope.context; }\n        // Not found?\n        if ( !lexicalScope ) {\n            if ( hint.isTypeCheck ) return;\n            throw new Error( `${ name } is not defined.` );\n        }\n        // Bind now?\n        const kind = lexicalScope.symbols.get( name )?.kind;\n        const baseSignal = lexicalScope.signal( name, kind );\n        if ( hint.typed ) { this.typed( hint.typed, baseSignal.state, name ); }\n        return this.autobind( baseSignal, depth, hint );\n    }\n\n    obj( val, ...rest ) {\n        let depth = 0, hint = {};\n        if ( typeof rest[ 0 ] === 'number' ) {\n            depth = rest.shift();\n            hint = rest.shift() || {};\n        } else if ( typeof rest[ 0 ] === 'object' ) {\n            hint = rest.shift();\n        }\n        return this.autobind( this.runtime.$objects.signal( val, 'object' ), depth, hint );\n    }\n\n    autobind( baseSignal, depth, hint ) {\n        const isStatefulFunction = this.runtime.$params.isStatefulFunction;\n        const isConst = baseSignal.type  === 'const';\n        const isRuntime = this === this.runtime;\n        const isAborted = this.state === 'aborted';\n        const nowRunning = this;\n        return ( function proxy( signal, depth ) {\n            // Do bindings first\n            if ( isStatefulFunction && !isConst && !isRuntime && !isAborted ) {\n                signal.subscribe( nowRunning );\n            }\n            // Return bare value here?\n            if ( !depth || !signal.state || typeof signal.state !== 'object' ) {\n                let returnValue = signal.state;\n                if ( typeof signal.state === 'function' ) {\n                    // We're returning a proxy for functions instead of: signal.context.state[ signal.name ].bind( signal.context.state );\n                    returnValue = Observer.proxy( signal.state, { membrane: signal } );\n                }\n                return returnValue;\n            }\n            // Return dynamic value\n            let propertyAlreadyBound;\n            return Observer.proxy( signal.state, {}, traps => ( {\n                ...traps,\n                get( target, name, receiver = null ) {\n                    // Constructs are always going to for one property access: ref('a').b, and we need to prevent .c from creating a binding\n                    if ( propertyAlreadyBound ) { return traps.get( target, name, receiver ); }\n                    propertyAlreadyBound = true;\n                    return proxy( signal.signal( name ), depth - 1 );\n                },\n            } ) );\n        } )( baseSignal, depth );\n    }\n\n    autorun( type, ...rest ) {\n        let closure = rest.pop();\n        const serial = rest.pop();\n        const spec = rest.pop() || {};\n        // Handle certain types with their own class\n        let AutorunClass = Autorun, scope = this.scope;\n        if ( type === 'iteration' ) {\n            const staticDefs = this.runtime.constructor;\n            AutorunClass = closure.constructor.name === 'AsyncFunction' ? staticDefs.AutoAsyncIterator : staticDefs.AutoIterator;\n        }\n        if ( [ 'block', 'iteration' ].includes( type ) ) { scope = new Scope( scope, type ); }\n        // Instantiate\n        const autorun = new AutorunClass( this, type, spec, serial, scope, closure );\n        if ( type === 'downstream' ) {\n            // Declare a \"downstream\" for the context\n            this.downstream = autorun;\n            // For now\n            if ( this.flowControlApplied() ) return;\n        }\n        // Push stack and execute\n        return autorun.execute();\n    }\n\n    function( isDeclaration, isStatefulFunction, serial, $function ) {\n        // Declare in current scope\n        if ( isDeclaration ) { Observer.set( this.scope.state, $function.name, $function ); }\n        // Metarise function\n        const _this = this;\n        Object.defineProperty( $function, 'toString', { value: function( $fSource = false ) {\n            if ( $fSource && isStatefulFunction ) return Function.prototype.toString.call( $function );\n            const originalSource = _this.runtime.extractSource( serial );\n            return originalSource.startsWith( 'static ' ) ? originalSource.replace( 'static ', '' ) : originalSource;\n        } } );\n        return $function;\n    }\n\n    class( isDeclaration, $class, methodsSpec ) {\n        // Declare in current scope\n        if ( isDeclaration ) { Observer.set( this.scope.state, $class.name, $class ); }\n        // Metarise methods\n        methodsSpec.forEach( ( { name, static: isStatic, isStatefulFunction, serial } ) => {\n            this.function( false, isStatefulFunction, serial, isStatic ? $class[ name ] : $class.prototype[ name ] )\n        } );\n        return $class;\n    }\n\n    async import( ...args ) { return this.runtime.import( ...args ); }\n\n    async export( ...args ) { return this.runtime.export( ...args ); }\n\n    continue( label ) { return this.applyFlowControl( 'continue', label ); }\n\n    break( label ) { return this.applyFlowControl( 'break', label ); }\n\n    return( arg ) { return this.applyFlowControl( 'return', arg ); }\n\n    applyFlowControl( cmd, arg, unset = false ) {\n        const sizeBefore = this.flowControl.size;\n        if ( unset ) { this.flowControl.delete( cmd ); }\n        else { this.flowControl.set( cmd, { arg } ); }\n        if ( this.type === 'round' ) { this.context.breakpoint = this; }\n        if ( this.type === 'round' && [ 'break', 'continue' ].includes( cmd ) && arg === this.context?.spec.label ) {\n            if ( !unset ) { this.flowControl.get( cmd ).endpoint = true; }\n            if ( this.state !== 'running' ) { this.handleRightstream( this.flowControl.size, sizeBefore ); }\n            return;\n        }\n        // Notice that no hoisting and no \"downstream\" handling if in active scope\n        // as that would be done at after() hook!\n        if ( this.state !== 'running' ) {\n            this.handleDownstream( this.flowControl.size, sizeBefore );\n            this.hoistFlowControl( ...arguments );\n        }\n    }\n\n    hoistFlowControl( ...args ) { return this.context?.applyFlowControl( ...args ); }\n\n    flowControlApplied( cmd, arg ) {\n        if ( !arguments.length ) return this.flowControl.size || false;\n        if ( arguments.length === 1 ) return this.flowControl.has( cmd );\n        return this.flowControl.get( cmd )?.arg === arg;\n    }\n\n    handleDownstream( sizeAfter, sizeBefore ) {\n        let downstream;\n        if ( this.type !== 'block' // If this is \"downstream\", the \"downstream\" you see from parent scope will be self\n        || !( downstream = this.context?.downstream ) ) return;\n        if ( sizeAfter ) { downstream.abort(); }\n        else if ( sizeBefore ) {\n            downstream.state = 'resuming'; // Just something other than \"aborted\"\n            this.runtime.schedule( downstream );\n        }\n    }\n\n    handleRightstream( sizeAfter, sizeBefore ) {\n        if ( this.type !== 'round' ) return;\n        let nextRound = this, returnees = new Set;\n        while( nextRound = nextRound.nextRound ) {\n            if ( sizeAfter ) { nextRound.abort(); }\n            else if ( sizeBefore && nextRound.state !== 'inert' ) {\n                nextRound.state = 'resuming'; // Just something other than \"aborted\"\n                returnees.add( nextRound );\n            }\n        }\n        if ( returnees.size ) { this.runtime.schedule( ...returnees ); }\n        if ( !sizeAfter && sizeBefore ) {\n            this.runtime.on( 'reflection', () => {\n                if ( this.context.iterating ) return;\n                this.context.iterate();\n            }, { once: true } );\n        }\n    }\n\n    abort( total = false ) {\n        if ( total ) {\n            if ( this.context?.breakpoint === this ) { delete this.context.breakpoint; }\n            this.flowControl.clear();\n        }\n        this.state = total ? 'inert' : 'aborted';\n        return super.abort( total );\n    }\n    \n}", "\n/**\n * @import\n */\nimport { _await } from '../util.js';\nimport Observer from '@webqit/observer';\nimport Autorun from './Autorun.js';\nimport Scope from './Scope.js';\n\nexport default class AutoIterator extends Autorun {\n\n    rounds = new Map;\n\n    constructor( context, type, spec, serial, scope, closure ) {\n        spec.$closure = closure;\n        super( context, type, spec, serial, scope );\n        this.manage( () => {\n            delete this.breakpoint;\n            this.rounds.clear();\n        } );\n    }\n\n    pseudorun( callback ) {\n        this.runtime.iThread.unshift( this );\n        return _await( callback(), returnValue => {\n            this.runtime.iThread.pop();\n            return returnValue;\n        } );\n    }\n\n    createIterator() {\n        if ( this.spec.kind === 'for-in' ) return ( function* () { for ( let key in this.iteratee ) yield key; } ).call( this );\n        if ( this.spec.kind === 'for-of' ) return ( function* () { for ( let val of this.iteratee ) yield val; } ).call( this );\n        return { next: () => ({ done: !this.pseudorun( () => this.spec.test( this ) ), }), };\n    }\n\n    closure() {\n        if ( [ 'for-of', 'for-in' ].includes( this.spec.kind ) ) {\n            [ this.production, this.iteratee ] = this.spec.parameters( this );\n            this.iterator = this.createIterator();\n            this.iterator.original = true;\n            this.watchMode();\n        } else {\n            if ( this.spec.kind === 'for' ) { this.spec.init( this ); }\n            this.iterator = this.createIterator();\n        }\n        this.iterate();\n    }\n\n    terminated() { return this.breakpoint && !this.breakpoint.flowControlApplied( 'continue', this.spec.label ) && this.breakpoint.flowControlApplied(); }\n    advance() { if ( this.spec.kind === 'for' ) { this.pseudorun( () => this.spec.advance( this ) ); } }\n\n    iterate() {\n        this.iterating = true;\n        const $test = () => !this.terminated()/* must come before */ && !( this.cursor = this.iterator.next() ).done;\n        const $round = () => {\n            const round = this.createRound( this.cursor.value );\n            round.execute();\n            this.advance();\n        };\n        if ( this.spec.kind === 'do-while' ) { do $round(); while ( $test() ); }\n        else { while ( $test() ) $round(); }\n        this.iterating = false;\n    }\n\n    createRound( production ) {\n        const index = this.rounds.size, spec = { index };\n        // The scope instance starts life with the variables that the iteration round should see.\n        const state = [ 'for-in', 'for-of' ].includes( this.spec.kind ) ? { [ this.production ]: production } : { ...this.scope.state };\n        const scope = new Scope( this.scope, 'round', state );\n        this.scope.symbols.forEach( ( meta, name ) => { scope.symbols.set( name, meta ); } );\n        const round = new Autorun( this, 'round', spec, this.serial, scope, this.spec.$closure );\n        const key = this.spec.kind === 'for-in' ? production : index;\n        this.rounds.set( key, round );\n        if ( this.lastRound ) {\n            this.lastRound.nextRound = round;\n            round.prevRound = this.lastRound;\n        }\n        this.lastRound = round;\n        return round;\n    }\n\n    watchMode() {\n        const handleMutations = ( mutations, currentCursor ) => {\n            const deletions = new Set, extension = new Set;\n            for ( const mutation of mutations ) {\n                if ( Array.isArray( this.iteratee ) && mutation.key === 'length' ) continue;\n                const production = this.spec.kind === 'for-in' ? mutation.key : mutation.value;\n                const key = this.spec.kind === 'for-in' ? mutation.key : parseInt( mutation.key );\n                const existingRound = this.rounds.get( key ); // Note that we're not using has()\n                if ( existingRound ) {\n                    // This is an existing round\n                    Observer.set( existingRound.scope.state, this.production, production );\n                    if ( mutation.type === 'delete' ) {\n                        this.rounds.set( key, undefined ); // No actual deletions here as this.rounds.size is our index\n                        if ( existingRound.prevRound ) { existingRound.prevRound.nextRound = existingRound.nextRound; }\n                        if ( existingRound.nextRound ) { existingRound.nextRound.prevRound = existingRound.prevRound; }\n                        // Fired above for the last time and now should die\n                        deletions.add( existingRound );\n                    }\n                } else if ( mutation.type !== 'delete' && !mutation.isUpdate ) {\n                    // This is a brand new entry\n                    // Deletions and updates that didn't have an existing round above are obviously awaiting visit from a paused loop\n                    if ( this.spec.kind === 'for-of' && this.iterator.original && !currentCursor.done ) continue; // A live iteration is going on\n                    extension.add( production );\n                }\n            }\n            this.runtime.on( 'reflection', () => {\n                deletions.forEach( deletion => deletion.abort( true ) );\n            }, { once: true } );\n            if ( extension.size ) {\n                this.iterator = ( function* ( parent ) {\n                    yield* parent;\n                    yield* extension;\n                } )( this.iterator );\n                if ( currentCursor.done ) { this.iterate(); }\n            }\n        };\n        this.once( Observer.observe( this.iteratee, mutations => {\n            _await( this.cursor, currentCursor => handleMutations( mutations, currentCursor ) );\n        } ) );\n    }\n    \n}", "\n/**\n * @import\n */\nimport AutoIterator from './AutoIterator.js';\n\nexport default class AutoAsyncIterator extends AutoIterator {\n\n    async createIterator() {\n        if ( this.spec.kind === 'for-in' ) return ( function* () { for ( let key in this.iteratee ) yield key; } ).call( this );\n        if ( this.spec.kind === 'for-of' ) return ( function* () { for ( let val of this.iteratee ) yield val; } ).call( this );\n        return { next: async () => ({ done: !( await this.pseudorun( () => this.spec.test( this ) ) ), }), };\n    }\n\n    async closure() {\n        if ( [ 'for-of', 'for-in' ].includes( this.spec.kind ) ) {\n            [ this.production, this.iteratee ] = await this.spec.parameters( this );\n            this.iterator = await this.createIterator();\n            this.iterator.original = true;\n            this.watchMode();\n        } else {\n            if ( this.spec.kind === 'for' ) { await this.spec.init( this ); }\n            this.iterator = await this.createIterator();\n        }\n        await this.iterate();\n    }\n\n    async iterate() {\n        let cursor; this.iterating = true;\n        const $test = async () => ( !this.terminated()/* must come before */ && ( this.cursor = this.iterator.next() ) && ( cursor = await this.cursor ) && !cursor.done );\n        const $round = async () => {\n            const round = this.createRound( cursor.value );\n            await round.execute();\n            await this.advance();\n        };\n        if ( this.spec.kind === 'do-while' ) { do await $round(); while ( await $test() ); }\n        else { while ( await $test() ) await $round(); }\n        this.iterating = false;\n    }\n\n}", "\n/**\n * @imports\n */\nimport Observer from \"@webqit/observer\";\n\nexport default class State {\n\n    constructor( runtime ) {\n        Object.defineProperty( this, 'runtime', { value: runtime } );\n        const events = { statechange: () => { Observer.defineProperty( this, 'value', { value: runtime.flowControl.get( 'return' )?.arg, enumerable: true, configurable: true } ); }, };\n        for ( const name in events ) {\n            runtime.on( name, events[ name ] );\n            events[ name ]();\n        }\n        if ( runtime.$params.sourceType === 'module' ) {\n            Object.defineProperty( this, 'exports', { value: runtime.exports } );\n        }\n    }\n    \n    dispose() { return this.runtime.abort( true ); }\n\n}\n", "\n/**\n * @import\n */\nimport Observer from '@webqit/observer';\nimport { _await } from '../util.js';\nimport { registry } from './hot-module-registry.js';\nimport AutoAsyncIterator from './AutoAsyncIterator.js';\nimport AutoIterator from './AutoIterator.js';\nimport Autorun from './Autorun.js';\nimport Scope from './Scope.js';\nimport State from './State.js';\n\nexport default class Runtime extends Autorun {\n\n    static AutoAsyncIterator = AutoAsyncIterator;\n    static AutoIterator = AutoIterator;\n\n    locations = [];\n    queue = new Set;\n    thread = [];\n    iThread = [];\n\n    constructor( context, type, params, scope, closure ) {\n        super( context, type, {}/* spec */, -1, scope, closure );\n        const { $serial = 0, ...$params } = params;\n        this.$serial = $serial;\n        this.$params = $params;\n        // Random object\n        this.$objects = new Scope( undefined, 'objects' );\n        this.manage( this.$objects );\n        // Imports/exports\n        this.exports = Object.create( null );\n        this.$promises = { imports: [], exports: [] };\n        this.manage( () => {\n            Observer.deleteProperties( this.exports, Object.keys( this.exports ) );\n            this.$promises.imports.splice( 0 );\n            this.$promises.exports.splice( 0 );\n        } );\n    }\n\n    extractSource( serial, full = false ) {\n        const [ [ locStart, line, column ], [ locEnd ] ] = this.locations[ serial ];\n        const expr = this.$params.originalSource.slice( locStart, locEnd );\n        return full ? { expr, line, column } : expr;\n    }\n\n    throw( message, serials, ErrorClass = null, errorCode = null ) {\n        let error, $message = errorCode !== null ? `[${ errorCode }]: ${ message }` : message;\n        const cause = serials.map( serial => serial !== -1 && this.extractSource( serial, true ) ).filter( x => x );\n        cause.push( { source: this.$params.originalSource } );\n        error = new ( ErrorClass || Error )( $message, { cause } );\n        const fileName = this.$params.sourceType === 'module' && this.$params.experimentalFeatures !== false && this.$params.exportNamespace || this.$params.fileName;\n        if ( fileName ) { error.fileName = fileName; }\n        if ( errorCode ) { error.code = errorCode; }\n        throw error;\n    }\n\n    get runtime() { return this; }\n\n    get nowRunning() { return this.thread[ 0 ]; }\n\n    schedule( ...autoruns ) {\n        // Determine if active beforehand\n        const isActive = this.queue.size;\n        for ( const autorun of autoruns ) { this.queue.add( autorun ); }\n        if ( isActive ) return;\n        // Event Loop\n        this.flowControlDirty = false;\n        return ( function nextTick( prevReturn, current ) {\n            // Find following...\n            let following;\n            for ( const autorun of this.queue ) {\n                // If autorun is higher in source ignore\n                // Or a parent autorun has already been run in this event loop which started by aborting all descendants\n                // Or the unique situation with \"for\" loops where \"test\" and \"update\" expressions tend to self-schedule the AutoIteration instance.\n                if ( current && current.order( autorun ) !== current || [ 'aborted', 'running' ].includes( autorun.state ) || this.iThread[ 0 ]?.contains( autorun ) ) {\n                    this.queue.delete( autorun ); continue;\n                }\n                // Get $autorun to be very next to _this.currentMicro\n                following = following ? following.order( autorun ) : autorun;\n                if ( !current ) { current = following; }\n            }\n            // Fire events\n            if ( !following ) {\n                this.fire( 'reflection' );\n                if ( this.flowControlApplied() ) { this.fire( 'statechange' ); }\n                return prevReturn;\n            }\n            // Execute following...\n            following.abort();\n            // Evaluate and possibly await...\n            return following.execute( returnValue => {\n                // Remove from queue\n                this.queue.delete( following );\n                // Next tick\n                return nextTick.call( this, returnValue, following );\n            } );\n        } ).call( this, undefined, this.nowRunning );\n    }\n\n    execute( callback = null ) {\n        return super.execute( returnValue => {\n            const actualReturnValue = this.$params.isStatefulFunction\n                ? new State( this )\n                : returnValue;\n            return callback ? callback( actualReturnValue, this ) : actualReturnValue;\n        } );\n    }\n\n    spawn( isStatefulFunction, thisContext, closure ) {\n        const context = this.nowRunning || this;\n        const params = {  ...this.$params, $serial: this.$serial + 1, isStatefulFunction };\n        const scope = new Scope( context.scope, 'function', { [ 'this' ]: thisContext } );\n        const subRuntime = new this.constructor( context, 'function', params, scope, closure );\n        return subRuntime.execute();\n    }\n\n    async import( ...args ) {\n        const source = args.pop();\n        const $source = typeof source === 'string' ? { source } : source;\n        const onload = modules => {\n            if ( $source.forExport || $source.isDynamic ) return modules;\n            this.assignModules( args, this.scope.state, modules, source.serial );\n        };\n        if ( this.$params.experimentalFeatures !== false && registry[ $source.source ] ) {\n            return onload( registry[ $source.source ] );\n        }\n        const promise = ( async () => {\n            const moduleName = this.$params.sourceType === 'module' && this.$params.experimentalFeatures !== false && this.$params.exportNamespace || this.$params.fileName;\n            try { return onload( await import( $source.source ) ); } catch( e ) {\n                if ( e.code === 'ERR_MODULE_NOT_FOUND' ) { this.throw( `Cannot find package \"${ $source.source }\"${ moduleName ? ` imported at \"${ moduleName }\"` : '' }.`, [ $source.serial ], null, e.code ); }\n                throw e;\n            }\n        } )();\n        if ( !$source.isDynamic ) {\n            this.$promises[ $source.forExport ? 'exports' : 'imports' ].push( promise );\n        }\n        return promise;\n    }\n\n    async export( ...args ) {\n        const source = !Array.isArray( args[ args.length - 1 ] ) ? args.pop() : null;\n        // Export from source or from top-level scope!\n        const modules = source ? await this.import( { ...source, forExport: true } ) : this.scope.state;\n        // Assign imported modules to exports object\n        this.assignModules( args, this.exports, modules, source?.serial );\n    }\n\n    assignModules( specifiers, target, source, sourceSerial = null ) {\n        const observeList = [];\n        for ( const [ local, serial, alias ] of specifiers ) {\n            if ( local === '*' && alias ) {\n                Observer.set( target, alias, source );\n                continue;\n            }\n            if ( !Observer.has( source, local ) ) { this.throw( `The requested module does not provide an export named \"${ local }\".`, [ serial, sourceSerial ] ); }\n            Observer.set( target, alias || local, Observer.get( source, local ) );\n            observeList.push( [ local, serial, alias ] );\n        }\n        if ( !observeList.length ) return;\n        this.once( Observer.observe( source, mutations => {\n            for ( const [ local, /* serial */, alias ] of observeList ) {\n                for ( const mutation of mutations ) {\n                    if ( local === '*' ) { Observer.set( target, mutation.key, mutation.value ); }\n                    else if ( mutation.key === local ) { Observer.set( target, alias || local, mutation.value ); }                    \n                }\n            }\n        } ) );\n    }\n    \n    afterExecute( ...args ) {\n        if ( this.$params.sourceType === 'module' && this.$params.experimentalFeatures !== false && this.$params.exportNamespace ) {\n            registry[ this.$params.exportNamespace ] = this.exports;\n            this.once( () => { delete registry[ this.$params.exportNamespace ]; } );\n        }\n        return super.afterExecute( ...args );\n    }\n\n}", "\n/**\n * @imports\n */\nimport { _await } from '../util.js';\nimport { resolveParams } from '../params.js';\nimport Runtime from './Runtime.js';\nimport Scope from './Scope.js';\nimport State from './State.js';\n\nexport { State, Runtime }\n\nexport function $eval( sourceType, parseCompileCallback, source, params ) {\n    // params could have: env, functionParams, parserParams, compilerParams, runtimeParams\n    const { env, functionParams = [], exportNamespace, fileName } = params;\n    const { parserParams, compilerParams, runtimeParams, } = resolveParams( params );\n\n    // Format source? Mode can be: function, async-function, script, async-script, module\n    if ( sourceType === 'module' ) {\n        parserParams.sourceType = sourceType;\n        parserParams.allowAwaitOutsideFunction = true;\n    } else if ( [ 'function', 'async-function' ].includes( sourceType ) ) {\n        // Design the actual stateful function\n        const body = `  ` + source.split( `\\n` ).join( `\\n  ` );\n        source = `return ${ sourceType === 'async-function' ? 'async ' : '' }function**(${ functionParams.join( ', ' ) }) {\\n${ body }\\n}`;\n        compilerParams.startStatic = true;\n    } else if ( ![ 'script', 'async-script' ].includes( sourceType ) ) {\n        throw new Error( `Unrecognized sourceType specified: \"${ sourceType }\".` );\n    }\n\n    // Proceed to parse-compile\n    compilerParams.sourceType = sourceType;\n    const compiledSource = parseCompileCallback( source, { parserParams, compilerParams } );\n    if ( compiledSource instanceof Promise && ![ 'async-function', 'async-script', 'module' ].includes( sourceType ) ) {\n        throw new Error( `Parse-compile can only return a Promise for sourceTypes: async-function, async-script, module.` );\n    }\n\n    // Proceed to eval\n    runtimeParams.sourceType = sourceType;\n    runtimeParams.exportNamespace = exportNamespace;\n    runtimeParams.fileName = fileName;\n    return _await( compiledSource, compiledSource => {\n        // Below, \"async-function\" would already has async in the returned function\n        // And no need to ask compiledSource.topLevelAwait\n        const asyncEval = [ 'async-script', 'module' ].includes( sourceType );\n        const $eval = ( params, source ) => {\n            if ( runtimeParams.compileFunction ) return runtimeParams.compileFunction( source, params );\n            return new ( asyncEval ? ( async function() {} ).constructor : Function )( ...params.concat( source ) );\n        };\n        const main = $eval( [ compiledSource.identifier + '' ], compiledSource + '' );\n        const isFunction = [ 'function', 'async-function' ].includes( sourceType );\n        const createRuntime = thisContext => {\n            let $main = main;\n            if ( thisContext ) { $main = $main.bind( thisContext ); }\n            // There's always a global scope\n            let contextType = 'global', scope = new Scope( undefined, contextType, globalThis );\n            // Then this, for script scope, which may also directly reflect/mutate any provided \"env\"\n            if ( sourceType.endsWith( 'script' ) || env ) { contextType = 'env'; scope = new Scope( scope, contextType, env ); }\n            // Or this for module scope. And where \"env\" was provided, the \"env\" scope above too\n            if ( sourceType === 'module' ) { contextType = 'module'; scope = new Scope( scope, contextType ); }\n            if ( typeof thisContext !== 'undefined' ) { scope = new Scope( scope, 'this', { [ 'this' ]: thisContext } ); }\n            return new Runtime( undefined, contextType, { ...runtimeParams, originalSource: compiledSource.originalSource, isStatefulFunction: !isFunction }, scope, $main );\n\n        };\n        return isFunction\n            ? createRuntime().execute() // Produces the actual stateful function designed above\n            : { createRuntime, compiledSource };\n    } );\n}\n", "\n/**\n * @imports\n */\nimport { _await } from './util.js';\nimport { $eval, State } from './runtime/index.js';\n\n/**\n * @Script\n */\nexport default class AbstractStatefulScript {\n    constructor( ...args ) {\n        const $static = this.constructor;\n        const params = typeof args[ args.length - 1 ] === 'object' ? args.pop() : {};\n        const source = args.pop() || '';\n        this.$program = $eval( $static.sourceType, $static.parseCompileCallback, source, params );\n    }\n\n    execute() { return _await( this.$program, ( { createRuntime } ) => createRuntime().execute() ); }\n\n    bind( thisContext ) { return _await( this.$program, ( { createRuntime } ) => createRuntime( thisContext ) ); }\n\n    toString( $fSource = false ) {\n        return _await( this.$program, ( { compiledSource } ) => {\n            if ( $fSource ) return compiledSource + '';\n            return compiledSource.originalSource;\n        } );\n    }\n}", "\n/**\n * @imports\n */\nimport Observer from '@webqit/observer';\nimport { _$functionArgs } from './util.js';\nimport { $eval } from './runtime/index.js';\nimport AbstractStatefulScript from './AbstractStatefulScript.js';\nimport State from './runtime/State.js';\n\n/** -------------- APIs */\n\nexport { Observer, State }\n\nexport function StatefulAsyncFunction( ...args ) {\n    const { source, params } = _$functionArgs( args );\n    const compiledFunction = $eval( 'async-function', parseCompileCallback, source, params );\n    if ( !( compiledFunction instanceof Promise ) ) return compiledFunction;\n    // Introduce a wrapper function that awaits main function\n    const wrapperFunction = async function( ...args ) { return ( await compiledFunction ).call( this, ...args ); }\n    Object.defineProperty( wrapperFunction, 'toString', { value: async function( ...args ) { return ( await compiledFunction ).toString( ...args ) } } )\n    return wrapperFunction;\n}\n\nexport class StatefulAsyncScript extends AbstractStatefulScript {\n    static sourceType = 'async-script';\n    static parseCompileCallback = parseCompileCallback;\n}\n\nexport class StatefulModule extends AbstractStatefulScript {\n    static sourceType = 'module';\n    static parseCompileCallback = parseCompileCallback;\n}\n\n/** -------------- parse-compile */\n\nfunction parseCompileCallback( ...args ) {\n    const params = typeof args[ args.length - 1 ] === 'object' ? args.pop() : {};\n    const source = args.pop() || '';\n    // $fCompiler has been loaded sync?\n    if ( globalThis.webqit?.$fCompiler ) {\n        const { parse, compile } = globalThis.webqit.$fCompiler;\n        const ast = parse( source, params.parserParams );\n        return compile( ast, params.compilerParams );\n    }\n    // Load and run $fCompiler async - in the background?\n    globalThis.webqit = globalThis.webqit || {};\n    if ( !globalThis.webqit.$fCompilerWorker ) {\n        const customUrl = document.querySelector( 'meta[name=\"$f-compiler-url\"]' );\n        const compilerUrls = ( customUrl?.content.split( ',' ) || [] ).concat( 'https://unpkg.com/@webqit/stateful-js/dist/compiler.js' );\n        const workerScriptText = `\n        const compilerUrls = [ '${ compilerUrls.join( `','` ) }' ];\n        ( function importScript() {\n            try { importScripts( compilerUrls.shift().trim() ) } catch( e ) { if ( compilerUrls.length ) { importScript(); } }\n        } )();\n        const { parse, compile } = globalThis.webqit.$fCompiler;\n        globalThis.onmessage = e => {\n            const { source, params } = e.data;\n            const ast = parse( source, params.parserParams );\n            const compilation = compile( ast, params.compilerParams );\n            e.ports[ 0 ]?.postMessage( {\n                identifier: compilation.identifier,\n                originalSource: compilation.originalSource,\n                compiledSource: compilation + '',\n                topLevelAwait: compilation.topLevelAwait\n            } );\n        };`;\n        globalThis.webqit.$fCompilerWorker = new Worker( `data:text/javascript;base64,${ btoa( workerScriptText ) }` );\n    }\n    return new Promise( res => {\n        let messageChannel = new MessageChannel;\n        webqit.$fCompilerWorker.postMessage( { source, params }, [ messageChannel.port2 ] );\n        messageChannel.port1.onmessage = e => {\n            const { compiledSource, ...compilation } = e.data;\n            Object.defineProperty( compilation, 'toString', { value: () => compiledSource } );\n            res( compilation );\n        }\n    } );\n}", "\n/**\n * @imports\n */\nimport { _isObject, _isTypeObject, _isFunction, _getType } from '@webqit/util/js/index.js';\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport { _, _await, other as otherUtil } from './util.js';\nimport ListenerRegistry from './core/ListenerRegistry.js';\nimport TrapsRegistry from './core/TrapsRegistry.js';\nimport Descriptor from './core/Descriptor.js';\nimport { unproxy } from './actors.js';\n\n/* ---------------SPECIAL APIs--------------- */\n\n/**\n * Creates a Path array instance from arguments.\n * \n * @param Array\t            ...segments\n *\n * @return Path\n */\nclass Path extends Array {}\nexport function path( ...segments ) {\n    return new Path( ...segments );\n}\n\n/**\n * Reduces a path array against handler.\n * \n * @param Array|Object\t    target\n * @param Array\t            path\n * @param Function\t        receiver\n * @param Function\t        final\n * @param Object\t        params\n * \n * @example reduce( object, [ segement1, segement2 ], observe, ( value, flags ) => {}, params );\n *\n * @return Any\n */\nexport function reduce( target, path, receiver, final = x => x, params = {} ) {\n    if ( !path.length ) return;\n    return ( function eat( target, path, $params ) {\n        const segment = path[ $params.level ];\n        const isLastSegment = $params.level === path.length - 1;\n        if ( target instanceof Descriptor && target.operation !== 'get' ) {\n            // Always probe event-generated trees\n            $params = { ...$params, probe: 'always' };\n        } else if ( $params.probe !== 'always' ) {\n            // Probe until (before) last segment\n            $params = { ...$params, probe: !isLastSegment };\n        }\n        // ---------------\n        return receiver( target, segment, ( result, ...args ) => {\n            // -----------\n            const addTrail = desc => {\n                if ( !( desc instanceof Descriptor ) ) return;\n                desc.path = [ desc.key ];\n                if ( target instanceof Descriptor ) {\n                    desc.path = target.path.concat( desc.key );\n                    Object.defineProperty( desc, 'context', { get: () => target, configurable: true } );\n                }\n            };\n            const advance = result => {\n                const $value = resolveObj( result/* a Descriptor who's value could be proxied */, false );\n                return _await( $value/* could be a promise */, $value => {\n                    if ( result instanceof Descriptor ) {\n                        result.value = $value; // Update to (fulfilled), unproxied, value\n                    } else {\n                        result = $value;\n                    }\n                    const flags = args[ 0 ] || {};\n                    return eat( result, path, { ...$params, ...flags, level: $params.level + 1, } );\n                } );\n            };\n            // -----------\n            if ( isPropsList( segment ) && Array.isArray( result ) ) {\n                result.forEach( addTrail );\n                if ( isLastSegment ) return final( result, ...args );\n                return result.map( advance );\n            }\n            // -----------\n            addTrail( result );\n            if ( isLastSegment ) return final( result, ...args );\n            return advance( result );\n            // -----------\n        }, $params );\n    } )( target, path.slice( 0 ), { ...params, level: 0 } );\n}\n\n/**\n * Adds an observer to a target's registry.\n *\n * @param Array|Object\t    target\n * @param String|Object\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return AbortController\n */\nexport function observe( target, prop, receiver, params = {} ) {\n    // ---------------\n    target = resolveObj( target, !params.level );\n\tif ( _isFunction( arguments[ 1 ] ) ) {\n        [ , receiver, params = {} ] = arguments;\n        prop = Infinity;\n\t}\n\tif ( !_isFunction( receiver ) ) throw new Error( `Handler must be a function; \"${ _getType( receiver ) }\" given!` );\n    if ( prop instanceof Path ) return reduce( target, prop, observe, receiver, params );\n    // ---------------\n    params = { ...params, descripted: true };\n    delete params.live;\n    if ( !_isTypeObject( target ) ) return params.probe && get( target, prop, receiver, params );\n    // ---------------\n    const emit = bind( target, prop, receiver, params );\n    if ( params.probe ) {\n        return get( target, prop, emit, params );\n    }\n    return emit();\n}\n\n/**\n * Adds an interceptor object to a target's registry.\n *\n * @param Array|Object\t    target\n * @param Object\t        traps\n * @param Object\t\t    params\n *\n * @return AbortRegistry\n */\nexport function intercept( target, traps, params = {} ) {\n    // ---------------\n    target = resolveObj( target );\n    if ( !_isObject( traps ) ) {\n        [ /*target*/, /*operation*/, /*handler*/, params = {} ] = arguments;\n        traps = { [ arguments[ 1 ] ]: arguments[ 2 ] };\n    }\n    // ---------------\n    return TrapsRegistry.getInstance( target, true, params.namespace ).addRegistration( { traps, params } );\n}\n\n/* ---------------QUERY APIs--------------- */\n\n/**\n * Performs a \"getOwnPropertyDescriptor\" operation.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getOwnPropertyDescriptor( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'getOwnPropertyDescriptor', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a \"getOwnPropertyDescriptors\" operation.\n * @note this isn't part of the standard Reflect API.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getOwnPropertyDescriptors( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'getOwnPropertyDescriptors', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a \"getPrototypeOf\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getPrototypeOf( target, receiver = x => x, params = {} ) {\n    return exec( target, 'getPrototypeOf', {}, receiver, params );\n}\n\n/**\n * Performs a \"isExtensible\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function isExtensible( target, receiver = x => x, params = {} ) {\n    return exec( target, 'isExtensible', {}, receiver, params );\n}\n\n/**\n * Performs a \"ownKeys\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function ownKeys( target, receiver = x => x, params = {} ) {\n    return exec( target, 'ownKeys', {}, receiver, params );\n}\n\n/**\n * Performs an operation of the given \"type\".\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function has( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'has', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a get operation.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function get( target, prop, receiver = x => x, params = {} ) {\n    // ---------------\n    let isLive;\n    const originalTarget = resolveObj( target, !params.level );\n    if ( _isObject( receiver ) ) { [ params, receiver ] = [ receiver, x => x ]; }\n    else if ( params.live ) { isLive = true; }\n    if ( prop instanceof Path ) return reduce( originalTarget, prop, get, receiver, params );\n    // ---------------\n    return resolveProps( originalTarget, prop, props => {\n        const related = [ ...props ];\n        return ( function next( results, _props, _done ) {\n            if ( !_props.length ) return _done( results );\n            const prop = _props.shift();\n            if ( ![ 'string', 'number', 'symbol' ].includes( typeof prop ) ) {\n                throw new Error( `Property name/key ${ prop } invalid.` );\n            }\n            // ---------\n            function defaultGet( descriptor, value = undefined ) {\n                const _next = value => ( descriptor.value = value, next( [ ...results, params.live || params.descripted ? descriptor : value ]/** not using concat() as value may be an array */, _props, _done ) );\n                if ( arguments.length > 1 ) return _next( value );\n                if ( !_isTypeObject( originalTarget ) ) return _next( originalTarget?.[ descriptor.key ] );\n                const accessorizedProps = _( originalTarget, 'accessorizedProps', false );\n                const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n                if ( accessorization && accessorization.intact() ) {\n                    return _next( accessorization.getValue( params.withPropertyDescriptors ) );\n                }\n                if ( params.withPropertyDescriptors ) {\n                    const desc = Object.getOwnPropertyDescriptor( originalTarget, descriptor.key );\n                    if ( 'forceValue' in params &&  'value' in desc ) { desc.value = params.forceValue; }\n                    return _next( desc );\n                }\n                if ( 'forceValue' in params ) { return _next( params.forceValue ); }\n                return _next( Reflect.get( originalTarget, descriptor.key, ...( params.receiver ? [ params.receiver ] : [] ) ) );\n            }\n            // ---------\n            const descriptor = new Descriptor( originalTarget, {\n                type: 'get',\n                key: prop,\n                value: undefined,\n                operation: 'get',\n                related,\n            } );\n            if ( !_isTypeObject( originalTarget ) ) return defaultGet( descriptor );\n            const trapsRegistry = TrapsRegistry.getInstance( originalTarget, false, params.namespace );\n            if ( trapsRegistry ) {\n                return trapsRegistry.emit( descriptor, defaultGet );\n            }\n            return defaultGet( descriptor );\n        } )( [], props.slice( 0 ), results => {\n            const result_s = isPropsList( prop/*original*/ ) ? results : results[ 0 ];\n            if ( isLive && _isTypeObject( originalTarget ) ) {\n                const emit = bind( originalTarget, prop, receiver, params );\n                return emit( result_s );\n            }\n            return receiver( result_s );\n        } );\n    }, params );\n}\n\n/* ---------------MUTATION APIs--------------- */\n\n/**\n * Performs a batch operation.\n * \n * @param Object\t        target\n * @param Function\t        callback\n * @param Object\t        params\n *\n * @return Void\n */\nexport function batch( target, callback, params = {} ) {\n    target = resolveObj( target );\n    return ListenerRegistry.getInstance( target, true, params.namespace ).batch( callback );\n}\n\n/**\n * Performs a mirror operation.\n * \n * @param Object\t        source\n * @param Object\t        target\n * @param Object\t        params\n *\n * @return Void\n */\nexport function read( source, target, params = {} ) {\n    target = resolveObj( target );\n    source = resolveObj( source );\n    const only = ( params.only || [] ).slice( 0 ), except = ( params.except || [] ).slice( 0 );\n    const sourceKeys = ownKeys( params.spread ? [ ...source ] : source ).map( k => !isNaN( k ) ? parseInt( k ) : k );\n    const filteredKeys = only.length ? only.filter( k => sourceKeys.includes( k ) ) : sourceKeys.filter( k => !except.includes( k ) );\n    const resolveKey = k => {\n        if ( !Array.isArray( target ) || isNaN( k ) ) return k;\n        return k - except.filter( i => i < k ).length;\n    };\n    const doSet = key => {\n        const descriptor = getOwnPropertyDescriptor( source, key, params );\n        if ( ( 'value' in descriptor ) && descriptor.writable && descriptor.enumerable && descriptor.configurable ) {\n            set( target, resolveKey( key ), descriptor.value, params );\n        } else if ( descriptor.enumerable || params.onlyEnumerable === false ) { defineProperty( target, key, { ...descriptor, configurable: true }, params ); }\n    };\n    batch( target, () => {\n        filteredKeys.forEach( doSet );\n    } );\n    return observe( source, mutations => {\n        //batch( target, () => {\n            mutations.filter( m => only.length ? only.includes( m.key ) : !except.includes( m.key ) ).forEach( m => {\n                if ( m.operation === 'deleteProperty' ) return deleteProperty( target, resolveKey( m.key ), params );\n                if ( m.operation === 'defineProperty' ) {\n                    if ( m.value.enumerable || params.onlyEnumerable === false ) {\n                        defineProperty( target, resolveKey( m.key ), { ...m.value, configurable: true }, params );\n                    }\n                    return;\n                }\n                doSet( m.key );\n            } );\n        //}, params );\n    }, { ...params, withPropertyDescriptors: true } );\n}\n\n/**\n * Performs a set operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Any\t            value\n * @param Function\t        receiver\n * @param Object\t        params\n * @param Bool\t            def\n *\n * @return Any\n */\nexport function set( target, prop, value, receiver = x => x, params = {}, def = false ) {\n    // ---------------\n    const originalTarget = resolveObj( target );\n    let entries = [ [ prop, value ] ];\n    if ( _isObject( prop ) ) {\n        [ /*target*/, /*hash*/, receiver = x => x, params = {}, def = false ] = arguments;\n        entries = Object.entries( prop );\n    }\n    if ( _isObject( receiver ) ) { [ def, params, receiver ] = [ typeof params === 'boolean' ? params : def, receiver, x => x ]; }\n    // ---------------\n    const related = entries.map( ( [ prop ] ) => prop );\n    return ( function next( descriptors, entries, _done ) {\n        if ( !entries.length ) return _done( descriptors );\n        const [ prop, value ] = entries.shift();\n        // ---------\n        function defaultSet( descriptor, status = undefined ) {\n            const _next = status => ( descriptor.status = status, next( descriptors.concat( descriptor ), entries, _done ) );\n            if ( arguments.length > 1 ) return _next( descriptor, status );\n            const accessorizedProps = _( originalTarget, 'accessorizedProps', false );\n            const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n            if ( descriptor.operation === 'defineProperty' ) {\n                if ( accessorization && !accessorization.restore() ) _next( false );\n                Object.defineProperty( originalTarget, descriptor.key, descriptor.value );\n                return _next( true );\n            }\n            if ( accessorization && accessorization.intact() ) {\n                return _next( accessorization.setValue( descriptor.value ) );\n            }\n            return _next( Reflect.set( originalTarget, descriptor.key, descriptor.value ) );\n        }\n        // ---------\n        function exec( isUpdate, oldValue ) {\n            if ( params.diff && value === oldValue ) return next( descriptors, entries, _done );\n            const descriptor = new Descriptor( originalTarget, {\n                type: def ? 'def' : 'set',\n                key: prop,\n                value,\n                isUpdate,\n                oldValue,\n                related: [ ...related ],\n                operation: def ? 'defineProperty' : 'set',\n                detail: params.detail,\n            } );\n            const trapsRegistry = TrapsRegistry.getInstance( originalTarget, false, params.namespace );\n            return trapsRegistry \n                ? trapsRegistry.emit( descriptor, defaultSet ) \n                : defaultSet( descriptor );\n        }\n        // ---------\n        return has( originalTarget, prop, exists => {\n            if ( !exists ) return exec( exists );\n            const $params = { ...params, withPropertyDescriptors: def };\n            if ( 'forceOldValue' in params ) { $params.forceValue = params.forceOldValue; }\n            return get( originalTarget, prop, oldValue => exec( exists, oldValue ), $params );\n        }, params );\n        // ---------\n    } )( [], entries.slice( 0 ), descriptors => {\n        const listenerRegistry = ListenerRegistry.getInstance( originalTarget, false, params.namespace );\n        if ( listenerRegistry ) listenerRegistry.emit( descriptors, def );\n        return receiver(\n            isPropsList( prop/*original*/ ) ? descriptors.map( opr => opr.status ) : descriptors[ 0 ]?.status\n        );\n    } );\n}\n\n/**\n * Performs a defineProperty operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Object\t        descriptor\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function defineProperty( target, prop, descriptor, receiver = x => x, params = {} ) {\n    return set( target, prop, descriptor, receiver, params, true/*def*/ );\n}\n\n/**\n * Performs a defineProperties operation.\n * @note this isn't part of the standard Reflect API.\n * \n * @param Object\t        target\n * @param Object\t        descriptors\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function defineProperties( target, descriptors, receiver = x => x, params = {} ) {\n    return set( target, descriptors, receiver, params, true/*def*/ );\n}\n\n/**\n * Performs a delete operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function deleteProperty( target, prop, receiver = x => x, params = {} ) {\n    // ---------------\n    target = resolveObj( target );\n    if ( _isObject( receiver ) ) { [ params, receiver ] = [ receiver, x => x ]; }\n    // ---------------\n    const props = _arrFrom( prop, false ), related = [ ...props ];\n    return ( function next( descriptors, props, _done ) {\n        if ( !props.length ) return _done( descriptors );\n        const prop = props.shift();\n        // ---------\n        function defaultDel( descriptor, status = undefined ) {\n            const _next = status => ( descriptor.status = status, next( descriptors.concat( descriptor ), props, _done ) );\n            if ( arguments.length > 1 ) return _next( descriptor, status );\n            const accessorizedProps = _( target, 'accessorizedProps', false );\n            const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n            if ( accessorization && !accessorization.restore() ) _next( false );\n            return _next( Reflect.deleteProperty( target, descriptor.key ) );\n        }\n        // ---------\n        function exec( oldValue ) {\n            const descriptor = new Descriptor( target, {\n                type: 'delete',\n                key: prop,\n                oldValue,\n                related: [ ...related ],\n                operation: 'deleteProperty',\n                detail: params.detail,\n            } );\n            const listenerRegistry = TrapsRegistry.getInstance( target, false, params.namespace );\n            return listenerRegistry \n                ? listenerRegistry.emit( descriptor, defaultDel ) \n                : defaultDel( descriptor );\n        }\n        // ---------\n        return get( target, prop, exec, params );\n        // ---------\n    } )( [], props.slice( 0 ), descriptors => {\n        const listenerRegistry = ListenerRegistry.getInstance( target, false, params.namespace );\n        if ( listenerRegistry ) listenerRegistry.emit( descriptors );\n        return receiver(\n            isPropsList( prop/*original*/ ) ? descriptors.map( opr => opr.status ) : descriptors[ 0 ].status\n        );\n    } );\n}\n\n/**\n * @alias deleteProperty()\n */\nexport function deleteProperties( target, props, receiver = x => x, params = {} ) {\n    return deleteProperty( ...arguments );\n}\n\n/* ---------------EFFECT APIs--------------- */\n\n/**\n * Performs a \"construct\" operation.\n *\n * @param Array|Object\t    target\n * @param Array\t\t\t    argumentsList\n * @param Object\t\t    newTarget\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function construct( target, argumentsList, newTarget = null, receiver = x => x, params = {} ) {\n    return exec( target, 'construct', arguments.length > 2 ? { argumentsList, newTarget } : { argumentsList }, receiver, params );\n}\n\n/**\n * Performs an \"apply\" operation.\n *\n * @param Array|Object\t    target\n * @param Any\t            thisArgument\n * @param Array\t            argumentsList\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function apply( target, thisArgument, argumentsList, receiver = x => x, params = {} ) {\n    return exec( target, 'apply', { thisArgument, argumentsList }, receiver, params );\n}\n\n/**\n * Performs a \"setPrototypeOf\" operation.\n *\n * @param Array|Object\t    target\n * @param Anyr\t            proto\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function setPrototypeOf( target, proto, receiver = x => x, params = {} ) {\n    return exec( target, 'setPrototypeOf', { proto }, receiver, params );\n}\n\n/**\n * Performs a \"preventExtension\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function preventExtensions( target, receiver = x => x, params = {} ) {\n    return exec( target, 'preventExtensions', {}, receiver, params );\n}\n\n/* ---------------HELPER APIs--------------- */\n\n/**\n * Adds an observer to a target's registry.\n *\n * @param Array|Object\t    target\n * @param String|Object\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Function: AbortController\n */\nfunction bind( target, prop, receiver, params = {} ) {\n    let controller;\n    if ( !params.signal ) {\n        controller = new AbortController;\n        params = { ...params, signal: controller.signal };\n        otherUtil.setMaxListeners?.( 0, controller.signal );\n    }\n    const listenerRegistry = ListenerRegistry.getInstance( target, true, params.namespace );\n    return function emit( descriptor_s, prevRegistration = null ) {\n        prevRegistration?.remove();\n        const registrationNext = listenerRegistry.addRegistration( prop, emit, params );\n        const flags = { signal: registrationNext.signal, };\n        if ( arguments.length ) {\n            const handlerReturnValue = receiver( descriptor_s, flags );\n            if ( arguments.length > 1 ) return handlerReturnValue;\n        }\n        return controller;\n    };\n}\n\n/**\n * Performs an operation of the given \"type\".\n *\n * @param Array|Object\t    target\n * @param String\t\t    operation\n * @param Object\t\t    payload\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nfunction exec( target, operation, payload = {}, receiver = x => x, params = {} ) {\n    // ---------\n    target = resolveObj( target );\n    if ( _isObject( receiver ) ) { [ params, receiver ] = [ receiver, x => x ]; }    \n    // ---------\n    function defaultExec( descriptor, result ) {\n        if ( arguments.length > 1 ) return receiver( result );\n        return receiver( ( Reflect[ operation ] || Object[ operation ] )( target, ...Object.values( payload ) ) );\n    }\n    // ---------\n    const descriptor = new Descriptor( target, { operation, ...payload } );\n    const listenerRegistry = TrapsRegistry.getInstance( target, false, params.namespace );\n    if ( listenerRegistry ) {\n        return listenerRegistry.emit( descriptor, defaultExec );\n    }\n    return defaultExec( descriptor );\n}\n\n// Asks if prop is a multi-result field\nfunction isPropsList( prop ) {\n    return prop === Infinity || Array.isArray( prop );\n}\n\n// Resolves obj down to it's self\nfunction resolveObj( obj, assert = true ) {\n\tif ( ( !obj || !_isTypeObject( obj ) ) && assert ) throw new Error( `Object must be of type object or array! \"${ _getType( obj ) }\" given.` );\n    if ( obj instanceof Descriptor ) {\n        obj = obj.value;\n    }\n\treturn obj && unproxy( obj );\n}\n\n// Resolves prop down to actual keys\nfunction resolveProps( obj, prop, receiver, params = {} ) {\n    if ( prop === Infinity ) {\n        if ( params.level && !_isTypeObject( obj ) ) return receiver( [] );\n        return ownKeys( obj, receiver, params );\n    }\n    return receiver( _arrFrom( prop, false ) );\n}\n", "\r\n/**\r\n * Tells if val is pure object.\r\n *\r\n * @param object\t \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn !Array.isArray(val) && typeof val === 'object' && val;\r\n};\r\n", "\r\n/**\r\n * Returns the val's type.\r\n *\r\n * @param string \tval\r\n *\r\n * @return string\r\n */\r\nexport default function(val) {\r\n\treturn typeof val;\r\n};\r\n", "\r\n/**\r\n * Tells if val is of type \"array\".\r\n *\r\n * @param object\t \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn Array.isArray(val);\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isArray from '../js/isArray.js';\r\n\r\n/**\r\n * Returns the intersection of two arrays;\r\n * optionally using a custom matching function.\r\n *\r\n * @param array \tarr\r\n * @param array\t \tarr2\r\n * @param function \tcallback\r\n *\r\n * @return array\r\n */\r\nexport default function(arr, arr2, callback = null) {\r\n\treturn !_isArray(arr2) ? [] : arr.filter(val1 => callback \r\n\t\t? arr2.filter(val2 => callback(val1, val2)).length \r\n\t\t: arr2.indexOf(val1) !== -1\r\n\t);\r\n};\r\n", "/**\r\n * @imports\r\n */\r\nimport _intersect from '../arr/intersect.js';\r\n\r\n/**\r\n * Creates and/or returns an \"internals\" object for the given object.\r\n * \r\n * @param Any obj\r\n * @param String namespace\r\n * \r\n * @return Object\r\n */\r\nexport default function internals(obj, ...namespaces) {\r\n    if (!globalThis.webqit) { globalThis.webqit = {}; }\r\n    if (!globalThis.webqit.refs) {\r\n        Object.defineProperty(globalThis.webqit, 'refs', {value: new ObservableMap})\r\n    }\r\n    if (!arguments.length) return globalThis.webqit.refs;\r\n    let itnls = globalThis.webqit.refs.get(obj);\r\n    if (!itnls) {\r\n        itnls = new ObservableMap;\r\n        globalThis.webqit.refs.set(obj, itnls);\r\n    }\r\n    let _ns, _itnls;\r\n    while ((_ns = namespaces.shift())) {\r\n        if ((_itnls = itnls) && !(itnls = itnls.get(_ns))) {\r\n            itnls = new ObservableMap;\r\n            _itnls.set(_ns, itnls);\r\n        }\r\n    }\r\n    return itnls;\r\n}\r\n\r\nclass ObservableMap extends Map {\r\n    constructor( ...args ) {\r\n        super( ...args );\r\n        this.observers = new Set;\r\n    }\r\n    set( key, value ) {\r\n        let returnValue = super.set( key, value );\r\n        this.fire( 'set', key, value, key );\r\n        return returnValue;\r\n    }\r\n    delete( key ) {\r\n        let returnValue = super.delete( key );\r\n        this.fire( 'delete', key );\r\n        return returnValue;\r\n    }\r\n    has( key ) {\r\n        this.fire( 'has', key );\r\n        return super.has( key );\r\n    }\r\n    get( key ) {\r\n        this.fire( 'get', key );\r\n        return super.get( key );\r\n    }\r\n    keyNames() { return Array.from( super.keys() ); }\r\n    observe( type, key, callback ) {\r\n        const entry = { type, key, callback };\r\n        this.observers.add( entry );\r\n        return () => this.observers.delete( entry );\r\n    }\r\n    unobserve( type, key, callback ) {\r\n        if ( Array.isArray( type ) || Array.isArray( key ) ) {\r\n            throw new Error( `The \"type\" and \"key\" arguments can only be strings.` );\r\n        }\r\n        for ( let entry of this.observers ) {\r\n            if ( !( _intersection( [ type, '*' ], entry.type ) && _intersection( [ key, '*' ], entry.key ) && entry.callback === callback ) ) continue;\r\n            this.observers.delete( entry );\r\n        }\r\n    }\r\n    fire( type, key, ...args ) {\r\n        // IMPORTANT: Array.from() must be used so that new additions to this.observers\r\n        // during the loop aren't picked up!\r\n        for ( let entry of this.observers ) {\r\n            if ( !( _intersection( [ type, '*' ], entry.type ) && _intersection( [ key, '*' ], entry.key ) ) ) continue;\r\n            entry.callback( ...args );\r\n        }\r\n    }\r\n}\r\n\r\nconst _intersection = ( a, b ) => {\r\n    if ( Array.isArray( b ) ) return _intersect( a, b ).length;\r\n    return a.includes( b );\r\n}\r\n", "\r\n/**\r\n * Tells if val is of type \"function\".\r\n * This holds true for both regular functions and classes.\r\n *\r\n * @param object\t \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn typeof val === 'function';\r\n};\r\n", "\r\n/**\r\n * Tells if val is undefined or is null.\r\n *\r\n * @param string \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn val === null || val === '';\r\n};\r\n", "\r\n/**\r\n * Tells if val is undefined or is of type \"undefined\".\r\n *\r\n * @param string \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn arguments.length && (val === undefined || typeof val === 'undefined');\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isTypeFunction from './isTypeFunction.js';\r\n\r\n/**\r\n * Tells if val is of type \"object\".\r\n * This holds true for anything object, including built-ins.\r\n *\r\n * @param object\t \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn Array.isArray(val) || (typeof val === 'object' && val) || _isTypeFunction(val);\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isNull from './isNull.js';\r\nimport _isUndefined from './isUndefined.js';\r\nimport _isTypeObject from './isTypeObject.js';\r\n\r\n/**\r\n * Tells if val is empty in its own type.\r\n * This holds true for NULLs, UNDEFINED, FALSE, 0,\r\n * objects without keys, empty arrays.\r\n *\r\n * @param string \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn _isNull(val) || _isUndefined(val) || val === false || val === 0 \r\n\t\t|| (_isTypeObject(val) && !Object.keys(val).length);\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isTypeFunction from './isTypeFunction.js';\r\n\r\n/**\r\n * Tells if val is of type \"function\".\r\n *\r\n * @param object \t\tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn _isTypeFunction(val) || (val && {}.toString.call(val) === '[object function]');\r\n};\r\n", "\r\n/**\r\n * Tells if val is of type \"number\".\r\n *\r\n * @param string \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn val instanceof Number || (typeof val === 'number');\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isNumber from './isNumber.js';\r\n/**\r\n * Tells if val is of type \"string\" or a numeric string.\r\n * This holds true for both numbers and numeric strings.\r\n *\r\n * @param string \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn _isNumber(val) || (val !== true && val !== false && val !== null && val !== '' && !isNaN(val * 1));\r\n};\r\n", "\r\n/**\r\n * Tells if val is of type \"string\".\r\n *\r\n * @param string \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn val instanceof String || (typeof val === 'string' && val !== null);\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isString from './isString.js';\r\nimport _isUndefined from './isUndefined.js';\r\n\r\n/**\r\n * Tells if val is \"array-like\".\r\n * This holds true for anything that has a length property.\r\n *\r\n * @param object\t \tval\r\n *\r\n * @return bool\r\n */\r\nexport default function(val) {\r\n\treturn !_isString(val) && !_isUndefined(val.length);\r\n};\r\n", "\r\n/**\r\n * Adds an item if not already exist.\r\n *\r\n * @param array \tarr\r\n * @param array\t \t...itms\r\n *\r\n * @return array\r\n */\r\nexport default function(arr, ...items) {\r\n\titems.forEach(itm => {\r\n\t\tif (arr.indexOf(itm) < 0) {\r\n\t\t\tarr.push(itm);\r\n\t\t}\r\n\t});\r\n\treturn arr;\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isArray from '../js/isArray.js';\r\n\r\n/**\r\n * Returns the prototype chain.\r\n *\r\n * @param object \t\tobj\r\n * @param object\t \tuntil\r\n *\r\n * @return bool\r\n */\r\nexport default function(obj, until) {\r\n\tuntil = until || Object.prototype;\r\n\tuntil = until && !_isArray(until) ? [until] : until;\r\n\t// We get the chain of inheritance\r\n\tvar prototypalChain = [];\r\n\tvar obj = obj;\r\n\twhile((obj && (!until || until.indexOf(obj) < 0) && obj.name !== 'default')) {\r\n\t\tprototypalChain.push(obj);\r\n\t\tobj = obj ? Object.getPrototypeOf(obj) : null;\r\n\t}\r\n\treturn prototypalChain;\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _pushUnique from '../arr/pushUnique.js';\r\nimport _getPrototypeChain from './getPrototypeChain.js';\r\n\r\n/**\r\n * Eagerly retrieves object members all down the prototype chain.\r\n *\r\n * @param object\t \tobj\r\n * @param object\t \tuntil\r\n *\r\n * @return array\r\n */\r\nexport default function(obj, until) {\r\n\tvar keysAll = [];\r\n\t_getPrototypeChain(obj, until).forEach(obj => {\r\n\t\t_pushUnique(keysAll, ...Object.getOwnPropertyNames(obj));\r\n\t});\r\n\treturn keysAll;\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isArray from '../js/isArray.js';\r\nimport _isFunction from '../js/isFunction.js';\r\nimport _isObject from '../js/isObject.js';\r\nimport _isTypeObject from '../js/isTypeObject.js';\r\nimport _isNumeric from '../js/isNumeric.js';\r\nimport _getAllPropertyNames from './getAllPropertyNames.js';\r\n\r\n/**\r\n  * Merges values from subsequent arrays/objects first array/object;\r\n  * optionally recursive\r\n  *\r\n  * @param array ...objs\r\n  *\r\n  * @return void\r\n  */\r\nexport default function mergeCallback(objs, callback, deepProps = false, isReplace = false, withSymbols = false) {\r\n\tvar depth = 0;\r\n\tvar obj1 = objs.shift();\r\n\tif (_isNumeric(obj1) || obj1 === true || obj1 === false) {\r\n\t\tdepth = obj1;\r\n\t\tobj1 = objs.shift();\r\n\t}\r\n\tif (!objs.length) {\r\n\t\tthrow new Error('_merge() requires two or more array/objects.');\r\n\t}\r\n\tobjs.forEach((obj2, i) => {\r\n\t\tif (!_isTypeObject(obj2) && !_isFunction(obj2)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t(deepProps ? _getAllPropertyNames(obj2) : Object.keys(obj2)).forEach(key => {\r\n\t\t\tif (!callback(key, obj1, obj2, i)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar valAtObj1 = obj1[key];\r\n\t\t\tvar valAtObj2 = obj2[key];\r\n\t\t\tif (((_isArray(valAtObj1) && _isArray(valAtObj2)) || (_isObject(valAtObj1) && _isObject(valAtObj2))) \r\n\t\t\t&& (depth === true || depth > 0)) {\r\n\t\t\t\t// RECURSE...\r\n\t\t\t\tobj1[key] = _isArray(valAtObj1) && _isArray(valAtObj2) ? [] : {};\r\n\t\t\t\tmergeCallback([_isNumeric(depth) ? depth - 1 : depth, obj1[key], valAtObj1, valAtObj2], callback, deepProps, isReplace, withSymbols);\r\n\t\t\t} else {\r\n\t\t\t\tif (_isArray(obj1) && _isArray(obj2)) {\r\n\t\t\t\t\tif (isReplace) {\r\n\t\t\t\t\t\tobj1[key] = valAtObj2;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tobj1.push(valAtObj2);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// In case we're setting a read-only property\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tif (withSymbols) {\r\n\t\t\t\t\t\t\tObject.defineProperty(obj1, key, Object.getOwnPropertyDescriptor(obj2, key));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tobj1[key] = obj2[key];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch(e) {}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n\treturn obj1;\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _mergeCallback from './mergeCallback.js';\r\n\r\n/**\r\n  * Merges values from subsequent arrays/objects first array/object;\r\n  * optionally recursive\r\n  *\r\n  * @param array ...objs\r\n  *\r\n  * @return void\r\n  */\r\nexport default function(...objs) {\r\n\treturn _mergeCallback(objs, (k, obj1, obj2) => {\r\n\t\treturn true;\r\n\t}, false/*deepProps*/, false/*isReplace*/, false/*withSymbols*/);\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isArray from '../js/isArray.js';\r\nimport _isTypeArray from '../js/isTypeArray.js';\r\nimport _isEmpty from '../js/isEmpty.js';\r\nimport _isObject from '../js/isObject.js';\r\n\r\n/**\r\n * Casts an array-like object to an array.\r\n *\r\n * @param mixed \tval\r\n * @param bool\t \tcastObject\r\n *\r\n * @return array\r\n */\r\nexport default function(val, castObject = true) {\r\n\tif (_isArray(val)) {\r\n\t\treturn val;\r\n\t};\r\n\tif (!castObject && _isObject(val)) {\r\n\t\treturn [val];\r\n\t};\r\n\tif (val !== false && val !== 0 && _isEmpty(val)) {\r\n\t\treturn [];\r\n\t};\r\n\tif (_isTypeArray(val)) {\r\n\t\treturn Array.prototype.slice.call(val);\r\n\t};\r\n\tif (_isObject(val)) {\r\n\t\treturn Object.values(val);\r\n\t};\r\n\treturn [val];\r\n};\r\n", "\n/**\n * @imports\n */\nimport { _internals } from '@webqit/util/js/index.js';\n\nexport const _ = ( ...args ) => _internals( 'observer-api', ...args );\n\nexport const _await = ( value, callback ) => value instanceof Promise ? value.then( callback ) : callback( value );\n\nexport const other = {};\n", "\n/**\n * ---------------------------\n * The Registration class\n * ---------------------------\n */\n\nexport default class Registration {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param Registry\t\t\tregistry\n\t * @param object\t\t\tdfn\n\t *\n\t * @return void\n\t */\n\tconstructor( registry, dfn ) {\n\t\tthis.registry = registry;\n\t\tObject.assign( this, { ...dfn, target: registry.target } );\n\t\tif ( this.params.signal ) {\n\t\t\tthis.params.signal.addEventListener( 'abort', () => this.remove() );\n\t\t}\n\t}\n\n\t/**\n\t * Sets a \"disconnected\" flag on the Registration.\n\t *\n\t * @return void\n\t */\n\tremove() {\n\t\tthis.removed = true;\n\t\treturn this.registry.removeRegistration( this );\n\t}\n}", "\n/**\n * @imports\n */\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport Registration from './Registration.js';\nimport { _await, other as otherUtil } from '../util.js';\n\n/**\n * ---------------------------\n * The ListenerRegistration class\n * ---------------------------\n */\n\nexport default class ListenerRegistration extends Registration {\n\t\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\tsuper( ...arguments );\n\t\tthis.emit.currentRegistration = this;\n\t\tObject.defineProperty( this, 'abortController', { value: new AbortController } );\n\t\tObject.defineProperty( this, 'signal', { value: this.abortController.signal } );\n\t\totherUtil.setMaxListeners?.( 0, this.signal );\n\t}\n\n\t/**\n\t * De-registers the instance.\n\t * \n\t * @return Void\n\t */\n\tremove() {\n\t\tthis.abortController.abort();\n\t\tsuper.remove();\n\t}\n\n\t/**\n\t * Calls the observer's handler function\n\t * on matching with the event's fields.\n\t *\n\t * @param Array\t\t\t \t\tevents\n\t *\n\t * @return Any\n\t */\n\tfire( events ) {\n\t\tif ( this.emit.recursionTarget && ![ 'inject', 'force-async', 'force-sync' ].includes( this.params.recursions ) ) return;\n\t\tlet matches = events, filter = this.filter;\n\t\tif ( filter !== Infinity && ( filter = _arrFrom( filter, false ) ) ) {\n\t\t\tmatches = events.filter( event => filter.includes( event.key ) );\n\t\t}\n\t\tif ( this.params.diff ) {\n\t\t\tmatches = matches.filter( event => event.type !== 'set' || event.value !== event.oldValue );\n\t\t}\n\t\tif ( matches.length ) {\n\t\t\tif ( this.emit.recursionTarget && this.params.recursions !== 'force-sync' ) {\n\t\t\t\tthis.emit.recursionTarget.push( ...matches );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.emit.recursionTarget = this.params.recursions === 'inject' ? matches : [];\n\t\t\tconst $ret = this.filter === Infinity || Array.isArray( this.filter )\n\t\t\t\t? this.emit( matches, this )\n\t\t\t\t: this.emit( matches[ 0 ], this );\n\t\t\t// NOTEL: on calling emit(), this registration has expired and a new one active!!!\n\t\t\treturn _await( $ret, ret => {\n\t\t\t\tconst recursions = this.emit.recursionTarget;\n\t\t\t\tdelete this.emit.recursionTarget;\n\t\t\t\tif ( this.params.recursions === 'force-async' ) {\n\t\t\t\t\tif ( recursions.length ) return this.emit.currentRegistration.fire( recursions );\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} );\n\t\t}\n\t}\n}\n", "\n/**\n * @imports\n */\nimport { _isTypeObject, _getType } from '@webqit/util/js/index.js';\nimport { _from as _arrFrom, _intersect, _equals as _arrEquals } from '@webqit/util/arr/index.js';\nimport { _ } from '../util.js';\n\n/**\n * ---------------------------\n * The Registry class\n * ---------------------------\n */\n\nexport default class Registry {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param object\ttarget\n\t * \n\t * @return void\n\t */\n\tconstructor( target ) {\n\t\tthis.target = target;\n\t\tthis.entries = [];\n\t}\n\t\n\t/**\n\t * Adds an Registration instance\n\t * with optional tags.\n\t *\n\t * @param Registration\t\tregistration\n\t *\n\t * @return Registration\n\t */\n\taddRegistration( registration ) {\n\t\tthis.entries.push( registration );\n\t\treturn registration;\n\t}\n\t\n\t/**\n\t * Removes registrations by reference.\n\t *\n\t * @param Registration\t\tregistration\n\t *\n\t * @return void\n\t */\n\tremoveRegistration( registration ) {\n\t\tthis.entries = this.entries.filter( _entry => _entry !== registration );\n\t}\n\t\t\n\t/**\n\t * Returns a observer-specific object embedded on an element.\n\t *\n\t * @param string\t\ttype\n\t * @param array|object\ttarget\n\t * @param bool      \tcreateIfNotExists\n\t * @param string      \tnamespace\n\t *\n\t * @return Registry\n\t */\n\tstatic _getInstance( type, target, createIfNotExists = true, namespace = this.__namespace ) {\n\t\tif ( !_isTypeObject( target ) ) throw new Error( `Subject must be of type object; \"${ _getType( target ) }\" given!` );\n\t\tlet ImplementationClass = this;\n\t\tif ( namespace && _( 'namespaces' ).has( type + '-' + namespace ) ) {\n\t\t\tImplementationClass = _( 'namespaces' ).get( type + '-' + namespace );\n\t\t\ttype += '-' + namespace\n\t\t}\n\t\tif ( !_( target, 'registry' ).has( type ) && createIfNotExists ) {\n\t\t\t_( target, 'registry' ).set( type, new ImplementationClass( target ) );\n\t\t}\n\t\treturn _( target, 'registry' ).get( type );\n\t}\n\n\t/**\n\t * Extend a Fireable Class with a namespace.\n\t *\n\t * @param string\t\tnamespace\n\t * @param class      \tImplementationClass\n\t *\n\t * @return void|class\n\t */\n\tstatic _namespace( type, namespace, ImplementationClass = null ) {\n\t\ttype += '-' + namespace;\n\t\tif ( arguments.length === 2 ) return _( 'namespaces' ).get( type );\n\t\tif ( !( ImplementationClass.prototype instanceof this ) ) {\n\t\t\tthrow new Error( `The implementation of the namespace ${ this.name }.${ namespace } must be a subclass of ${ this.name }.` );\n\t\t}\n\t\t_( 'namespaces' ).set( type, ImplementationClass );\n\t\tImplementationClass.__namespace = namespace;\n\t}\n}", "\n/**\n * ---------------------------\n * The Descriptor class\n * ---------------------------\n */\n\nexport default class Descriptor {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param array|object\ttarget\n\t * @param object\t\tdfn\n\t *\n\t * @return void\n\t */\n\tconstructor( target, dfn ) {\n\t\tthis.target = target;\n\t\tif ( !( dfn.operation ) ) throw new Error( 'Descriptor operation must be given in definition!' );\n\t\tObject.assign( this, dfn );\n\t}\n}", "\n/**\n * @imports\n */\nimport ListenerRegistration from './ListenerRegistration.js';\nimport Registry from './Registry.js';\nimport { _await } from '../util.js';\nimport Descriptor from './Descriptor.js';\n\n/**\n * ---------------------------\n * The ListenerRegistry class\n * ---------------------------\n */\n\nexport default class ListenerRegistry extends Registry {\n\n\tstatic getInstance( target, createIfNotExists = true, namespace = null ) {\n\t\treturn super._getInstance( 'listeners', ...arguments );\n\t}\n\n\tstatic namespace( namespace, ImplementationClass = null ) {\n\t\treturn super._namespace( 'listeners', ...arguments );\n\t}\n\n\t/**\n\t * @constructor\n\t */\n\tconstructor( target ) {\n\t\tsuper( target );\n\t\tthis.batches = [];\n\t}\n\t\n\t/**\n\t * @addRegistration\n\t */\n\taddRegistration( filter, emit, params ) {\n\t\treturn super.addRegistration( new ListenerRegistration( this, { filter, emit, params } ) );\n\t}\n\t\n\t/**\n\t * Fires all observers with the given evt (change).\n\t *\n\t * @param Arrayn events\n\t *\n\t * @return Void\n\t */\n\temit( events, isPropertyDescriptors = false ) {\n\t\tif ( this.batches.length ) {\n\t\t\tthis.batches[ 0 ].snapshots.push( { events: [ ...events ], isPropertyDescriptors } );\n\t\t\treturn\n\t\t}\n\t\tthis.$emit( this.entries, [ { events, isPropertyDescriptors } ] );\n\t}\n\n\t$emit( entries, snapshots ) {\n\t\tconst needsEventsWithDescriptors = entries.filter( listener => listener.params.withPropertyDescriptors ).length;\n\t\tconst hasEventsToTransform = snapshots.some( snapshot => snapshot.isPropertyDescriptors );\n\t\tconst eventsAsIs = [], eventsTransformed = [], entriesLength = entries.length;\n\t\tsnapshots.forEach( snapshot => {\n\t\t\t// Some need it untransformed (as-is)\n\t\t\tif ( needsEventsWithDescriptors || !hasEventsToTransform ) { eventsAsIs.push( ...snapshot.events ); }\n\t\t\t// It might not be all that need it untransformed, and there might be events to transform\n\t\t\tif ( needsEventsWithDescriptors !== entriesLength && hasEventsToTransform ) {\n\t\t\t\tif ( snapshot.isPropertyDescriptors ) {\n\t\t\t\t\teventsTransformed.push( ...snapshot.events.map( e => {\n\t\t\t\t\t\tlet { target, type, ...details } = e;\n\t\t\t\t\t\tconst desc = new Descriptor( target, { type: 'set', ...details } );\n\t\t\t\t\t\tObject.defineProperty( desc, 'value', 'get' in details.value ? { get: () => details.value.get() } : { value: details.value.value } )\n\t\t\t\t\t\tif ( details.oldValue ) {\n\t\t\t\t\t\t\tObject.defineProperty( desc, 'oldValue', 'get' in details.oldValue ? { get: () => details.oldValue.get() } : { value: details.oldValue.value } )\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn desc;\n\t\t\t\t\t} ) );\n\t\t\t\t} else { eventsTransformed.push( ...snapshot.events ); }\n\t\t\t}\n\t\t} );\n\t\tentries.forEach( listener => {\n\t\t\tif ( listener.params.withPropertyDescriptors ) {\n\t\t\t\tlistener.fire( eventsAsIs.length ? eventsAsIs : eventsTransformed );\n\t\t\t} else { listener.fire( eventsTransformed.length ? eventsTransformed : eventsAsIs ); }\n\t\t} );\n\t}\n\n\t/**\n\t * Fires all observers with the given evt (change).\n\t *\n\t * @param Arrayn events\n\t *\n\t * @return Void\n\t */\n\tbatch( callback ) {\n\t\tthis.batches.unshift( { entries: [ ...this.entries ], snapshots: [] } );\n\t\tconst returnValue = callback();\n\t\treturn _await( returnValue, returnValue => {\n\t\t\tconst batch = this.batches.shift();\n\t\t\tif ( !batch.snapshots.length ) return returnValue;\n\t\t\tthis.$emit( batch.entries, batch.snapshots );\n\t\t\treturn returnValue;\n\t\t} )\n\t}\n\n}", "\n/**\n * @imports\n */\nimport Registration from './Registration.js';\n\n/**\n * ---------------------------\n * The TrapsRegistration class\n * ---------------------------\n */\n\nexport default class TrapsRegistration extends Registration {\n\t\n\t/**\n\t * Calls the observer's handler function\n\t * on matching with the descriptor's fields.\n\t *\n\t * @param Descriptor\t\t\t \tdescriptor\n\t * @param function\t\t\t\t\tnext\n\t * @param mixed\t\t\t\t\t \trecieved\n\t *\n\t * @return void\n\t */\n\texec( descriptor, next, recieved ) {\n\t\tif ( this.running || !this.traps[ descriptor.operation ] ) {\n\t\t\treturn next( ...Array.prototype.slice.call( arguments, 2 ) );\n\t\t}\n\t\tthis.running = true;\n\t\treturn this.traps[ descriptor.operation ]( descriptor, recieved, ( ...args ) => {\n\t\t\tthis.running = false;\n\t\t\treturn next( ...args );\n\t\t} );\n\t}\n}", "\n/**\n * @imports\n */\nimport TrapsRegistration from './TrapsRegistration.js';\nimport Registry from './Registry.js';\n\n/**\n * ---------------------------\n * The TrapsRegistry class\n * ---------------------------\n */\n\nexport default class TrapsRegistry extends Registry {\n\n\tstatic getInstance( target, createIfNotExists = true, namespace = null ) {\n\t\treturn super._getInstance( 'traps', ...arguments );\n\t}\n\n\tstatic namespace( namespace, ImplementationClass = null ) {\n\t\treturn super._namespace( 'traps', ...arguments );\n\t}\n\t\n\t/**\n\t * @inheritdoc\n\t */\n\taddRegistration( dfn ) {\n\t\treturn super.addRegistration( new TrapsRegistration( this, dfn ) );\n\t}\n\n\t/**\n\t * Fires all interceptors with the given action.\n\t *\n\t * @param Descriptor\t\tdescriptor\n\t * @param function\t\t\tdefaultHandler\n\t *\n\t * @return mixed\n\t */\n\temit( descriptor, defaultHandler = null ) {\n\t\tconst $this = this;\n\t\treturn ( function next( index, ..._args ) {\n\t\t\tconst registration = $this.entries[ index ];\n\t\t\tif ( registration ) {\n\t\t\t\treturn registration.exec( descriptor, ( ...args ) => {\n\t\t\t\t\treturn next( index + 1, ...args );\n\t\t\t\t}/*next*/, ..._args );\n\t\t\t}\n\t\t\treturn defaultHandler ? defaultHandler( descriptor, ..._args ) : _args[ 0 ];\n\t\t} )( 0 );\n\t}\n}", "\n/**\n * @imports\n */\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport { _isClass, _isFunction, _isTypeObject, _getType } from '@webqit/util/js/index.js';\nimport { set, deleteProperty, has, get, ownKeys, defineProperty, getOwnPropertyDescriptor } from \"./main.js\";\nimport { batch, apply, construct, getPrototypeOf, setPrototypeOf, isExtensible, preventExtensions } from \"./main.js\";\nimport { _ } from './util.js';\n\n/* ---------------ACCESSORIZE METHODS--------------- */\n\n/**\n * Accessorizes props.\n *\n * @param Array|Object\ttarget\n * @param String|Array\tprops\n * @param Object\t\tparams\n *\n * @return Array\n */\nexport function accessorize( target, props, params = {} ) {\n    target = resolveTarget( target );\n    const accessorizedProps = _( target, 'accessorizedProps' );\n    // ---------\n    function getDescriptorDeep( prop ) {\n        let descriptor, proto = target;\n        do {\n            descriptor = Object.getOwnPropertyDescriptor( proto, prop );\n        } while ( !descriptor && ( proto = Object.getPrototypeOf( proto ) ) );\n        return descriptor \n            ? { proto, descriptor } \n            : { descriptor: { value: undefined, configurable: true, enumerable: true, writable: true } };\n    }\n    // ---------\n    function accessorizeProp( prop ) {\n        if ( accessorizedProps.has( prop + '' ) ) return true;\n        // ------------------\n        // Current Descriptor Record\n        const currentDescriptorRecord = getDescriptorDeep( prop );\n        currentDescriptorRecord.getValue = function( withPropertyDescriptors = false ) {\n            if ( withPropertyDescriptors ) return this.descriptor;\n            return this.descriptor.get ? this.descriptor.get() : this.descriptor.value;\n        };\n        currentDescriptorRecord.setValue = function( value, withPropertyDescriptors = false ) {\n            this.dirty = true;\n            if ( withPropertyDescriptors ) { this.descriptor = value; return; }\n            return this.descriptor.set ? this.descriptor.set( value ) !== false : ( this.descriptor.value = value, true );\n        };\n        currentDescriptorRecord.intact = function() {\n            const currentDescriptor = Object.getOwnPropertyDescriptor( target, prop );\n            return currentDescriptor?.get === accessorization.get \n                && currentDescriptor?.set === accessorization.set\n                && accessorizedProps.get( prop + '' ) === this;\n        };\n        currentDescriptorRecord.restore = function() {\n            if ( !this.intact() ) return false;\n            if ( ( this.proto && this.proto !== target ) || ( !this.proto && !this.dirty ) ) { delete target[ prop ]; }\n            else { Object.defineProperty( target, prop, this.descriptor ); }\n            accessorizedProps.delete( prop + '' );\n            return true;\n        };\n        accessorizedProps.set( !isNaN( prop ) ? parseInt( prop ) : prop, currentDescriptorRecord );\n        // ------------------\n        // enumerable, configurable\n        const { enumerable = true } = currentDescriptorRecord.descriptor;\n        const accessorization = { enumerable, configurable: true };\n        // set, get\n        if ( ( 'value' in currentDescriptorRecord.descriptor ) || currentDescriptorRecord.descriptor.set ) {\n            accessorization.set = function ( value ) { return set( this, prop, value, params ); };\n        }\n        if ( ( 'value' in currentDescriptorRecord.descriptor ) || currentDescriptorRecord.descriptor.get ) {\n            accessorization.get = function () { return get( this, prop, params ); };\n        }\n        try {\n            Object.defineProperty( target, prop, accessorization );\n            return true;\n        } catch( e ) {\n            accessorizedProps.delete( prop + '' );\n            return false;\n        }\n    }\n    const _props = Array.isArray( props ) ? props : (\n        props === undefined ? Object.keys( target ) : [ props ]\n    );\n    const statuses = _props.map( accessorizeProp );\n    return props === undefined || Array.isArray( props ) \n        ? statuses \n        : statuses[ 0 ];\n}\n\n/**\n * Unaccessorizes previously accessorized props.\n *\n * @param Array|Object\ttarget\n * @param String|Array\tprops\n * @param Object\t\tparams\n *\n * @return Array\n */\nexport function unaccessorize( target, props, params = {} ) {\n    target = resolveTarget( target );\n    const accessorizedProps = _( target, 'accessorizedProps' );\n    function unaccessorizeProp( prop ) {\n        if ( !accessorizedProps.has( prop + '' ) ) return true;\n        return accessorizedProps.get( prop + '' ).restore();\n    }\n    const _props = Array.isArray( props ) ? props : (\n        props === undefined ? Object.keys( target ) : [ props ]\n    );\n    const statuses = _props.map( unaccessorizeProp );\n    return props === undefined || Array.isArray( props ) \n        ? statuses \n        : statuses[ 0 ];\n}\n\n/* ---------------PROXY METHODS--------------- */\n\n/**\n * Returns an object as a proxy and binds all instance methods\n * to the proxy instead of the object itself.\n *\n * @param Array|Object\t\ttarget\n * @param Object\t\t    params\n * @param Function\t\t    extendCallback\n *\n * @return Proxy\n */\nexport function proxy( target, params = {}, extendCallback = undefined ) {\n    // Resolve target\n    const originalTarget = resolveTarget( target );\n    // Return same proxy instance?\n    if ( typeof params.membrane === 'boolean' ) throw new Error( `The params.membrane parameter cannot be of type boolean.` );\n    if ( params.membrane && _( originalTarget, 'membraneRef' ).has( params.membrane ) ) { return _( originalTarget, 'membraneRef' ).get( params.membrane ); }\n    const traps = {\n        apply( target, thisArgument, argumentsList ) {\n            if ( Array.isArray( thisArgument ) ) {\n                // Manually manage the length property\n                const originalThis = resolveTarget( thisArgument );\n                _( originalThis ).set( '$length', originalThis.length );\n                // And array methods have their operations batched\n                return batch( originalThis, () =>  apply( target, thisArgument, argumentsList ) );\n            }\n            return apply( target, unproxy( thisArgument ), argumentsList );\n        },\n        construct:  ( target, argumentsList, newTarget = null ) => construct( target, argumentsList, newTarget, params ),\n        defineProperty:  ( target, propertyKey, attributes ) => defineProperty( target, propertyKey, attributes, params ),\n        deleteProperty: ( target, propertyKey ) => deleteProperty( target, propertyKey, params ),\n        get: ( target, propertyKey, receiver = null ) => {\n            const $params = { ...params, receiver };\n            if ( Array.isArray( target ) && propertyKey === 'length' && _( target ).has( '$length' ) ) {\n                $params.forceValue = _( target ).get( '$length' );\n            }\n            const returnValue = get( target, propertyKey, $params );\n            if ( Array.isArray( target ) && typeof returnValue === 'function' ) {\n                // Return a proxy, but in terms of a membrane. \n                return proxy( returnValue, { ...params, membrane: receiver/* the instance obj that will be the thisArgument at apply(). Much like function.bind() */ } );\n            }\n            return returnValue;\n        },\n        getOwnPropertyDescriptor: ( target, propertyKey ) => getOwnPropertyDescriptor( target, propertyKey, params ),\n        getPrototypeOf: target => getPrototypeOf( target, params ),\n        has: ( target, propertyKey ) => has( target, propertyKey, params ),\n        isExtensible: target => isExtensible( target, params ),\n        ownKeys: target => ownKeys( target, params ),\n        preventExtensions: target => preventExtensions( target, params ),\n        set: ( target, propertyKey, value, receiver = null ) => {\n            const $params = { ...params, receiver };\n            if ( Array.isArray( target ) && propertyKey === 'length' ) {\n                $params.forceOldValue = _( target ).get( '$length' );\n                _( target ).set( '$length', value );\n            }\n            return set( target, propertyKey, value, $params );\n        },\n        setPrototypeOf: ( target, prototype ) => setPrototypeOf( target, prototype, params ),\n    };\n    // Extend...\n    const $traps = extendCallback?.( traps ) || traps;\n    // Create proxy\n    const $proxy = new Proxy( originalTarget, $traps );\n    if ( params.membrane ) { _( originalTarget, 'membraneRef' ).set( params.membrane, $proxy ); }\n    _( $proxy ).set( $proxy, originalTarget );\n\treturn $proxy;\n}\n\n/**\n * Returns the original object earlier proxied by proxy().\n *\n * @param Proxy|Any\t\ttarget\n *\n * @return Any\n */\nexport function unproxy( target ) {\n    // Proxy targets are mapped to their own instances internally\n    return _( target ).get( target ) || target;\n}\n\n/* ---------------HELPERS--------------- */\n\n/** \n * Ensures target object is an object or array.\n *\n * @param Array|Object\ttarget\n *\n * @return Array|Object\n */\nfunction resolveTarget( target ) {\n\tif ( !target || !_isTypeObject( target ) ) throw new Error('Target must be of type object!');\n\treturn unproxy( target );\n}\n", "\n/**\n * @imports\n */\nimport * as main from './main.js';\nimport * as actors from './actors.js';\n\nconst Observer = { ...main, ...actors };\n\nexport default Observer;", "\nexport default class Hash {\n\n    // Unique ID generator\n    static hashTable = new Map;\n    static uniqId = () => (0|Math.random()*9e6).toString(36);\n\n    // Hash of anything generator\n    static toHash( val ) {\n        let hash;\n        if ( !( hash = this.hashTable.get( val ) ) ) {\n            hash = this.uniqId();\n            this.hashTable.set( val, hash );\n        }\n        return hash;\n    }\n\n    // Value of any hash\n    static fromHash( hash ) {\n        let val;\n        this.hashTable.forEach( ( _hash, _val ) => {\n            if ( _hash === hash ) val = _val;\n        } );\n        return val;\n    }\n}", "\r\n/**\r\n * @imports\r\n */\r\nimport _isTypeObject from '../js/isTypeObject.js';\r\nimport _isUndefined from '../js/isUndefined.js';\r\nimport _isNull from '../js/isNull.js';\r\nimport _arrFrom from '../arr/from.js';\r\n\r\n/**\r\n * Retrieves the value at the given path.\r\n *\r\n * A return value of undefined is ambiguous, and can mean either that the\r\n * path does not exist, or that the path actually exists but with a value of undefined. If it is required to\r\n * know whether the path actually exists, pass an object as a third argument.\r\n * This object will have an \"exists\" key set to true/false.\r\n *\r\n * @param object \t\t\t\tctxt\r\n * @param array \t\t\t\tpath\r\n * @param object \t\t\t\ttrap\r\n * @param object \t\t\t\treciever\r\n *\r\n * @return mixed\r\n */\r\nexport default function(ctxt, path, trap = {}, reciever = {}) {\r\n\tpath = _arrFrom(path).slice();\r\n\tvar _ctxt = ctxt;\r\n\twhile(!_isUndefined(_ctxt) && !_isNull(_ctxt) && path.length) {\r\n\t\tvar _key = path.shift();\r\n\t\tif (!(trap.get ? trap.get(_ctxt, _key) : (_isTypeObject(_ctxt) ? _key in _ctxt : _ctxt[_key]))) {\r\n\t\t\treciever.exists = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t_ctxt = trap.get ? trap.get(_ctxt, _key) : _ctxt[_key];\r\n\t}\r\n\treciever.exists = true;\r\n\treturn _ctxt;\r\n};\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport _isTypeObject from '../js/isTypeObject.js';\r\nimport _isFunction from '../js/isFunction.js';\r\nimport _isNumeric from '../js/isNumeric.js';\r\nimport _isArray from '../js/isArray.js';\r\nimport _arrFrom from '../arr/from.js';\r\nimport _get from './get.js';\r\n\r\n/**\r\n * Sets a value to the given path.\r\n *\r\n * @param object \t\t\t\tobj\r\n * @param array \t\t\t\tpath\r\n * @param mixed \t\t\t\tval\r\n * @param object|function \t\tbuildTree\r\n * @param object \t\t\t\ttrap\r\n *\r\n * @return bool\r\n */\r\nexport default function(obj, path, val, buildTree = {}, trap = {}) {\r\n\tconst _set = (target, key, val) => {\r\n\t\tif (trap.set) {\r\n\t\t\treturn trap.set(target, key, val);\r\n\t\t} else {\r\n\t\t\tif (_isNumeric(path[i]) && _isArray(target)) {\r\n\t\t\t\ttarget.push(val);\r\n\t\t\t} else {\r\n\t\t\t\ttarget[key] = val;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\tpath = _arrFrom(path);\r\n\tvar target = obj;\r\n\tfor(var i = 0; i < path.length; i ++) {\r\n\t\tif (i < path.length - 1) {\r\n\t\t\tif (!target || (!_isTypeObject(target) && !_isFunction(target))) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tvar branch = _get(target, path[i], trap);\r\n\t\t\tif (!_isTypeObject(branch)) {\r\n\t\t\t\tif (trap.buildTree === false) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tbranch = _isFunction(trap.buildTree) ? trap.buildTree(i) : (_isNumeric(path[i + 1]) ? [] : {});\r\n\t\t\t\tvar branchSuccess = _set(target, path[i], branch);\r\n\t\t\t\tif (!branchSuccess) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttarget = branch;\r\n\t\t} else {\r\n\t\t\treturn _set(target, path[i], val);\r\n\t\t}\r\n\t}\r\n};\r\n", "\n/**\n * ---------------------------\n * Binds callbacks to requestAnimationFrame()\n * to create a central \"read/write\" phases for Ctxt access.\n * ---------------------------\n */\n\t\t\t\nexport default class Scheduler {\n\n\t/**\n\t * Starts the loop.\n\t *\n\t * @return this\n\t */\n\tconstructor( window, asyncDOM = true ) {\n\t\tObject.defineProperty( this, 'window', { value: window } );\n\t\tObject.defineProperty( this, 'readCallbacks', { value: new Set } );\n\t\tObject.defineProperty( this, 'writeCallbacks', { value: new Set } );\n\t\tthis.async = asyncDOM;\n\t\tif ( this.window.requestAnimationFrame ) {\n\t\t\tthis._run();\n\t\t} else {\n\t\t\tthis.async = false;\n\t\t}\n\t}\n\n\t_run() {\n\t\tthis.window.requestAnimationFrame( () => {\n\t\t\tfor ( const callback of this.readCallbacks ) {\n\t\t\t\tcallback();\n\t\t\t\tthis.readCallbacks.delete( callback );\n\t\t\t}\n\t\t\tfor ( const callback of this.writeCallbacks ) {\n\t\t\t\tcallback();\n\t\t\t\tthis.writeCallbacks.delete( callback );\n\t\t\t}\n\t\t\tthis._run();\n\t\t} );\n\t}\n\t\n\t/**\n\t * Binds a callback to the \"read\" phase.\n\t *\n\t * @param function \tcallback\n\t * @param bool\t\twithPromise\n\t *\n\t * @return void\n\t */\n\tonread( callback, withPromise = false ) {\n\t\tif ( withPromise ) {\n\t\t\treturn new Promise( resolve => {\n\t\t\t\tif ( this.async === false ) {\n\t\t\t\t\tresolve( callback() );\n\t\t\t\t} else {\n\t\t\t\t\tthis.readCallbacks.add( () => {\n\t\t\t\t\t\tresolve( callback() );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\tif ( this.async === false ) {\n\t\t\tcallback();\n\t\t} else {\n\t\t\tthis.readCallbacks.add( callback );\n\t\t}\n\t}\n\t\n\t/**\n\t * Binds a callback to the \"write\" phase.\n\t *\n\t * @param function \tcallback\n\t * @param bool\t\twithPromise\n\t *\n\t * @return void\n\t */\n\tonwrite( callback, withPromise = false ) {\n\t\tif ( withPromise ) {\n\t\t\treturn new Promise( resolve => {\n\t\t\t\tif ( this.async === false ) {\n\t\t\t\t\tresolve( callback() );\n\t\t\t\t} else {\n\t\t\t\t\tthis.writeCallbacks.add( () => {\n\t\t\t\t\t\tresolve( callback() );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\tif ( this.async === false ) {\n\t\t\tcallback();\n\t\t} else {\n\t\t\tthis.writeCallbacks.add( callback );\n\t\t}\n\t}\n\t\n\t/**\n\t * A special construct for Ctxt manipulations that span\n\t * one or more read/write cycles.\n\t *\n\t * @param function \tread\n\t * @param function \twrite\n\t * @param mixed\t\tprevTransaction\n\t *\n\t * @return void|mixed\n\t */\n\tcycle( onread, onwrite, prevTransaction ) {\n\t\tthis.onread( () => {\n\t\t\t// Record initial values\n\t\t\tconst readReturn = onread( prevTransaction );\n\t\t\t// Call erite, the transation\n\t\t\tconst callWrite = ( readReturn ) => {\n\t\t\t\tif ( readReturn === undefined ) return;\n\t\t\t\tthis.onwrite( () => {\n\t\t\t\t\tconst writeReturn = onwrite( readReturn, prevTransaction );\n\t\t\t\t\t// Repeat transaction\n\t\t\t\t\tconst repeatTransaction = ( writeReturn ) => {\n\t\t\t\t\t\tif ( writeReturn === undefined ) return;\n\t\t\t\t\t\tthis.cycle( onread, onwrite, writeReturn );\n\t\t\t\t\t};\n\t\t\t\t\t// ---------------------------------------\n\t\t\t\t\t// If \"write\" returns a promise, we wait until it is resolved\n\t\t\t\t\t// ---------------------------------------\n\t\t\t\t\tif ( writeReturn instanceof Promise ) {\n\t\t\t\t\t\twriteReturn.then( repeatTransaction );\n\t\t\t\t\t} else {\n\t\t\t\t\t\trepeatTransaction( writeReturn );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t};\n\t\t\t// ---------------------------------------\n\t\t\t// If \"read\" returns a promise, we wait until it is resolved\n\t\t\t// ---------------------------------------\n\t\t\tif ( readReturn instanceof Promise ) {\n\t\t\t\treadReturn.then( callWrite );\n\t\t\t} else {\n\t\t\t\tcallWrite( readReturn );\n\t\t\t}\n\t\t} );\n\t}\n\n}", "\n\nexport function isXpath( expr ) { return ( expr = expr.trim() ) && expr.startsWith( '(' ) && expr.endsWith( ')' ) }\n\nexport function query( window, context, expr, subtree = true ) {\n    expr = ( Array.isArray( expr ) ? expr : [ expr ] ).map( x => ( x + '' ).replace( '(', subtree ? '(.//' : '(./' ) ).join( '|' );\n    const result = window.document.evaluate( expr, context, null, XPathResult.ANY_TYPE );\n    let nodes = [], node;\n    while ( node = result.iterateNext() ) nodes.push( node );\n    return nodes;\n}\n\nexport function match( window, node, expr ) {\n    expr = ( Array.isArray( expr ) ? expr : [ expr ] ).map( x => ( x + '' ).replace( '(', '(self::' ) ).join( '|' );\n    return window.document.evaluate( `${ expr }`, node, null, XPathResult.BOOLEAN_TYPE ).booleanValue;\n}\n\nexport function split( s, delim = '|' ) {\n    return [ ...s ].reduce( ( [ state, splits ], x ) => {\n        if ( x === delim && state === 0 ) return [ state, [ '' ].concat( splits ) ];\n        if ( [ '(', '[' ].includes( x ) && !splits[ 0 ].endsWith( '\\\\' ) ) state++;\n        if ( [ ')', ']' ].includes( x ) && !splits[ 0 ].endsWith( '\\\\' ) ) state--;\n        splits[ 0 ] += x;\n        return [ state, splits ]\n    }, [ 0, [ '' ] ] )[ 1 ].reverse();\n}\n", "\n/**\n * @imports\n */\nimport * as Xpath from './Xpath.js';\n\nexport default class DOMSpec {\n    constructor( content ) {\n        this.content = content;\n        this.type = typeof content === 'string' ? 'selector' : 'instance';\n        this.kind = this.type === 'instance' ? null : Xpath.isXpath( content ) ? 'xpath' : 'css';\n        if ( this.kind === 'xpath' ) {\n            this.isXpathAttr = Xpath.split( content.trim().slice( 1, -1 ), '@' ).length > 1;\n        }\n    }\n    toString() { return this.content; }\n}", "\n/**\n * @imports\n */\nimport { _isFunction, _isObject, _internals } from '@webqit/util/js/index.js';\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport DOMSpec from './DOMSpec.js';\n\n/**\n *\n * @class Realtime\n */\nexport default class Realtime {\n\n\t/**\n\t * @constructor\n\t *\n\t * @param document|Element\tcontext\n\t */\n\tconstructor( context, namespace, window ) {\n\t\tthis.context = context;\n\t\tthis.namespace = namespace;\n\t\tthis.window = context.defaultView || context.ownerDocument?.defaultView || window;\n\t\tthis.document = this.window.document;\n\t\tthis.webqit = this.window.webqit;\n\t\tObject.defineProperty( this, '#', { value: {} } );\n\t}\n\t\n\t/**\n\t * Resolves arguments\n\t * \n\t * @param Array \t\t\targs \n\t * \n\t * @returns Array\n\t */\n\tresolveArgs( args ) {\n\t\tif ( _isFunction( args[ 0 ] ) ) { args = [ [], ...args ]; }\n\t\telse if ( _isObject( args[ 0 ] ) && !( args[ 0 ] instanceof DOMSpec ) && args.length === 1 ) {\n\t\t\targs = [ [], undefined, args[ 0 ] ];\n\t\t} else if ( _isObject( args[ 1 ] ) && args.length === 2 ) {\n\t\t\targs = [ _arrFrom( args[ 0 ], false/*castObject*/ ), undefined, args[ 1 ] ];\n\t\t} else { args[ 0 ] = _arrFrom( args[ 0 ], false/*castObject*/ ); }\n\t\tif ( args[ 0 ].filter( x => typeof x !== 'string' && !( x instanceof DOMSpec ) && !( x instanceof this.window.Node ) ).length ) {\n\t\t\tthrow new Error( `Argument #2 must be either a string or a Node object, or a list of those.` );\n\t\t}\n\t\targs[ 0 ] = args[ 0 ].map( s => s instanceof DOMSpec ? s : new DOMSpec( s ) );\n\t\treturn args;\n\t}\n\n\t/**\n\t * @registry\n\t *\n\t * @param Array\t\t\t\t...args\n\t * \n\t * @returns Map\n\t */\n\tregistry( ...args ) {\n\t\treturn _internals( 'realdom.realtime', this.window, this.namespace, ...args );\n\t}\n\t\t\n\t/**\n\t * @createSignalGenerator\n\t * \n\t * @param Object \t\t\tmo \n\t * \n\t * @returns Object\n\t */\n\tcreateSignalGenerator() {\n\t\treturn {\n\t\t\tgenerate() {\n\t\t\t\t// Abort previous\n\t\t\t\tthis.lastController?.abort();\n\t\t\t\tthis.lastController = new AbortController;\n\t\t\t\tconst flags = { signal: this.lastController.signal };\n\t\t\t\treturn flags;\n\t\t\t},\n\t\t\tdisconnect() { this.lastController?.abort(); }\n\t\t}\n\t}\n\t\t\n\t/**\n\t * Loops through registration objects whose contexts match the event context.\n\t * \n\t * @param String \t\tinterceptionTiming\n\t * @param Object|Array \trecord_s\n\t * @param Function \t\tcallback \n\t * \n\t * @returns void\n\t */\n\tforEachMatchingContext( interceptionTiming, record_s, callback ) {\n\t\tconst { window } = this, records = Array.isArray( record_s ) ? record_s : [ record_s ];\n\t\tlet dispatchBatch = new Set;\n\t\tfor ( const [ depth, registries ] of this.registry( interceptionTiming ) ) {\n\t\t\tfor ( const [ context, registry ] of registries ) {\n\t\t\t\t// Ensure event target is/within context\n\t\t\t\tlet matches = records.filter( record => {\n\t\t\t\t\tif ( !context.contains( record.target ) ) return false;\n\t\t\t\t\treturn depth === 'subtree' || record.target === context;\n\t\t\t\t} );\n\t\t\t\tif ( !matches.length ) continue;\n\t\t\t\t// Records will be dispatched in their original form\n\t\t\t\tif ( !Array.isArray( record_s ) ) { matches = matches[ 0 ]; }\n\t\t\t\tfor ( const registration of registry ) {\n\t\t\t\t\tdispatchBatch.add( [ registration, matches, context ] );\n\t\t\t\t\t//callback.call( window, registration, matches, context );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Saving everything to dispatchBatch ensures that recursive modifications\n\t\t// to both this.registry( interceptionTiming ), registries, and registry aren't pciked up\n\t\tfor ( const [ registration, record_s, context ] of dispatchBatch ) {\n\t\t\tcallback.call( window, registration, record_s, context );\n\t\t}\n\t}\n\n\t/**\n\t * @disconnectables\n\t * \n\t * @param AbortSignal \t\tsignal\n\t * @param Array \t\t\t...objects \n\t * \n\t * @returns Object\n\t */\n\tdisconnectables( signal, ...objects ) {\n\t\tconst disconnectable = { disconnect() {\n\t\t\tobjects.forEach( d => (\n\t\t\t\td && _isFunction( d.disconnect ) && d.disconnect() \n\t\t\t\t|| _isFunction( d ) && d() \n\t\t\t\t|| _isObject( d ) && ( d.disconnected = true )\n\t\t\t) );\n\t\t} };\n\t\tif ( signal ) signal.addEventListener( 'abort', () => disconnectable.disconnect() );\n\t\treturn disconnectable;\n\t}\n}\n", "\n/**\n * @imports\n */\nimport Realtime from './Realtime.js';\nimport DOMSpec from './DOMSpec.js';\n\n/**\n *\n * @class AttrRealtime\n */\nexport default class AttrRealtime extends Realtime {\n\n\t/**\n\t * @constructor\n\t */\n\tconstructor( context, ...args ) {\n\t\tsuper( context, 'attr', ...args );\n\t}\n\t\n\t/**\n\t * Runs a query.\n\t *\n\t * @param array|string\t\t\t\tspec\n\t * @param function\t\t\t\t\tcallback\n\t * @param object\t\t\t\t\tparams\n\t *\n\t * @return Disconnectable|Void\n\t */\n\tget( spec, callback = undefined, params = {} ) {\n\t\tconst originalFilterIsString = typeof spec === 'string' || spec instanceof DOMSpec;\n\t\t[ spec = [], callback = undefined, params = {} ] = this.resolveArgs( arguments );\n\t\tconst { context } = this;\n\t\t// -------------\n\t\tconst records = attrIntersection( context, spec );\n\t\tif ( !callback ) return records;\n\t\tconst signalGenerator = params.lifecycleSignals && this.createSignalGenerator();\n\t\tif ( !originalFilterIsString ) {\n\t\t\tconst flags = signalGenerator?.generate() || {};\n\t\t\tcallback( records, flags, context );\n\t\t} else {\n\t\t\tfor ( const record of records ) {\n\t\t\t\tconst flags = signalGenerator?.generate() || {};\n\t\t\t\tcallback( record, flags, context );\n\t\t\t}\n\t\t}\n\t\t// -------------\n\t\tif ( params.live ) {\n\t\t\tif ( signalGenerator ) { params = { ...params, signalGenerator }; }\n\t\t\tconst disconnectable_live = this.observe( originalFilterIsString ? spec[ 0 ] : spec, callback, { newValue: true, ...params } );\n\t\t\treturn this.disconnectables( params.signal, disconnectable_live );\n\t\t}\n\t}\n\n\t/**\n\t * Mutation Observer\n\t * \n\t * @param array|string\t\t\t\tspec\n\t * @param function\t\t\t\t\tcallback\n\t * @param object\t\t\t\t\tparams\n\t * \n\t * @returns Disconnectable\n\t */\n\tobserve( spec, callback, params = {} ) {\n\t\tconst originalFilterIsString = typeof spec === 'string' || spec instanceof DOMSpec;\n\t\t[ spec = [], callback, params = {} ] = this.resolveArgs( arguments );\n\t\t// ------------------------\n\t\tif ( [ 'sync', 'intercept' ].includes( params.timing ) ) return this.observeSync( originalFilterIsString ? spec[ 0 ] : spec, callback, params );\n\t\tif ( params.timing && params.timing !== 'async' ) throw new Error( `Timing option \"${ params.timing }\" invalid.` );\n\t\t// ------------------------\n\t\tconst { context, window, webqit } = this;\n\t\t// ------------------\n\t\tif ( params.eventDetails && !webqit.realdom.attrInterceptionHooks?.intercepting ) {\n\t\t\tattrInterception.call( window, 'intercept', () => {} );\n\t\t}\n\t\t// -------------\n\t\tconst disconnectable = new window.MutationObserver( records => {\n\t\t\trecords = dedup( records ).map( rcd => withAttrEventDetails.call( window, rcd ) );\n\t\t\tdispatch.call( window, registration, records, context );\n\t\t} );\n\t\t// ------------------\n\t\tconst $params = { attributes: true, attributeOldValue: params.oldValue, subtree: params.subtree };\n\t\tif ( spec.length ) { $params.attributeFilter = spec.map( a => a + '' ); }\n\t\tdisconnectable.observe( context, $params );\n\t\t// -------------\n\t\tconst signalGenerator = params.signalGenerator || params.lifecycleSignals && this.createSignalGenerator();\n\t\tconst registration = { context, spec, callback, params, atomics: new Map, originalFilterIsString, signalGenerator, disconnectable };\n\t\t// -------------\n\t\treturn this.disconnectables( params.signal, disconnectable, signalGenerator );\n\t}\n\t\n\t/**\n\t * Mutation Interceptor\n\t * \n\t * @param array|string\t\t\t\tspec\n\t * @param function\t\t\t\t\tcallback\n\t * @param object\t\t\t\t\tparams\n\t * \n\t * @returns Disconnectable\n\t */\n\tobserveSync( spec, callback, params = {} ) {\n\t\tconst originalFilterIsString = typeof spec === 'string' || spec instanceof DOMSpec;\n\t\t[ spec, callback, params = {} ] = this.resolveArgs( arguments );\n\t\tconst { context, window } = this;\n\t\t// -------------\n\t\tif ( params.timing && ![ 'sync', 'intercept' ].includes( params.timing ) ) throw new Error( `Timing option \"${ params.timing }\" invalid.` );\n\t\tconst interceptionTiming = params.timing === 'intercept' ? 'intercept' : 'sync';\n\t\tconst intersectionDepth = params.subtree ? 'subtree' : 'children';\n\t\tif ( !this.registry( interceptionTiming ).size ) {\n\t\t\t// One handler per intercept/sync registry\n\t\t\tattrInterception.call( window, interceptionTiming, records => {\n\t\t\t\tthis.forEachMatchingContext( interceptionTiming, records, dispatch );\n\t\t\t} );\n\t\t}\n\t\t// -------------\n\t\tconst disconnectable = { disconnect() {\n\t\t\tregistry.delete( registration );\n\t\t\tif ( !registry.size ) { registries.delete( context ); }\n\t\t} };\n\t\tconst signalGenerator = params.signalGenerator || params.lifecycleSignals && this.createSignalGenerator();\n\t\tconst registration = { context, spec, callback, params, atomics: new Map, originalFilterIsString, signalGenerator, disconnectable };\n\t\t// -------------\n\t\tconst registries = this.registry( interceptionTiming, intersectionDepth );\n\t\tif ( !registries.has( context ) ) { registries.set( context, new Set ); }\n\t\tconst registry = registries.get( context );\n\t\tregistry.add( registration );\n\t\t// -------------\n\t\treturn this.disconnectables( params.signal, disconnectable, signalGenerator );\n\t}\n}\n\n/**\n * Deduplicates records.\n * \n * @param Array \t\t\trecords\n * \n * @returns Array\n */\nfunction dedup( records ) {\n\treturn records.reduce( ( rcds, rcd, i ) => {\n\t\tif ( rcds[ i - 1 ]?.attributeName === rcd.attributeName ) return rcds;\n\t\treturn rcds.concat( rcd );\n\t}, [] );\n}\n\n/**\n * Dispatches a mutation record if it matches the observed.\n * \n * @param Object \t\t\tregistration\n * @param Array \t\t\trecords\n * \n * @returns Void\n */\nfunction dispatch( registration, records ) {\n\tconst { context, spec, callback, params, atomics, originalFilterIsString, signalGenerator } = registration;\n\tconst $spec = spec.map( a => a + '' );\n\tif ( params.atomic && !atomics.size ) {\n\t\trecords = attrIntersection( context, spec, records );\n\t} else if ( params.timing !== 'async' && spec.length ) {\n\t\trecords = records.filter( r => $spec.includes( r.name ) );\n\t}\n\tif ( !records.length ) return;\n\t// Should we care about old / new values being present?\n\tif ( !( params.newValue === null && params.oldValue === null && params.eventDetails ) ) {\n\t\trecords = records.map( rcd => {\n\t\t\tlet exclusion;\n\t\t\tif ( !params.eventDetails ) {\n\t\t\t\t( { event: exclusion, ...rcd } = rcd );\n\t\t\t}\n\t\t\tif ( !params.oldValue && ( 'oldValue' in rcd ) ) {\n\t\t\t\t( { oldValue: exclusion, ...rcd } = rcd );\n\t\t\t}\n\t\t\tif ( !params.newValue && ( 'value' in rcd ) ) {\n\t\t\t\t( { value: exclusion, ...rcd } = rcd );\n\t\t\t} else if ( params.newValue && typeof rcd.value === 'undefined' ) {\n\t\t\t\trcd = {  ...rcd, value: rcd.target.getAttribute( rcd.name ) };\n\t\t\t}\n\t\t\treturn rcd;\n\t\t} );\n\t}\n\tif ( params.atomic ) {\n\t\trecords.forEach( record => atomics.set( record.name, record ) );\n\t\trecords = Array.from( atomics.entries() ).map( ( [ , value ] ) => value );\n\t}\n\tconst record_s = originalFilterIsString ? records[ 0 ] : records;\n\tconst flags = signalGenerator?.generate() || {};\n\tcallback( record_s, flags, context );\n}\n\n/**\n * Helper to determining which records to deliver.\n * \n * @param Object \t\t\tcontext\n * @param Array \t\t\tspec\n * @param Array \t\t\trecords\n * \n * @returns Array\n */\nfunction attrIntersection( context, spec, records = [] ) {\n\tconst _type = { event: null, type: 'attribute' };\n\tif ( spec.length ) {\n\t\treturn spec.map( attrName => {\n\t\t\tattrName = attrName + '';\n\t\t\treturn records.find( r => r.name === attrName ) || { target: context, name: attrName, value: context.getAttribute( attrName ), ..._type };\n\t\t} );\n\t}\n\tconst attrs = Array.from( context.attributes );\n\treturn attrs.map( attr => {\n\t\treturn records.find( r => r.name === attr.nodeName ) || { target: context, name: attr.nodeName, value: attr.nodeValue, ..._type };\n\t} );\n}\n\n/**\n * Determines the event for an attr mutation record.\n * \n * @param MutationRecord \t{ target, attributeName }\n * \n * @returns Object\n */\nfunction withAttrEventDetails( { target, attributeName, value, oldValue } ) {\n\tconst window = this, registry = window.webqit.realdom.attrInterceptionRecords?.get( target ) || {};\n\tconst event = registry[ attributeName ]?.[ 0 ] || 'mutation';\n\tconst record = { target, name: attributeName, value, oldValue, type: 'observation', event };\n\treturn record;\n}\n\n/**\n * Attributes intersection engine.\n * \n * @param String \t\t\ttiming \n * @param Function \t\t\tcallback \n * \n * @returns \n */\nfunction attrInterception( timing, callback ) {\n\tconst window = this;\n\tconst { webqit, document, Element } = window;\n\tif ( !webqit.realdom.attrInterceptionHooks ) { Object.defineProperty( webqit.realdom, 'attrInterceptionHooks', { value: new Map } ); }\n\tif ( !webqit.realdom.attrInterceptionHooks.has( timing ) ) { webqit.realdom.attrInterceptionHooks.set( timing, new Set ); }\n\twebqit.realdom.attrInterceptionHooks.get( timing ).add( callback );\n\tconst rm = () => webqit.realdom.attrInterceptionHooks.get( timing ).delete( callback );\n\tif ( webqit.realdom.attrInterceptionHooks?.intercepting ) return rm;\n\tconsole.warn( `Attr mutation APIs are now being intercepted.` );\n\twebqit.realdom.attrInterceptionHooks.intercepting = true;\n\tObject.defineProperty( webqit.realdom, 'attrInterceptionRecords', { value: new Map } );\n\n\t// Interception hooks\n\tconst attrIntercept = ( record, defaultAction ) => {\n\t\tif ( !webqit.realdom.attrInterceptionRecords.has( record.target ) ) { webqit.realdom.attrInterceptionRecords.set( record.target, {} ); }\n\t\tconst registry = webqit.realdom.attrInterceptionRecords.get( record.target );\n\t\t// ------------------\n\t\tregistry[ record.name ] = registry[ record.name ] || [];\n\t\tregistry[ record.name ].unshift( record.event );\n\t\t// ------------------\n\t\twebqit.realdom.attrInterceptionHooks.get( 'intercept' )?.forEach( callback => callback( [ record ] ) );\n\t\tconst returnValue = defaultAction();\n\t\twebqit.realdom.attrInterceptionHooks.get( 'sync' )?.forEach( callback => callback( [ record ] ) );\n\t\treturn returnValue;\n\t};\n\n\t// Interception observer WILL need to know non-API-based mutations\n\tconst mo = new window.MutationObserver( records => {\n\t\trecords = records.filter( rcd => {\n\t\t\tconst registry = window.webqit.realdom.attrInterceptionRecords?.get( rcd.target ) || {};\n\t\t\treturn !registry[ rcd.attributeName ]?.shift();\n\t\t} );\n\t\trecords = dedup( records ).map( rcd => withAttrEventDetails.call( window, rcd ) );\n\t\tif ( !records.length ) return;\n\t\twebqit.realdom.attrInterceptionHooks.get( 'intercept' )?.forEach( callback => callback( records ) );\n\t\twebqit.realdom.attrInterceptionHooks.get( 'sync' )?.forEach( callback => callback( records ) );\n\t} );\n\tmo.observe( document, { attributes: true, subtree: true, attributeOldValue: true } );\n\n\t// Intercept DOM attr mutation methods\n\tconst originalApis = Object.create( null );\n\t[ 'setAttribute', 'removeAttribute', 'toggleAttribute', ].forEach( apiName => {\n\t\toriginalApis[ apiName ] = Element.prototype[ apiName ];\n\t\tElement.prototype[ apiName ] = function( ...args ) {\n\t\t\tlet value, oldValue = this.getAttribute( args[ 0 ] );\n\t\t\tif ( [ 'setAttribute', 'toggleAttribute' ].includes( apiName ) ) { value = args[ 1 ]; }\n\t\t\tif ( apiName === 'toggleAttribute' && value === undefined ) {\n\t\t\t\tvalue = oldValue === null ? true : false;\n\t\t\t}\n\t\t\tconst record = { target: this, name: args[ 0 ], value, oldValue, type: 'interception', event: [ this, apiName ] };\n\t\t\tconst exec = () => originalApis[ apiName ].call( this, ...args );\n\t\t\treturn attrIntercept( record, exec );\n\t\t}\n\t} );\n\n\treturn rm;\n}\n", "\n/**\n * @imports\n */\nimport { _isObject } from '@webqit/util/js/index.js';\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport AttrRealtime from './AttrRealtime.js';\nimport Realtime from './Realtime.js';\nimport * as Xpath from './Xpath.js';\n\n/**\n *\n * @class DOMRealtime\n */\nexport default class DOMRealtime extends Realtime {\n\n\t/**\n\t * @constructor\n\t */\n\tconstructor( context, ...args ) {\n\t\tsuper( context, 'tree', ...args );\n\t}\n\n\t/**\n\t * Alias for ( new AttrRealtime() ).all( ... )\n\t */\n\tattr( filter, callback = undefined, params = {} ) {\n\t\tconst { context, window } = this;\n\t\treturn ( new AttrRealtime( context, window ) ).get( ...arguments );\n\t}\n\n\t/**\n\t * Runs a query.\n\t *\n\t * @param array|Element|string\t\tspec\n\t * @param function\t\t\t\t\tcallback\n\t * @param object\t\t\t\t\tparams\n\t *\n\t * @return Disconnectable|Void\n\t */\n\tquery( spec, callback = undefined, params = {} ) {\n\t\t[ spec, callback = undefined, params = {} ] = this.resolveArgs( arguments );\n\t\tconst { context } = this;\n\t\t// ------------------\n\t\tconst records = new Map, getRecord = target => {\n\t\t\tif ( !records.has( target ) ) { records.set( target, { target, entrants: [], exits: [], type: 'query', event: null } ); }\n\t\t\treturn records.get( target );\n\t\t};\n\t\t// ------------------\n\t\tif ( !params.generation || params.generation === 'entrants' ) {\n\t\t\tif ( !spec.length ) {\n\t\t\t\t//if ( params.subtree ) throw new Error( `The subtree option requires a selector to work.` );\n\t\t\t\t[ ...context.children ].forEach( node => getRecord( context ).entrants.push( node ) );\n\t\t\t} else if ( spec.every( s => s.type === 'selector' ) ) {\n\t\t\t\tconst [ cssSelectors, xpathQueries ] = spec.reduce( ( [ css, xpath ], s ) => {\n\t\t\t\t\treturn s.kind === 'xpath' ? [ css, xpath.concat( s ) ] : [ css.concat( s ), xpath ];\n\t\t\t\t}, [ [], [] ] );\n\t\t\t\tconst matches = [];\n\t\t\t\tif ( params.subtree ) {\n\t\t\t\t\tif ( cssSelectors.length ) { matches.push( ...context.querySelectorAll( cssSelectors.join( ',' ) ) ); }\n\t\t\t\t\tif ( xpathQueries.length ) { matches.push( ...Xpath.query( this.window, context, xpathQueries ) ); }\n\t\t\t\t} else {\n\t\t\t\t\tif ( cssSelectors.length ) { matches.push( ...[ ...context.children ].filter( node => node.matches( cssSelectors ) ) ); }\n\t\t\t\t\tif ( xpathQueries.length ) { matches.push( ...Xpath.query( this.window, context, xpathQueries, false ) ); }\n\t\t\t\t}\n\t\t\t\tmatches.forEach( node => getRecord( node.parentNode || context ).entrants.push( node ) );\n\t\t\t}\n\t\t}\n\t\t// ------------------\n\t\tif ( !callback ) return records;\n\t\tconst disconnectable = { disconnected: false };\n\t\tconst signalGenerator = callback && params.lifecycleSignals && this.createSignalGenerator();\n\t\tfor ( const [ , record ] of records ) {\n\t\t\tif ( disconnectable.disconnected ) break;\n\t\t\tconst flags = signalGenerator?.generate() || {};\n\t\t\tcallback( record, flags, context );\n\t\t}\n\t\t// ------------------\n\t\tif ( params.live ) {\n\t\t\tif ( signalGenerator ) { params = { ...params, signalGenerator }; }\n\t\t\tconst disconnectable_live = this.observe( spec, callback, params );\n\t\t\treturn this.disconnectables( params.signal, disconnectable, disconnectable_live );\n\t\t}\n\t\treturn this.disconnectables( params.signal, disconnectable, signalGenerator );\n\t}\n\n\t/**\n\t * Alias for query( ..., { subtree: false } )\n\t */\n\tchildren( spec, callback = undefined, params = {} ) {\n\t\t[ spec, callback = undefined, params = {} ] = this.resolveArgs( arguments );\n\t\treturn this.query( spec, callback, { ...params, subtree: false } );\n\t}\n\n\t/**\n\t * Alias for query( ..., { subtree: true } )\n\t */\n\tsubtree( spec, callback = undefined, params = {} ) {\n\t\t[ spec, callback = undefined, params = {} ] = this.resolveArgs( arguments );\n\t\treturn this.query( spec, callback, { ...params, subtree: true } );\n\t}\n\n\t/**\n\t * Mutation Observer\n\t * \n\t * @param array|Element|string\t\tspec\n\t * @param function\t\t\t\t\tcallback\n\t * @param object\t\t\t\t\tparams\n\t * \n\t * @returns Disconnectable\n\t */\n\tobserve( spec, callback, params = {} ) {\n\t\t[ spec, callback, params = {} ] = this.resolveArgs( arguments );\n\t\t// ------------------------\n\t\tif ( [ 'sync', 'intercept' ].includes( params.timing ) ) return this.observeSync( spec, callback, params );\n\t\tif ( params.timing && params.timing !== 'async' ) throw new Error( `Timing option \"${ params.timing }\" invalid.` );\n\t\t// ------------------------\n\t\tconst { context, window, webqit, document } = this;\n\t\t// ------------------\n\t\tif ( params.eventDetails ) { webqit.realdom.domInterceptionRecordsAlwaysOn = true; }\n\t\tif ( ( document.readyState === 'loading' || webqit.realdom.domInterceptionRecordsAlwaysOn ) && !webqit.realdom.domInterceptionHooks?.intercepting ) {\n\t\t\tdomInterception.call( window, 'sync', () => {} );\n\t\t}\n\t\t// -------------\n\t\tconst disconnectable = new window.MutationObserver( records => records.forEach( record => {\n\t\t\tdispatch.call( window, registration, withEventDetails.call( window, record ), context );\n\t\t} ) );\n\t\tdisconnectable.observe( context, { childList: true, subtree: params.subtree, } );\n\t\tconst signalGenerator = params.signalGenerator || params.lifecycleSignals && this.createSignalGenerator();\n\t\tconst registration = { context, spec, callback, params, signalGenerator, disconnectable };\n\t\t// -------------\n\t\tif ( params.staticSensitivity ) {\n\t\t\tconst disconnectable_attr = staticSensitivity.call( window, registration );\n\t\t\treturn this.disconnectables( params.signal, disconnectable, signalGenerator, disconnectable_attr );\n\t\t}\n\t\treturn this.disconnectables( params.signal, disconnectable, signalGenerator );\n\t}\n\t\n\t/**\n\t * Mutation Interceptor\n\t * \n\t * @param array|Element|string\t\tspec\n\t * @param function\t\t\t\t\tcallback\n\t * @param object\t\t\t\t\tparams\n\t * \n\t * @returns Disconnectable\n\t */\n\tobserveSync( spec, callback, params = {} ) {\n\t\t[ spec, callback, params = {} ] = this.resolveArgs( arguments );\n\t\tconst { context, window } = this;\t\t\n\t\t// -------------\n\t\tif ( params.timing && ![ 'sync', 'intercept' ].includes( params.timing ) ) throw new Error( `Timing option \"${ params.timing }\" invalid.` );\n\t\tconst interceptionTiming = params.timing === 'intercept' ? 'intercept' : 'sync';\n\t\tconst intersectionDepth = params.subtree ? 'subtree' : 'children';\n\t\tif ( !this.registry( interceptionTiming ).size ) {\n\t\t\t// One handler per intercept/sync registry\n\t\t\tdomInterception.call( window, interceptionTiming, record => {\n\t\t\t\tthis.forEachMatchingContext( interceptionTiming, record, dispatch );\n\t\t\t} );\n\t\t}\n\t\tconst mo = new window.MutationObserver( records => records.forEach( record => {\n\t\t\tif ( Array.isArray( ( record = withEventDetails.call( window, record ) ).event ) ) return;\n\t\t\tdispatch.call( window, registration, record, context );\n\t\t} ) );\n\t\tmo.observe( context, { childList: true, subtree: params.subtree } );\n\t\t// -------------\n\t\tconst disconnectable = { disconnect() {\n\t\t\tmo.disconnect();\n\t\t\tregistry.delete( registration );\n\t\t\tif ( !registry.size ) { registries.delete( context ); }\n\t\t} };\n\t\tconst signalGenerator = params.signalGenerator || params.lifecycleSignals && this.createSignalGenerator();\n\t\tconst registration = { context, spec, callback, params, signalGenerator, disconnectable };\n\t\t// -------------\n\t\tconst registries = this.registry( interceptionTiming, intersectionDepth );\n\t\tif ( !registries.has( context ) ) { registries.set( context, new Set ); }\n\t\tconst registry = registries.get( context );\n\t\tregistry.add( registration );\n\t\t// -------------\n\t\tif ( params.staticSensitivity ) {\n\t\t\tconst disconnectable_attr = staticSensitivity.call( window, registration );\n\t\t\treturn this.disconnectables( params.signal, disconnectable, signalGenerator, disconnectable_attr );\n\t\t}\n\t\treturn this.disconnectables( params.signal, disconnectable, signalGenerator );\n\t}\n}\n\n/**\n * Sensitivty for attribute changes for attribute spec.\n * \n * @param object registration\n * \n * @returns Disconnectable\n */\nfunction staticSensitivity( registration ) {\n\tconst window = this;\n\tconst { context, spec, callback, params, signalGenerator } = registration;\n\tconst cssSelectors = spec.filter( s => s.kind === 'css' );\n\tconst parseDot = selector => selector.match( /\\.([\\w-]+)/g )?.length ? [ 'class' ] : [];\n\tconst parseHash = selector => selector.match( /#([\\w-]+)/g )?.length ? [ 'id' ] : [];\n\tconst parse = selector => [ ...selector.matchAll( /\\[([^\\=\\]]+)(\\=[^\\]]+)?\\]/g ) ].map( x => x[ 1 ] ).concat( parseDot( selector ) ).concat( parseHash( selector ) );\n\tif ( !( registration.$attrs = Array.from( new Set( cssSelectors.filter( s => ( s + '' ).includes( '[' ) ).reduce( ( attrs, selector ) => attrs.concat( parse( selector + '' ) ), [] ) ) ) ).length ) return;\n\t// ---------\n\tconst entrants = new Set, exits = new Set;\n\tentrants.push = val => ( exits.delete( val ), entrants.add( val ) );\n\texits.push = val => ( entrants.delete( val ), exits.add( val ) );\n\tregistration.$deliveryCache = { entrants, exits };\n\t// ---------\n\treturn ( new AttrRealtime( context, window ) ).observe( registration.$attrs, _records => {\n\t\tconst records = new Map, getRecord = target => {\n\t\t\tif ( !records.has( target ) ) { records.set( target, { target, entrants: [], exits: [], type: 'static', event: null } ); }\n\t\t\treturn records.get( target );\n\t\t};\n\t\t// ---------\n\t\tconst matchesCache = new WeakMap;\n\t\tconst matches = node => {\n\t\t\tif ( !matchesCache.has( node ) ) { matchesCache.set( node, cssSelectors.some( s => node.matches( s + '' ) ) ); }\n\t\t\treturn matchesCache.get( node );\n\t\t};\n\t\t// ---------\n\t\tfor ( const _record of _records ) {\n\t\t\t[ 'entrants', 'exits' ].forEach( generation => {\n\t\t\t\tif ( params.generation && generation !== params.generation ) return;\n\t\t\t\tif ( registration.$deliveryCache[ generation ].has( _record.target ) || ( generation === 'entrants' ? !matches( _record.target ) : matches( _record.target ) ) ) return;\n\t\t\t\tregistration.$deliveryCache[ generation ].push( _record.target );\n\t\t\t\tgetRecord( _record.target )[ generation ].push( _record.target );\n\t\t\t\tgetRecord( _record.target ).event = _record.event;\n\t\t\t} );\n\t\t}\n\t\t// ---------\n\t\tfor ( const [ , record ] of records ) {\n\t\t\tconst flags = signalGenerator?.generate() || {};\n\t\t\tcallback( record, flags, context );\n\t\t}\n\t}, { subtree: params.subtree, timing: params.timing, eventDetails: params.eventDetails } );\n}\n\n/**\n * Dispatches a mutation record if it matches the observed.\n * \n * @param Object \t\t\tregistration \n * @param Object \t\t\trecord \n * \n * @returns Void\n */\nfunction dispatch( registration, _record ) {\n\tconst { context, spec, callback, params, signalGenerator, $deliveryCache } = registration;\n\t// ---------\n\tconst record = { ..._record, entrants: [], exits: [] };\n\tif ( !params.eventDetails ) { delete record.event; }\n\t[ 'entrants', 'exits' ].forEach( generation => {\n\t\tif ( params.generation && generation !== params.generation ) return;\n\t\tif ( spec.length ) {\n\t\t\trecord[ generation ] = nodesIntersection.call( this, spec, _record[ generation ], _record.event !== 'parse' );\n\t\t} else {\n\t\t\trecord[ generation ] = [ ..._record[ generation ] ];\n\t\t}\n\t\tif ( !$deliveryCache ) return;\n\t\tfor ( const node of record[ generation ] ) {\n\t\t\t$deliveryCache[ generation ].push( node );\n\t\t}\n\t} );\n\t// ---------\n\tif ( !record.entrants.length && !record.exits.length ) return;\n\tconst flags = signalGenerator?.generate() || {};\n\tcallback( record, flags, context );\n}\n\n/**\n * Aggregates instances of els in sources\n * \n * @param Array \t\t\tspec \n * @param Array \t\t\tsources \n * @param Bool \t\t\t\tdeepIntersect \n * \n * @returns \n */\nfunction nodesIntersection( spec, sources, deepIntersect ) {\n\tsources = Array.isArray( sources ) ? sources : [ ...sources ];\n\tconst match = ( sources, s ) => {\n\t\t// Filter out text nodes\n\t\tif ( s.type === 'selector' ) {\n\t\t\t// Is directly mutated...\n\t\t\tlet matches = s.isXpathAttr ? [] : sources.filter( source => s.kind === 'xpath' ? Xpath.match( this, source, s + '' ) : source.matches && source.matches( s + '' ) );\n\t\t\t// Is contextly mutated...\n\t\t\tif ( deepIntersect || s.isXpathAttr ) {\n\t\t\t\tmatches = sources.reduce( ( collection, source ) => {\n\t\t\t\t\tif ( s.kind === 'xpath' ) { return [ ...collection, ...Xpath.query( this, source, s, deepIntersect ) ]; }\n\t\t\t\t\treturn source.querySelectorAll ? [ ...collection, ...source.querySelectorAll( s + '' ) ] : collection;\n\t\t\t\t}, matches );\n\t\t\t}\n\t\t\tif ( matches.length ) return matches;\n\t\t} else {\n\t\t\t// Is directly mutated...\n\t\t\tif ( sources.includes( s.content ) || (\n\t\t\t\tdeepIntersect && sources.some( source => source.contains( s.content ) )\n\t\t\t) ) { return [ s.content ]; }\n\t\t}\n\t};\n\t// Search can be expensive...\n\t// Multiple listeners searching the same thing in the same list?\n\tif ( !sources.$$searchCache ) { sources.$$searchCache = new Map; }\n\treturn spec.reduce( ( matches, s ) => {\n\t\tlet _matches;\n\t\tif ( sources.$$searchCache.has( s.content ) ) {\n\t\t\t_matches = sources.$$searchCache.get( s.content );\n\t\t} else {\n\t\t\t_matches = match( sources, s ) || [];\n\t\t\tif ( s.type === 'instance' ) {\n\t\t\t\tsources.$$searchCache.set( s.content, _matches );\n\t\t\t}\n\t\t}\n\t\treturn matches.concat( _matches );\n\t}, [] );\n}\n\n/**\n * Determines the event for a mutation record\n * \n * @param MutationRecord \t{ target, entrants, exits }\n * \n * @returns Object\n */\nfunction withEventDetails( { target, addedNodes, removedNodes } ) {\n\tlet window = this, event;\n\tevent = _arrFrom( addedNodes ).reduce( ( prev, node ) => prev || window.webqit.realdom.domInterceptionRecords?.get( node ), null );\n\tevent = _arrFrom( removedNodes ).reduce( ( prev, node ) => prev || window.webqit.realdom.domInterceptionRecords?.get( node ), event );\n\tevent = event || window.document.readyState === 'loading' && 'parse' || 'mutation';\n\treturn { target, entrants: addedNodes, exits: removedNodes, type: 'observation', event };\n}\n\n/**\n * DOM intersection engine.\n * \n * @param String \t\t\ttiming \n * @param Function \t\t\tcallback \n * \n * @returns \n */\nfunction domInterception( timing, callback ) {\n\tconst window = this;\n\tconst { webqit, document, Node, CharacterData, Element, HTMLElement, HTMLTemplateElement, DocumentFragment } = window;\n\tif ( !webqit.realdom.domInterceptionHooks ) { Object.defineProperty( webqit.realdom, 'domInterceptionHooks', { value: new Map } ); }\n\tif ( !webqit.realdom.domInterceptionHooks.has( timing ) ) { webqit.realdom.domInterceptionHooks.set( timing, new Set ); }\n\twebqit.realdom.domInterceptionHooks.get( timing ).add( callback );\n\tconst rm = () => webqit.realdom.domInterceptionHooks.get( timing ).delete( callback );\n\tif ( webqit.realdom.domInterceptionHooks?.intercepting ) return rm;\n\tconsole.warn( `DOM mutation APIs are now being intercepted.` );\n\twebqit.realdom.domInterceptionHooks.intercepting = true;\n\tObject.defineProperty( webqit.realdom, 'domInterceptionRecords', { value: new Map } );\n\n\t// Interception hooks\n\tconst intercept = ( record, defaultAction ) => {\n\t\trecord.entrants.concat( record.exits ).forEach( node => {\n\t\t\tclearTimeout( webqit.realdom.domInterceptionRecords.get( node )?.timeout ); // Clear any previous that's still active\n\t\t\twebqit.realdom.domInterceptionRecords.set( node, record.event ); // Main: set event details... and next to timeout details\n\t\t\tconst timeout = setTimeout( () => { webqit.realdom.domInterceptionRecords.delete( node ); }, 0 );\n\t\t\tObject.defineProperty( record.event, 'timeout', { value: timeout, configurable: true } );\n\t\t} );\n\t\twebqit.realdom.domInterceptionHooks.get( 'intercept' )?.forEach( callback => callback( record ) );\n\t\tconst returnValue = defaultAction();\n\t\twebqit.realdom.domInterceptionHooks.get( 'sync' )?.forEach( callback => callback( record ) );\n\t\treturn returnValue;\n\t};\n\n\t// Intercept DOM mutation methods\n\tconst _originalApis = { characterData: Object.create( null ), other: Object.create( null ) };\n\t[ 'insertBefore'/*Node*/, 'insertAdjacentElement', 'insertAdjacentHTML', 'setHTML',\n\t\t'replaceChildren', 'replaceWith', 'remove', 'replaceChild'/*Node*/, 'removeChild'/*Node*/, \n\t\t'before', 'after', 'append', 'prepend', 'appendChild'/*Node*/, \n\t].forEach( apiName => {\n\t\tfunction method( ...args ) {\n\t\t\tconst originalApis = this instanceof CharacterData ? _originalApis.characterData : _originalApis.other;\n\t\t\t// Instance of Node interface? Abort!\n\t\t\tconst exec = () => originalApis[ apiName ].call( this, ...args );\n\t\t\tif ( !( this instanceof CharacterData || this instanceof Element || this instanceof DocumentFragment ) ) return exec();\n\t\t\t// --------------\n\t\t\t// Obtain exits and entrants\n\t\t\tlet exits = [], entrants = [], target = this;\n\t\t\tif ( [ 'insertBefore' ].includes( apiName ) ) {\n\t\t\t\tentrants = [ args[ 0 ] ];\n\t\t\t} else if ( [ 'insertAdjacentElement', 'insertAdjacentHTML' ].includes( apiName ) ) {\n\t\t\t\tentrants = [ args[ 1 ] ];\n\t\t\t\tif ( [ 'beforebegin', 'afterend' ].includes( args[ 0 ] ) ) {\n\t\t\t\t\ttarget = this.parentNode;\n\t\t\t\t}\n\t\t\t} else if ( [ 'setHTML', 'replaceChildren' ].includes( apiName ) ) {\n\t\t\t\texits = [ ...this.childNodes ];\n\t\t\t\tentrants = apiName === 'replaceChildren' ? [ ...args ] : [ args[ 0 ] ];\n\t\t\t} else if ( [ 'replaceWith', 'remove' ].includes( apiName ) ) {\n\t\t\t\texits = [ this ];\n\t\t\t\tentrants = apiName === 'replaceWith' ? [ ...args ] : [];\n\t\t\t\ttarget = this.parentNode;\n\t\t\t} else if ( [ 'replaceChild' ].includes( apiName ) ) {\n\t\t\t\texits = [ args[ 1 ] ];\n\t\t\t\tentrants = [ args[ 0 ] ];\n\t\t\t} else if ( [ 'removeChild' ].includes( apiName ) ) {\n\t\t\t\texits = [ ...args ];\n\t\t\t} else {\n\t\t\t\t// 'before', 'after', 'append', 'prepend', 'appendChild'\n\t\t\t\tentrants = [ ...args ];\n\t\t\t\tif ( [ 'before', 'after' ].includes( apiName ) ) {\n\t\t\t\t\ttarget = this.parentNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// --------------\n\t\t\t// Parse HTML to entrants\n\t\t\tlet apiNameFinal = apiName;\n\t\t\tif ( [ 'insertAdjacentHTML', 'setHTML' ].includes( apiName ) ) {\n\t\t\t\tlet tempNodeName = this.nodeName;\n\t\t\t\tif ( apiName === 'insertAdjacentHTML' && [ 'beforebegin', 'afterend' ].includes( args[ 0 ] ) ) {\n\t\t\t\t\t// We can't handle this... and this is going to throw afterall\n\t\t\t\t\tif ( !this.parentNode ) return originalApis[ apiName ].call( this, ...args );\n\t\t\t\t\ttempNodeName = this.parentNode.nodeName;\n\t\t\t\t}\n\t\t\t\tconst temp = document.createElement( tempNodeName );\n\t\t\t\toriginalApis.setHTML.call( temp, entrants[ 0 ], apiName === 'setHTML' ? args[ 1 ] : {} );\n\t\t\t\tentrants = [ ...temp.childNodes ];\n\t\t\t\t// --------------  \n\t\t\t\tif ( apiName === 'insertAdjacentHTML' ) {\n\t\t\t\t\tapiNameFinal = 'insertAdjacentElement';\n\t\t\t\t\targs[ 1 ] = new DocumentFragment;\n\t\t\t\t\targs[ 1 ].______isTemp = true;\n\t\t\t\t\targs[ 1 ].append( ...temp.childNodes );\n\t\t\t\t} else {\n\t\t\t\t\tapiNameFinal = 'replaceChildren';\n\t\t\t\t\targs = [ ...temp.childNodes ];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// --------------\n\t\t\tconst record = { target, entrants, exits, type: 'interception', event: [ this, apiName ] };\n\t\t\treturn intercept( record, () => {\n\t\t\t\treturn originalApis[ apiNameFinal ].call( this, ...args );\n\t\t\t} );\n\t\t}\n\t\t// We'll be sure to monkey the correct interface\n\t\tif ( [ 'insertBefore', 'replaceChild', 'removeChild', 'appendChild' ].includes( apiName ) ) {\n\t\t\t_originalApis.other[ apiName ] = Node.prototype[ apiName ];\n\t\t\tNode.prototype[ apiName ] = method;\n\t\t} else {\n\t\t\t// Comment nodes have this methods too\n\t\t\tif ( [ 'after', 'before', 'remove', 'replaceWith' ].includes( apiName ) ) {\n\t\t\t\t_originalApis.characterData[ apiName ] = CharacterData.prototype[ apiName ];\n\t\t\t\tCharacterData.prototype[ apiName ] = method;\n\t\t\t}\n\t\t\t// In case newer methods like setHTML() are not supported\n\t\t\tif ( Element.prototype[ apiName ] ) {\n\t\t\t\t_originalApis.other[ apiName ] = Element.prototype[ apiName ];\n\t\t\t\tElement.prototype[ apiName ] = method;\n\t\t\t}\n\t\t}\n\t} );\n\n\tconst originalApis = Object.create( null );\n\t// Intercept DOM mutation properties\n\t[ 'outerHTML', 'outerText'/*HTMLElement*/, 'innerHTML', \n\t\t'innerText'/*HTMLElement*/,'textContent'/*Node*/, 'nodeValue'/*Node*/\n\t].forEach( apiName => {\n\t\t// We'll be sure to monkey the correct interface\n\t\tconst Interface = [ 'textContent', 'nodeValue' ].includes( apiName ) ? Node : (\n\t\t\t[ 'outerText', 'innerText' ].includes( apiName ) ? HTMLElement : Element\n\t\t);\n\t\toriginalApis[ apiName ] = Object.getOwnPropertyDescriptor( Interface.prototype, apiName );\n\t\tObject.defineProperty( Interface.prototype, apiName, { ...originalApis[ apiName ], set: function( value ) {\n\t\t\tlet exec = () => originalApis[ apiName ].set.call( this, value );\n\t\t\t// Instance of Node interface? Abort!\n\t\t\tif ( !( this instanceof Element ) ) return exec();\n\t\t\t// --------------\n\t\t\t// Obtain exits and entrants\n\t\t\tlet exits = [], entrants = [], target = this;\n\t\t\tif ( [ 'outerHTML', 'outerText' ].includes( apiName ) ) {\n\t\t\t\texits = [ this ];\n\t\t\t\ttarget = this.parentNode;\n\t\t\t} else {\n\t\t\t\t// 'innerHTML', 'innerText', 'textContent', 'nodeValue'\n\t\t\t\texits = /*this instanceof HTMLTemplateElement \n\t\t\t\t\t? [ ...this.content.childNodes ]\n\t\t\t\t\t: */[ ...this.childNodes ];\n\t\t\t}\n\t\t\t// --------------\n\t\t\t// Parse HTML to nodes\n\t\t\tif ( [ 'outerHTML', 'innerHTML' ].includes( apiName ) ) {\n\t\t\t\tlet tempNodeName = this.nodeName;\n\t\t\t\tif ( apiName === 'outerHTML' ) {\n\t\t\t\t\t// We can't handle this... and this is going to throw afterall\n\t\t\t\t\tif ( !this.parentNode ) return exec();\n\t\t\t\t\ttempNodeName = this.parentNode.nodeName;\n\t\t\t\t}\n\t\t\t\tconst temp = document.createElement( tempNodeName === 'TEMPLATE' ? 'div' : tempNodeName );\n\t\t\t\toriginalApis[ apiName ].set.call( temp, value );\n\t\t\t\tentrants = /*[ ...temp.childNodes ];*/this instanceof HTMLTemplateElement ? [] : [ ...temp.childNodes ];\n\t\t\t\t// -------------- \n\t\t\t\tif ( apiName === 'outerHTML' ) {\n\t\t\t\t\tvalue = new DocumentFragment;\n\t\t\t\t\tvalue.______isTemp = true;\n\t\t\t\t\tvalue.append( ...temp.childNodes );\n\t\t\t\t\texec = () => Element.prototype.replaceWith.call( this, value );\n\t\t\t\t} else {\n\t\t\t\t\tif ( this instanceof HTMLTemplateElement ) {\n\t\t\t\t\t\texec = () => this.content.replaceChildren( ...temp.childNodes );\n\t\t\t\t\t} else {\n\t\t\t\t\t\texec = () => Element.prototype.replaceChildren.call( this, ...temp.childNodes );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// -------------- \n\t\t\tconst record = { target, entrants, exits, type: 'interception', event: [ this, apiName ] };\n\t\t\treturn intercept( record, exec );\n\t\t} } );\n\t} );\n\n\t// Intercept document mutation methods\n\t[ 'append', 'prepend', 'replaceChildren' ].forEach( apiName => {\n\t\t[ document, DocumentFragment.prototype ].forEach( target => {\n\t\t\tconst originalApi = target[ apiName ];\n\t\t\ttarget[ apiName ] = function( ...args ) {\n\t\t\t\tif ( this.______isTemp ) return originalApi.call( this, ...args );\n\t\t\t\tconst exits = apiName === 'replaceChildren' ? [ ...this.childNodes ] : [];\n\t\t\t\tconst record = {\n\t\t\t\t\ttarget: this,\n\t\t\t\t\tentrants: args,\n\t\t\t\t\texits,\n\t\t\t\t\ttype: 'interception', \n\t\t\t\t\tevent: [ this, apiName ]\n\t\t\t\t};\n\t\t\t\treturn intercept( record, () => {\n\t\t\t\t\treturn originalApi.call( this, ...args );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t} );\n\n\treturn rm;\n}\n", "\r\n/**\r\n * Applies all supported polyfills\r\n */\r\nexport default function() {\r\n    CSS_escape.call( this );\r\n    Node_isConnected.call( this );\r\n    Element_matches.call( this );\r\n}\r\n\r\n/**\r\n * Polyfills the window.CSS object.\r\n *  \r\n * @return void\r\n */\r\nexport function CSS_escape() {\r\n    const window = this;\r\n    if ( !window.CSS ) { window.CSS = {} }\r\n    if ( !window.CSS.escape ) {\r\n        /**\r\n         * Polyfills the window.CSS.escape() function.\r\n         *  \r\n         * @param string str \r\n         * \r\n         * @return string\r\n         */\r\n        window.CSS.escape = str => str.replace( /([\\:@\\~\\$\\&])/g, '\\\\$1' );\r\n    }\r\n}\r\n\r\n/**\r\n * Polyfills the Node.prototype.isConnected property\r\n * \r\n * @see MDN\r\n  *  \r\n * @return bool\r\n*/\r\nexport function Node_isConnected() {\r\n    const window = this;\r\n    if ( !( 'isConnected' in window.Node.prototype ) ) {\r\n        Object.defineProperty( window.Node.prototype, 'isConnected', { get: function() {\r\n            return !this.ownerDocument || !(\r\n                this.ownerDocument.compareDocumentPosition( this )\r\n                & this.DOCUMENT_POSITION_DISCONNECTED);\r\n        } } );\r\n    }\r\n}\r\n\r\n/**\r\n * Polyfills the Element.prototype.matches() method\r\n * \r\n * @see MDN\r\n  *  \r\n * @return void\r\n*/\r\nexport function Element_matches() {\r\n    const window = this;\r\n    if ( !window.Element.prototype.matches ) {\r\n        window.Element.prototype.matches = \r\n        window.Element.prototype.matchesSelector || \r\n        window.Element.prototype.mozMatchesSelector ||\r\n        window.Element.prototype.msMatchesSelector || \r\n        window.Element.prototype.oMatchesSelector || \r\n        window.Element.prototype.webkitMatchesSelector ||\r\n        function( s ) {\r\n            var matches = ( this.document || this.ownerDocument ).querySelectorAll( s ),\r\n                i = matches.length;\r\n            while ( --i >= 0 && matches.item( i ) !== this ) {}\r\n            return i > -1;            \r\n        }\r\n    }\r\n}", "\r\n/**\r\n * @imports\r\n */\r\nimport { _isNumeric, _isString, _isFunction } from '@webqit/util/js/index.js';\r\nimport { _set } from '@webqit/util/obj/index.js';\r\nimport Scheduler from './Scheduler.js';\r\nimport DOMRealtime from './realtime/DOMRealtime.js';\r\nimport AttrRealtime from './realtime/AttrRealtime.js';\r\nimport polyfill from './polyfills.js';\r\n\r\nexport default function() {\r\n    const window = this;\r\n    if ( !window.webqit ) window.webqit = {};\r\n    if ( window.webqit.realdom ) return window.webqit.realdom;\r\n    window.webqit.realdom = {};\r\n    polyfill.call( window );\r\n    // ------\r\n    window.webqit.realdom.meta = ( ...args ) => meta.call( window, ...args );\r\n    window.webqit.realdom.ready = ( ...args ) => ready.call( window, ...args );\r\n    // ------\r\n    window.webqit.realdom.realtime = ( context, namespace = 'dom' ) => {\r\n        if ( namespace === 'dom' ) return new DOMRealtime( context, window );\r\n        if ( namespace === 'attr' ) return new AttrRealtime( context, window );\r\n    };\r\n    // ------\r\n    const scheduler = new Scheduler( window );\r\n    window.webqit.realdom.schedule = ( type, ...args ) => {\r\n        return scheduler[ `on${ type }` ]( ...args );\r\n    };\r\n    // ------\r\n    return window.webqit.realdom;\r\n}\r\n\r\n\r\n/**\r\n * DOM-ready listeners.\r\n * \r\n * @param Function\t    \t\tcallback\r\n * \r\n * @return void\r\n */\r\nfunction ready( ...args ) {\r\n    let timing = 'interactive', callback;\r\n    if ( _isString( args[ 0 ] ) ) {\r\n        timing = args[ 0 ];\r\n        if ( _isFunction( args[ 1 ] ) ) { callback = args[ 1 ]; }\r\n    } else if ( _isFunction( args[ 0 ] ) ) { callback = args[ 0 ]; }\r\n    // --------------\r\n    const timings = { interactive: [ 'interactive', 'complete' ], complete: [ 'complete' ], };\r\n    if ( !timings[ timing ] ) throw new Error( `Invalid ready-state timing: ${ timing }.` );\r\n\tconst window = this;\r\n    // --------------\r\n    if ( !callback ) {\r\n        if ( !window.webqit.realdom.readyStatePromises ) {\r\n            window.webqit.realdom.readyStatePromises = {\r\n                interactive: new Promise( res => ready.call( this, 'interactive', res ) ),\r\n                complete: new Promise( res => ready.call( this, 'complete', res ) ),\r\n            };\r\n        }\r\n        return window.webqit.realdom.readyStatePromises[ timing ];\r\n    }\r\n    // --------------\r\n\tif ( timings[ timing ].includes( window.document.readyState ) ) return callback( window );\r\n    if ( !window.webqit.realdom.readyStateCallbacks ) {\r\n        window.webqit.realdom.readyStateCallbacks = { interactive: [], complete: [] };\r\n        window.document.addEventListener( 'readystatechange', () => {\r\n            const state = window.document.readyState;\r\n            for ( const callback of window.webqit.realdom.readyStateCallbacks[ state ].splice( 0 ) ) {\r\n                callback( window );\r\n            }\r\n        }, false );\r\n    }\r\n    window.webqit.realdom.readyStateCallbacks[ timing ].push( callback );\r\n}\r\n\r\n/**\r\n * A webqit's meta tag props reader.\r\n *  \r\n * @param String name\r\n * \r\n * @return Object\r\n */\r\nfunction meta( name ) {\r\n    const window = this;\r\n    let _content = {}, _el;\r\n    if ( _el = window.document.querySelector( `meta[name=\"${ name }\"]` ) ) {\r\n        _content = ( _el.content || '' ).split( ';' ).filter( v => v ).reduce( ( _metaVars, directive ) => {\r\n            const directiveSplit = directive.split( '=' ).map( d => d.trim() );\r\n            _set( _metaVars, directiveSplit[ 0 ].split( '.' ), directiveSplit[ 1 ] === 'true' ? true : (directiveSplit[ 1 ] === 'false' ? false : (\r\n                    _isNumeric( directiveSplit[ 1 ] ) ? parseInt( directiveSplit[ 1 ] ) : directiveSplit[ 1 ]\r\n                ) )\r\n            );\r\n            return _metaVars;\r\n        }, {} );\r\n    }\r\n    return { get name() { return name; }, get content() { return _el.content; }, json() {\r\n\t\treturn JSON.parse( JSON.stringify( _content ) );\r\n    } };\r\n}", "\n/**\n * @imports\n */\nimport realdomInit from '@webqit/realdom';\nimport { _internals } from '@webqit/util/js/index.js';\nimport { _merge } from '@webqit/util/obj/index.js';\n\nexport const _ = ( ...args ) => _internals( 'oohtml', ...args );\n\nexport function _init( name, $config, $defaults ) {\n    const _name = name.toUpperCase().replace( '-', '_' );\n    const window = this, realdom = realdomInit.call( window );\n    window.webqit || ( window.webqit = {} );\n    window.webqit.oohtml || ( window.webqit.oohtml = {} );\n    window.webqit.oohtml.configs || ( window.webqit.oohtml.configs = {} );\n    window.webqit.oohtml.configs[ _name ] || ( window.webqit.oohtml.configs[ _name ] = {} );\n    // ---------------------\n    _merge( 2, window.webqit.oohtml.configs[ _name ], $defaults, $config, realdom.meta( name ).json() );\n    // ---------------------\n    return { config: window.webqit.oohtml.configs[ _name ], realdom, window };\n}\n\nexport function _compare( a, b, depth = 1, objectSizing = false ) {\n    if ( depth && typeof a === 'object' && a && typeof b === 'object' && b && ( !objectSizing || Object.keys( a ).length === Object.keys( b ).length ) ) {\n        for ( let key in a ) {\n            if ( !_compare( a[ key ], b[ key ], depth - 1, objectSizing ) ) return false;\n        }\n        return true;\n    }\n    if ( Array.isArray( a ) && Array.isArray( b ) && a.length === b.length ) {\n        return ( b = b.slice( 0 ).sort() ) && a.slice( 0 ).sort().every( ( valueA, i ) => valueA === b[ i ] );\n    }\n    return a === b;\n};", "\n/**\n * @imports\n */\nimport { resolveParams } from '@webqit/stateful-js/params';\nimport { StatefulAsyncFunction, StatefulAsyncScript, StatefulModule, State } from '@webqit/stateful-js/async';\nimport Observer from '@webqit/observer';\nimport Hash from './Hash.js';\nimport { _init } from '../util.js';\n\nexport {\n    StatefulAsyncFunction,\n    StatefulAsyncScript,\n    StatefulModule,\n    State,\n    Observer,\n}\n\n/**\n * @init\n * \n * @param Object $config\n */\nexport default function init( { advanced = {}, ...$config } ) {\n    const { config, window } = _init.call( this, 'scoped-js', $config, {\n        script: { retention: 'retain', mimeType: '' },\n        advanced: resolveParams( advanced ),\n    } );\n\tconfig.scriptSelector = ( Array.isArray( config.script.mimeType ) ? config.script.mimeType : [ config.script.mimeType ] ).reduce( ( selector, mm ) => {\n        const qualifier = mm ? `[type=${ window.CSS.escape( mm ) }]` : '';\n        return selector.concat( `script${ qualifier }[scoped],script${ qualifier }[stateful]` );\n    }, [] ).join( ',' );\n    Object.assign( window.webqit, { StatefulAsyncFunction, StatefulAsyncScript, StatefulModule, State, Observer } );\n    window.webqit.oohtml.Script = {\n        compileCache: [ new Map, new Map, ],\n        execute: execute.bind( window, config ),\n    };\n    realtime.call( window, config );\n}\n\n// Script runner\nasync function execute( config, execHash ) {\n    const window = this, { realdom } = window.webqit;\n    const exec = Hash.fromHash( execHash );\n    if ( !exec ) throw new Error( `Argument must be a valid exec hash.` );\n    const { script, compiledScript, thisContext } = exec;\n    // Honour retention flag\n    if ( config.script.retention === 'dispose' ) {\n        script.remove();\n    } else if ( config.script.retention === 'dispose' ) {\n        script.textContent = `\"source hidden\"`;\n    } else {\n        script.textContent = await compiledScript.toString();\n    }\n    // Execute and save state\n    const state = ( await compiledScript.bind( thisContext ) ).execute();\n    if ( script.stateful ) { Object.defineProperty( script, 'state', { value: state } ); }\n    realdom.realtime( window.document ).observe( script, () => {\n        if ( script.stateful ) { state.dispose(); }\n        if ( script.scoped ) { thisContext.scripts.splice( thisContext.scripts.indexOf( script, 1 ) ); }\n    }, { subtree: true, timing: 'sync', generation: 'exits' } );\n}\n\n/**\n * Performs realtime capture of elements and builds their relationships.\n *\n * @param Object config\n *\n * @return Void\n */\nfunction realtime( config ) {\n\tconst window = this, { oohtml, realdom } = window.webqit;\n    if ( !window.HTMLScriptElement.supports ) { window.HTMLScriptElement.supports = () => false; }\n    const potentialManualTypes = [ 'module' ].concat( config.script.mimeType || [] );\n\trealdom.realtime( window.document ).subtree/*instead of observe(); reason: jsdom timing*/( config.scriptSelector, record => {\n        record.entrants.forEach( script => {\n            if ( script.cloned ) return;\n            if ( 'stateful' in script ) return handled( script );\n            Object.defineProperty( script, 'stateful', { value: script.hasAttribute( 'stateful' ) } ); \n            if ( 'scoped' in script ) return handled( script );\n            Object.defineProperty( script, 'scoped', { value: script.hasAttribute( 'scoped' ) } ); \n            // Do compilation\n            const textContent = ( script._ = script.textContent.trim() ) && script._.startsWith( '/*@oohtml*/if(false){' ) && script._.endsWith( '}/*@oohtml*/' ) ? script._.slice( 21, -12 ) : script.textContent;\n            const sourceHash = Hash.toHash( textContent );\n            const compileCache = oohtml.Script.compileCache[ script.stateful ? 0 : 1 ];\n            let compiledScript;\n            if ( !( compiledScript = compileCache.get( sourceHash ) ) ) {\n                const { parserParams, compilerParams, runtimeParams } = config.advanced;\n                compiledScript = new ( script.type === 'module' ? StatefulModule : StatefulAsyncScript )( textContent, {\n                    exportNamespace: `#${ script.id }`,\n                    fileName: window.document.url,\n                    parserParams,\n                    compilerParams: { ...compilerParams, startStatic: !script.stateful },\n                    runtimeParams,\n                } );\n                compileCache.set( sourceHash, compiledScript );\n            }\n            // Run now!!!\n            const thisContext = script.scoped ? script.parentNode || record.target : ( script.type === 'module' ? undefined : window );\n            if ( script.scoped ) {\n                if ( !thisContext.scripts ) { Object.defineProperty( thisContext, 'scripts', { value: [] } ); }\n                thisContext.scripts.push( script );\n            }\n            const execHash = Hash.toHash( { script, compiledScript, thisContext } );\n            const manualHandling = record.type === 'query' || ( potentialManualTypes.includes( script.type ) && !window.HTMLScriptElement.supports( script.type ) );\n            if ( manualHandling ) { oohtml.Script.execute( execHash ); } else {\n                script.textContent = `webqit.oohtml.Script.execute( '${ execHash }' );`;\n            }\n        } );\n\t}, { live: true, timing: 'intercept', generation: 'entrants', eventDetails: true } );\n    // ---\n}", "\n/**\n * @imports\n */\nimport init from './index.js';\n\n/**\n * @init\n */\ninit.call( window );\n"],
  "mappings": "kPAIO,eAA2B,EAAa,CAC3C,GAAI,GAAW,EAAS,CAAE,iBAAe,kBAAgB,eAAa,EACtE,KAAO,EAAY,EAAW,MAAM,GAAI,CACpC,GAAM,CACF,cAAe,EAAiB,CAAC,EACjC,eAAgB,CAAE,iBAAkB,EAAoB,CAAC,EAAG,uBAAwB,EAA0B,CAAC,KAAM,GAAoB,CAAC,EAC1I,aAAc,EAAgB,CAAC,GAC/B,EACJ,EAAS,CACL,cAAe,CAAE,GAAG,EAAO,cAAe,GAAG,CAAe,EAC5D,eAAgB,CAAE,GAAG,EAAO,eAAgB,iBAAkB,CAAE,GAAG,EAAO,eAAe,iBAAkB,GAAG,CAAkB,EAAG,uBAAwB,CAAE,GAAG,EAAO,eAAe,uBAAwB,GAAG,CAAwB,EAAG,GAAG,CAAgB,EAC/P,aAAc,CAAE,GAAG,EAAO,aAAc,GAAG,CAAc,CAC7D,EACK,EAAW,OACpB,CACA,MAAO,EACX,CACO,GAAM,IAAe,CACxB,YAAa,SACb,2BAA4B,GAC5B,0BAA2B,GAC3B,wBAAyB,GACzB,eAAgB,GAChB,UAAW,EACf,EACa,GAAiB,CAC1B,iBAAkB,CAAE,YAAa,UAAY,EAC7C,uBAAwB,CAAC,EACzB,eAAgB,GAChB,UAAW,GACX,QAAS,CACb,EACa,GAAgB,CACzB,WAAY,CAChB,ECtCA,yaCQe,WAAS,EAAK,CAC5B,MAAO,CAAC,MAAM,QAAQ,CAAG,GAAK,MAAO,IAAQ,UAAY,CAC1D,CCFe,YAAS,EAAK,CAC5B,MAAO,OAAO,EACf,CCFe,WAAS,EAAK,CAC5B,MAAO,OAAM,QAAQ,CAAG,CACzB,CCMe,YAAS,EAAK,EAAM,EAAW,KAAM,CACnD,MAAO,AAAC,GAAS,CAAI,EAAS,EAAI,OAAO,GAAQ,EAC9C,EAAK,OAAO,GAAQ,EAAS,EAAM,CAAI,CAAC,EAAE,OAC1C,EAAK,QAAQ,CAAI,IAAM,EAC1B,EAHyB,CAAC,CAI3B,CCRe,YAAmB,KAAQ,EAAY,CAKlD,GAJK,WAAW,QAAU,YAAW,OAAS,CAAC,GAC1C,WAAW,OAAO,MACnB,OAAO,eAAe,WAAW,OAAQ,OAAQ,CAAC,MAAO,GAAI,GAAa,CAAC,EAE3E,CAAC,UAAU,OAAQ,MAAO,YAAW,OAAO,KAChD,GAAI,GAAQ,WAAW,OAAO,KAAK,IAAI,CAAG,EAC1C,AAAK,GACD,GAAQ,GAAI,IACZ,WAAW,OAAO,KAAK,IAAI,EAAK,CAAK,GAEzC,GAAI,GAAK,EACT,KAAQ,EAAM,EAAW,MAAM,GAC3B,AAAK,GAAS,IAAU,CAAE,GAAQ,EAAM,IAAI,CAAG,IAC3C,GAAQ,GAAI,IACZ,EAAO,IAAI,EAAK,CAAK,GAG7B,MAAO,EACX,CAEA,GAAM,IAAN,aAA4B,IAAI,CAC5B,eAAgB,EAAO,CACnB,MAAO,GAAG,CAAK,EACf,KAAK,UAAY,GAAI,IACzB,CACA,IAAK,EAAK,EAAQ,CACd,GAAI,GAAc,MAAM,IAAK,EAAK,CAAM,EACxC,YAAK,KAAM,MAAO,EAAK,EAAO,CAAI,EAC3B,CACX,CACA,OAAQ,EAAM,CACV,GAAI,GAAc,MAAM,OAAQ,CAAI,EACpC,YAAK,KAAM,SAAU,CAAI,EAClB,CACX,CACA,IAAK,EAAM,CACP,YAAK,KAAM,MAAO,CAAI,EACf,MAAM,IAAK,CAAI,CAC1B,CACA,IAAK,EAAM,CACP,YAAK,KAAM,MAAO,CAAI,EACf,MAAM,IAAK,CAAI,CAC1B,CACA,UAAW,CAAE,MAAO,OAAM,KAAM,MAAM,KAAK,CAAE,CAAG,CAChD,QAAS,EAAM,EAAK,EAAW,CAC3B,GAAM,GAAQ,CAAE,OAAM,MAAK,UAAS,EACpC,YAAK,UAAU,IAAK,CAAM,EACnB,IAAM,KAAK,UAAU,OAAQ,CAAM,CAC9C,CACA,UAAW,EAAM,EAAK,EAAW,CAC7B,GAAK,MAAM,QAAS,CAAK,GAAK,MAAM,QAAS,CAAI,EAC7C,KAAM,IAAI,OAAO,qDAAsD,EAE3E,OAAU,KAAS,MAAK,UACpB,AAAK,CAAG,IAAe,CAAE,EAAM,GAAI,EAAG,EAAM,IAAK,GAAK,GAAe,CAAE,EAAK,GAAI,EAAG,EAAM,GAAI,GAAK,EAAM,WAAa,IACrH,KAAK,UAAU,OAAQ,CAAM,CAErC,CACA,KAAM,EAAM,KAAQ,EAAO,CAGvB,OAAU,KAAS,MAAK,UACpB,AAAK,CAAG,IAAe,CAAE,EAAM,GAAI,EAAG,EAAM,IAAK,GAAK,GAAe,CAAE,EAAK,GAAI,EAAG,EAAM,GAAI,IAC7F,EAAM,SAAU,GAAG,CAAK,CAEhC,CACJ,EAEM,GAAgB,CAAE,EAAG,IAClB,MAAM,QAAS,CAAE,EAAW,GAAY,EAAG,CAAE,EAAE,OAC7C,EAAE,SAAU,CAAE,EC3EV,YAAS,EAAK,CAC5B,MAAO,OAAO,IAAQ,UACvB,CCHe,YAAS,EAAK,CAC5B,MAAO,KAAQ,MAAQ,IAAQ,EAChC,CCFe,YAAS,EAAK,CAC5B,MAAO,WAAU,QAAW,KAAQ,QAAa,MAAO,GAAQ,IACjE,CCIe,WAAS,EAAK,CAC5B,MAAO,OAAM,QAAQ,CAAG,GAAM,MAAO,IAAQ,UAAY,GAAQ,GAAgB,CAAG,CACrF,CCCe,YAAS,EAAK,CAC5B,MAAO,IAAQ,CAAG,GAAK,GAAa,CAAG,GAAK,IAAQ,IAAS,IAAQ,GAChE,EAAc,CAAG,GAAK,CAAC,OAAO,KAAK,CAAG,EAAE,MAC9C,CCPe,WAAS,EAAK,CAC5B,MAAO,IAAgB,CAAG,GAAM,GAAO,CAAC,EAAE,SAAS,KAAK,CAAG,IAAM,mBAClE,CCPe,YAAS,EAAK,CAC5B,MAAO,aAAe,SAAW,MAAO,IAAQ,UAAY,IAAQ,IACrE,CCKe,YAAS,EAAK,CAC5B,MAAO,CAAC,GAAU,CAAG,GAAK,CAAC,GAAa,EAAI,MAAM,CACnD,CCAe,YAAS,EAAK,EAAa,GAAM,CAC/C,MAAI,GAAS,CAAG,EACR,EAEJ,CAAC,GAAc,EAAU,CAAG,EACxB,CAAC,CAAG,EAER,IAAQ,IAAS,IAAQ,GAAK,GAAS,CAAG,EACtC,CAAC,EAEL,GAAa,CAAG,EACZ,MAAM,UAAU,MAAM,KAAK,CAAG,EAElC,EAAU,CAAG,EACT,OAAO,OAAO,CAAG,EAElB,CAAC,CAAG,CACZ,CC5BO,GAAM,GAAI,IAAK,IAAU,GAAY,eAAgB,GAAG,CAAK,EAEvD,GAAS,CAAE,EAAO,IAAc,YAAiB,SAAU,EAAM,KAAM,CAAS,EAAI,EAAU,CAAM,EAEpG,GAAQ,CAAC,ECHtB,GAAqB,IAArB,KAAkC,CAUjC,YAAa,EAAU,EAAM,CAC5B,KAAK,SAAW,EAChB,OAAO,OAAQ,KAAM,CAAE,GAAG,EAAK,OAAQ,EAAS,MAAO,CAAE,EACpD,KAAK,OAAO,QAChB,KAAK,OAAO,OAAO,iBAAkB,QAAS,IAAM,KAAK,OAAO,CAAE,CAEpE,CAOA,QAAS,CACR,YAAK,QAAU,GACR,KAAK,SAAS,mBAAoB,IAAK,CAC/C,CACD,ECpBA,GAAqB,IAArB,aAAkD,GAAa,CAK9D,aAAc,CACb,MAAO,GAAG,SAAU,EACpB,KAAK,KAAK,oBAAsB,KAChC,OAAO,eAAgB,KAAM,kBAAmB,CAAE,MAAO,GAAI,gBAAgB,CAAE,EAC/E,OAAO,eAAgB,KAAM,SAAU,CAAE,MAAO,KAAK,gBAAgB,MAAO,CAAE,EAC9E,GAAU,kBAAmB,EAAG,KAAK,MAAO,CAC7C,CAOA,QAAS,CACR,KAAK,gBAAgB,MAAM,EAC3B,MAAM,OAAO,CACd,CAUA,KAAM,EAAS,CACd,GAAK,KAAK,KAAK,iBAAmB,CAAC,CAAE,SAAU,cAAe,YAAa,EAAE,SAAU,KAAK,OAAO,UAAW,EAAI,OAClH,GAAI,GAAU,EAAQ,EAAS,KAAK,OAOpC,GANK,IAAW,KAAc,GAAS,GAAU,EAAQ,EAAM,IAC9D,GAAU,EAAO,OAAQ,GAAS,EAAO,SAAU,EAAM,GAAI,CAAE,GAE3D,KAAK,OAAO,MAChB,GAAU,EAAQ,OAAQ,GAAS,EAAM,OAAS,OAAS,EAAM,QAAU,EAAM,QAAS,GAEtF,EAAQ,OAAS,CACrB,GAAK,KAAK,KAAK,iBAAmB,KAAK,OAAO,aAAe,aAAe,CAC3E,KAAK,KAAK,gBAAgB,KAAM,GAAG,CAAQ,EAC3C,MACD,CACA,KAAK,KAAK,gBAAkB,KAAK,OAAO,aAAe,SAAW,EAAU,CAAC,EAC7E,GAAM,GAAO,KAAK,SAAW,KAAY,MAAM,QAAS,KAAK,MAAO,EACjE,KAAK,KAAM,EAAS,IAAK,EACzB,KAAK,KAAM,EAAS,GAAK,IAAK,EAEjC,MAAO,IAAQ,EAAM,GAAO,CAC3B,GAAM,GAAa,KAAK,KAAK,gBAE7B,MADA,OAAO,MAAK,KAAK,gBACZ,KAAK,OAAO,aAAe,eAC1B,EAAW,OAAgB,KAAK,KAAK,oBAAoB,KAAM,CAAW,EAEzE,CACR,CAAE,CACH,CACD,CACD,EC5DA,GAAqB,IAArB,KAA8B,CAS7B,YAAa,EAAS,CACrB,KAAK,OAAS,EACd,KAAK,QAAU,CAAC,CACjB,CAUA,gBAAiB,EAAe,CAC/B,YAAK,QAAQ,KAAM,CAAa,EACzB,CACR,CASA,mBAAoB,EAAe,CAClC,KAAK,QAAU,KAAK,QAAQ,OAAQ,GAAU,IAAW,CAAa,CACvE,CAYA,MAAO,cAAc,EAAM,EAAQ,EAAoB,GAAM,EAAY,KAAK,YAAc,CAC3F,GAAK,CAAC,EAAe,CAAO,EAAI,KAAM,IAAI,OAAO,oCAAqC,GAAU,CAAO,WAAa,EACpH,GAAI,GAAsB,KAC1B,MAAK,IAAa,EAAG,YAAa,EAAE,IAAK,EAAO,IAAM,CAAU,GAC/D,GAAsB,EAAG,YAAa,EAAE,IAAK,EAAO,IAAM,CAAU,EACpE,GAAQ,IAAM,GAEV,CAAC,EAAG,EAAQ,UAAW,EAAE,IAAK,CAAK,GAAK,GAC5C,EAAG,EAAQ,UAAW,EAAE,IAAK,EAAM,GAAI,GAAqB,CAAO,CAAE,EAE/D,EAAG,EAAQ,UAAW,EAAE,IAAK,CAAK,CAC1C,CAUA,MAAO,YAAY,EAAM,EAAW,EAAsB,KAAO,CAEhE,GADA,GAAQ,IAAM,EACT,UAAU,SAAW,EAAI,MAAO,GAAG,YAAa,EAAE,IAAK,CAAK,EACjE,GAAK,CAAG,GAAoB,oBAAqB,OAChD,KAAM,IAAI,OAAO,uCAAwC,KAAK,QAAU,2BAAqC,KAAK,OAAS,EAE5H,EAAG,YAAa,EAAE,IAAK,EAAM,CAAoB,EACjD,EAAoB,YAAc,CACnC,CACD,ECrFA,GAAqB,GAArB,KAAgC,CAU/B,YAAa,EAAQ,EAAM,CAE1B,GADA,KAAK,OAAS,EACT,CAAG,EAAI,UAAc,KAAM,IAAI,OAAO,mDAAoD,EAC/F,OAAO,OAAQ,KAAM,CAAI,CAC1B,CACD,ECPA,GAAqB,IAArB,aAA8C,GAAS,CAEtD,MAAO,aAAa,EAAQ,EAAoB,GAAM,EAAY,KAAO,CACxE,MAAO,OAAM,aAAc,YAAa,GAAG,SAAU,CACtD,CAEA,MAAO,WAAW,EAAW,EAAsB,KAAO,CACzD,MAAO,OAAM,WAAY,YAAa,GAAG,SAAU,CACpD,CAKA,YAAa,EAAS,CACrB,MAAO,CAAO,EACd,KAAK,QAAU,CAAC,CACjB,CAKA,gBAAiB,EAAQ,EAAM,EAAS,CACvC,MAAO,OAAM,gBAAiB,GAAI,IAAsB,KAAM,CAAE,SAAQ,OAAM,QAAO,CAAE,CAAE,CAC1F,CASA,KAAM,EAAQ,EAAwB,GAAQ,CAC7C,GAAK,KAAK,QAAQ,OAAS,CAC1B,KAAK,QAAS,GAAI,UAAU,KAAM,CAAE,OAAQ,CAAE,GAAG,CAAO,EAAG,uBAAsB,CAAE,EACnF,MACD,CACA,KAAK,MAAO,KAAK,QAAS,CAAE,CAAE,SAAQ,uBAAsB,CAAE,CAAE,CACjE,CAEA,MAAO,EAAS,EAAY,CAC3B,GAAM,GAA6B,EAAQ,OAAQ,GAAY,EAAS,OAAO,uBAAwB,EAAE,OACnG,EAAuB,EAAU,KAAM,GAAY,EAAS,qBAAsB,EAClF,EAAa,CAAC,EAAG,EAAoB,CAAC,EAAG,EAAgB,EAAQ,OACvE,EAAU,QAAS,GAAY,CAE9B,AAAK,IAA8B,CAAC,IAAyB,EAAW,KAAM,GAAG,EAAS,MAAO,EAE5F,IAA+B,GAAiB,GACpD,CAAK,EAAS,sBACb,EAAkB,KAAM,GAAG,EAAS,OAAO,IAAK,GAAK,CACpD,GAAI,CAAE,SAAQ,UAAS,GAAY,EAC7B,EAAO,GAAI,GAAY,EAAQ,CAAE,KAAM,MAAO,GAAG,CAAQ,CAAE,EACjE,cAAO,eAAgB,EAAM,QAAS,OAAS,GAAQ,MAAQ,CAAE,IAAK,IAAM,EAAQ,MAAM,IAAI,CAAE,EAAI,CAAE,MAAO,EAAQ,MAAM,KAAM,CAAE,EAC9H,EAAQ,UACZ,OAAO,eAAgB,EAAM,WAAY,OAAS,GAAQ,SAAW,CAAE,IAAK,IAAM,EAAQ,SAAS,IAAI,CAAE,EAAI,CAAE,MAAO,EAAQ,SAAS,KAAM,CAAE,EAEzI,CACR,CAAE,CAAE,EACI,EAAkB,KAAM,GAAG,EAAS,MAAO,EAEtD,CAAE,EACF,EAAQ,QAAS,GAAY,CAC5B,AAAK,EAAS,OAAO,wBACpB,EAAS,KAAM,EAAW,OAAS,EAAa,CAAkB,EAC1D,EAAS,KAAM,EAAkB,OAAS,EAAoB,CAAW,CACnF,CAAE,CACH,CASA,MAAO,EAAW,CACjB,KAAK,QAAQ,QAAS,CAAE,QAAS,CAAE,GAAG,KAAK,OAAQ,EAAG,UAAW,CAAC,CAAE,CAAE,EACtE,GAAM,GAAc,EAAS,EAC7B,MAAO,IAAQ,EAAa,GAAe,CAC1C,GAAM,GAAQ,KAAK,QAAQ,MAAM,EACjC,MAAM,GAAM,UAAU,QACtB,KAAK,MAAO,EAAM,QAAS,EAAM,SAAU,EACpC,CACR,CAAE,CACH,CAED,EC1FA,GAAqB,IAArB,aAA+C,GAAa,CAY3D,KAAM,EAAY,EAAM,EAAW,CAClC,MAAK,MAAK,SAAW,CAAC,KAAK,MAAO,EAAW,WACrC,EAAM,GAAG,MAAM,UAAU,MAAM,KAAM,UAAW,CAAE,CAAE,EAE5D,MAAK,QAAU,GACR,KAAK,MAAO,EAAW,WAAa,EAAY,EAAU,IAAK,IACrE,MAAK,QAAU,GACR,EAAM,GAAG,CAAK,EACpB,EACH,CACD,ECrBA,GAAqB,GAArB,aAA2C,GAAS,CAEnD,MAAO,aAAa,EAAQ,EAAoB,GAAM,EAAY,KAAO,CACxE,MAAO,OAAM,aAAc,QAAS,GAAG,SAAU,CAClD,CAEA,MAAO,WAAW,EAAW,EAAsB,KAAO,CACzD,MAAO,OAAM,WAAY,QAAS,GAAG,SAAU,CAChD,CAKA,gBAAiB,EAAM,CACtB,MAAO,OAAM,gBAAiB,GAAI,IAAmB,KAAM,CAAI,CAAE,CAClE,CAUA,KAAM,EAAY,EAAiB,KAAO,CACzC,GAAM,GAAQ,KACd,MAAS,YAAe,KAAU,EAAQ,CACzC,GAAM,GAAe,EAAM,QAAS,GACpC,MAAK,GACG,EAAa,KAAM,EAAY,IAAK,IACnC,EAAM,EAAQ,EAAG,GAAG,CAAK,EACtB,GAAG,CAAM,EAEd,EAAiB,EAAgB,EAAY,GAAG,CAAM,EAAI,EAAO,EACzE,EAAK,CAAE,CACR,CACD,EClDA,uFAqBO,YAAsB,EAAQ,EAAO,EAAS,CAAC,EAAI,CACtD,EAAS,GAAe,CAAO,EAC/B,GAAM,GAAoB,EAAG,EAAQ,mBAAoB,EAEzD,WAA4B,EAAO,CAC/B,GAAI,GAAY,EAAQ,EACxB,EACI,GAAa,OAAO,yBAA0B,EAAO,CAAK,QACpD,CAAC,GAAgB,GAAQ,OAAO,eAAgB,CAAM,IAChE,MAAO,GACD,CAAE,QAAO,YAAW,EACpB,CAAE,WAAY,CAAE,MAAO,OAAW,aAAc,GAAM,WAAY,GAAM,SAAU,EAAK,CAAE,CACnG,CAEA,WAA0B,EAAO,CAC7B,GAAK,EAAkB,IAAK,EAAO,EAAG,EAAI,MAAO,GAGjD,GAAM,GAA0B,EAAmB,CAAK,EACxD,EAAwB,SAAW,SAAU,EAA0B,GAAQ,CAC3E,MAAK,GAAiC,KAAK,WACpC,KAAK,WAAW,IAAM,KAAK,WAAW,IAAI,EAAI,KAAK,WAAW,KACzE,EACA,EAAwB,SAAW,SAAU,EAAO,EAA0B,GAAQ,CAElF,GADA,KAAK,MAAQ,GACR,EAA0B,CAAE,KAAK,WAAa,EAAO,MAAQ,CAClE,MAAO,MAAK,WAAW,IAAM,KAAK,WAAW,IAAK,CAAM,IAAM,GAAU,MAAK,WAAW,MAAQ,EAAO,GAC3G,EACA,EAAwB,OAAS,UAAW,CACxC,GAAM,GAAoB,OAAO,yBAA0B,EAAQ,CAAK,EACxE,MAAO,IAAmB,MAAQ,EAAgB,KAC3C,GAAmB,MAAQ,EAAgB,KAC3C,EAAkB,IAAK,EAAO,EAAG,IAAM,IAClD,EACA,EAAwB,QAAU,UAAW,CACzC,MAAM,MAAK,OAAO,EAClB,CAAO,KAAK,OAAS,KAAK,QAAU,GAAc,CAAC,KAAK,OAAS,CAAC,KAAK,MAAY,MAAO,GAAQ,GAC3F,OAAO,eAAgB,EAAQ,EAAM,KAAK,UAAW,EAC5D,EAAkB,OAAQ,EAAO,EAAG,EAC7B,IAJsB,EAKjC,EACA,EAAkB,IAAK,AAAC,MAAO,CAAK,EAAuB,EAAnB,SAAU,CAAK,EAAU,CAAwB,EAGzF,GAAM,CAAE,aAAa,IAAS,EAAwB,WAChD,EAAkB,CAAE,aAAY,aAAc,EAAK,EAEzD,AAAO,UAAW,GAAwB,YAAgB,EAAwB,WAAW,MACzF,GAAgB,IAAM,SAAW,EAAQ,CAAE,MAAO,IAAK,KAAM,EAAM,EAAO,CAAO,CAAG,GAEjF,UAAW,GAAwB,YAAgB,EAAwB,WAAW,MACzF,GAAgB,IAAM,UAAY,CAAE,MAAO,GAAK,KAAM,EAAM,CAAO,CAAG,GAE1E,GAAI,CACA,cAAO,eAAgB,EAAQ,EAAM,CAAgB,EAC9C,EACX,MAAE,CACE,SAAkB,OAAQ,EAAO,EAAG,EAC7B,EACX,CACJ,CAIA,GAAM,GAAW,AAHF,OAAM,QAAS,CAAM,EAAI,EACpC,IAAU,OAAY,OAAO,KAAM,CAAO,EAAI,CAAE,CAAM,GAElC,IAAK,CAAgB,EAC7C,MAAO,KAAU,QAAa,MAAM,QAAS,CAAM,EAC7C,EACA,EAAU,EACpB,CAWO,YAAwB,EAAQ,EAAO,EAAS,CAAC,EAAI,CACxD,EAAS,GAAe,CAAO,EAC/B,GAAM,GAAoB,EAAG,EAAQ,mBAAoB,EACzD,WAA4B,EAAO,CAC/B,MAAM,GAAkB,IAAK,EAAO,EAAG,EAChC,EAAkB,IAAK,EAAO,EAAG,EAAE,QAAQ,EADA,EAEtD,CAIA,GAAM,GAAW,AAHF,OAAM,QAAS,CAAM,EAAI,EACpC,IAAU,OAAY,OAAO,KAAM,CAAO,EAAI,CAAE,CAAM,GAElC,IAAK,CAAkB,EAC/C,MAAO,KAAU,QAAa,MAAM,QAAS,CAAM,EAC7C,EACA,EAAU,EACpB,CAcO,YAAgB,EAAQ,EAAS,CAAC,EAAG,EAAiB,OAAY,CAErE,GAAM,GAAiB,GAAe,CAAO,EAE7C,GAAK,MAAO,GAAO,UAAa,UAAY,KAAM,IAAI,OAAO,0DAA2D,EACxH,GAAK,EAAO,UAAY,EAAG,EAAgB,aAAc,EAAE,IAAK,EAAO,QAAS,EAAM,MAAO,GAAG,EAAgB,aAAc,EAAE,IAAK,EAAO,QAAS,EACrJ,GAAM,GAAQ,CACV,MAAO,EAAQ,EAAc,EAAgB,CACzC,GAAK,MAAM,QAAS,CAAa,EAAI,CAEjC,GAAM,GAAe,GAAe,CAAa,EACjD,SAAG,CAAa,EAAE,IAAK,UAAW,EAAa,MAAO,EAE/C,GAAO,EAAc,IAAO,GAAO,EAAQ,EAAc,CAAc,CAAE,CACpF,CACA,MAAO,IAAO,EAAQ,GAAS,CAAa,EAAG,CAAc,CACjE,EACA,UAAY,CAAE,EAAQ,EAAe,EAAY,OAAU,GAAW,EAAQ,EAAe,EAAW,CAAO,EAC/G,eAAiB,CAAE,EAAQ,EAAa,IAAgB,GAAgB,EAAQ,EAAa,EAAY,CAAO,EAChH,eAAgB,CAAE,EAAQ,IAAiB,GAAgB,EAAQ,EAAa,CAAO,EACvF,IAAK,CAAE,EAAQ,EAAa,EAAW,OAAU,CAC7C,GAAM,GAAU,CAAE,GAAG,EAAQ,UAAS,EACtC,AAAK,MAAM,QAAS,CAAO,GAAK,IAAgB,UAAY,EAAG,CAAO,EAAE,IAAK,SAAU,GACnF,GAAQ,WAAa,EAAG,CAAO,EAAE,IAAK,SAAU,GAEpD,GAAM,GAAc,EAAK,EAAQ,EAAa,CAAQ,EACtD,MAAK,OAAM,QAAS,CAAO,GAAK,MAAO,IAAgB,WAE5C,GAAO,EAAa,CAAE,GAAG,EAAQ,SAAU,CAAmG,CAAE,EAEpJ,CACX,EACA,yBAA0B,CAAE,EAAQ,IAAiB,GAA0B,EAAQ,EAAa,CAAO,EAC3G,eAAgB,GAAU,GAAgB,EAAQ,CAAO,EACzD,IAAK,CAAE,EAAQ,IAAiB,GAAK,EAAQ,EAAa,CAAO,EACjE,aAAc,GAAU,GAAc,EAAQ,CAAO,EACrD,QAAS,GAAU,GAAS,EAAQ,CAAO,EAC3C,kBAAmB,GAAU,GAAmB,EAAQ,CAAO,EAC/D,IAAK,CAAE,EAAQ,EAAa,EAAO,EAAW,OAAU,CACpD,GAAM,GAAU,CAAE,GAAG,EAAQ,UAAS,EACtC,MAAK,OAAM,QAAS,CAAO,GAAK,IAAgB,UAC5C,GAAQ,cAAgB,EAAG,CAAO,EAAE,IAAK,SAAU,EACnD,EAAG,CAAO,EAAE,IAAK,UAAW,CAAM,GAE/B,GAAK,EAAQ,EAAa,EAAO,CAAQ,CACpD,EACA,eAAgB,CAAE,EAAQ,IAAe,GAAgB,EAAQ,EAAW,CAAO,CACvF,EAEM,EAAS,IAAkB,CAAM,GAAK,EAEtC,EAAS,GAAI,OAAO,EAAgB,CAAO,EACjD,MAAK,GAAO,UAAa,EAAG,EAAgB,aAAc,EAAE,IAAK,EAAO,SAAU,CAAO,EACzF,EAAG,CAAO,EAAE,IAAK,EAAQ,CAAe,EACpC,CACR,CASO,YAAkB,EAAS,CAE9B,MAAO,GAAG,CAAO,EAAE,IAAK,CAAO,GAAK,CACxC,CAWA,YAAwB,EAAS,CAChC,GAAK,CAAC,GAAU,CAAC,EAAe,CAAO,EAAI,KAAM,IAAI,OAAM,gCAAgC,EAC3F,MAAO,IAAS,CAAO,CACxB,CvB5LA,GAAM,IAAN,aAAmB,MAAM,CAAC,EACnB,eAAkB,EAAW,CAChC,MAAO,IAAI,IAAM,GAAG,CAAS,CACjC,CAeO,YAAiB,EAAQ,EAAM,EAAU,EAAQ,GAAK,EAAG,EAAS,CAAC,EAAI,CAC1E,GAAK,EAAC,EAAK,OACX,MAAS,YAAc,EAAQ,EAAM,EAAU,CAC3C,GAAM,GAAU,EAAM,EAAQ,OACxB,EAAgB,EAAQ,QAAU,EAAK,OAAS,EACtD,MAAK,aAAkB,IAAc,EAAO,YAAc,MAEtD,EAAU,CAAE,GAAG,EAAS,MAAO,QAAS,EAChC,EAAQ,QAAU,UAE1B,GAAU,CAAE,GAAG,EAAS,MAAO,CAAC,CAAc,GAG3C,EAAU,EAAQ,EAAS,CAAE,KAAW,IAAU,CAErD,GAAM,GAAW,GAAQ,CACrB,AAAQ,YAAgB,IACxB,GAAK,KAAO,CAAE,EAAK,GAAI,EAClB,YAAkB,IACnB,GAAK,KAAO,EAAO,KAAK,OAAQ,EAAK,GAAI,EACzC,OAAO,eAAgB,EAAM,UAAW,CAAE,IAAK,IAAM,EAAQ,aAAc,EAAK,CAAE,GAE1F,EACM,EAAU,GAAU,CACtB,GAAM,GAAS,EAAY,EAAuD,EAAM,EACxF,MAAO,IAAQ,EAAgC,GAAU,CACrD,AAAK,YAAkB,GACnB,EAAO,MAAQ,EAEf,EAAS,EAEb,GAAM,GAAQ,EAAM,IAAO,CAAC,EAC5B,MAAO,GAAK,EAAQ,EAAM,CAAE,GAAG,EAAS,GAAG,EAAO,MAAO,EAAQ,MAAQ,CAAG,CAAE,CAClF,CAAE,CACN,EAEA,MAAK,IAAa,CAAQ,GAAK,MAAM,QAAS,CAAO,EACjD,GAAO,QAAS,CAAS,EACpB,EAAuB,EAAO,EAAQ,GAAG,CAAK,EAC5C,EAAO,IAAK,CAAQ,GAG/B,GAAU,CAAO,EACZ,EAAuB,EAAO,EAAQ,GAAG,CAAK,EAC5C,EAAS,CAAO,EAE3B,EAAG,CAAQ,CACf,EAAK,EAAQ,EAAK,MAAO,CAAE,EAAG,CAAE,GAAG,EAAQ,MAAO,CAAE,CAAE,CAC1D,CAYO,YAAkB,EAAQ,EAAM,EAAU,EAAS,CAAC,EAAI,CAO9D,GALG,EAAS,EAAY,EAAQ,CAAC,EAAO,KAAM,EACzC,EAAa,UAAW,EAAI,GAC1B,EAAE,CAAE,EAAU,EAAS,CAAC,CAAE,EAAI,UAC9B,EAAO,KAET,CAAC,EAAa,CAAS,EAAI,KAAM,IAAI,OAAO,gCAAiC,GAAU,CAAS,WAAa,EAC/G,GAAK,YAAgB,IAAO,MAAO,IAAQ,EAAQ,EAAM,GAAS,EAAU,CAAO,EAInF,GAFA,EAAS,CAAE,GAAG,EAAQ,WAAY,EAAK,EACvC,MAAO,GAAO,KACT,CAAC,EAAe,CAAO,EAAI,MAAO,GAAO,OAAS,EAAK,EAAQ,EAAM,EAAU,CAAO,EAE3F,GAAM,GAAO,GAAM,EAAQ,EAAM,EAAU,CAAO,EAClD,MAAK,GAAO,MACD,EAAK,EAAQ,EAAM,EAAM,CAAO,EAEpC,EAAK,CAChB,CAWO,YAAoB,EAAQ,EAAO,EAAS,CAAC,EAAI,CAEpD,SAAS,EAAY,CAAO,EACtB,EAAW,CAAM,GACnB,EAAY,CAAe,CAAa,CAAE,EAAS,CAAC,CAAE,EAAI,UAC1D,EAAQ,CAAE,CAAE,UAAW,IAAO,UAAW,EAAI,GAG1C,EAAc,YAAa,EAAQ,GAAM,EAAO,SAAU,EAAE,gBAAiB,CAAE,QAAO,QAAO,CAAE,CAC1G,CAcO,YAAmC,EAAQ,EAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACrF,MAAO,GAAM,EAAQ,2BAA4B,CAAE,IAAK,CAAK,EAAG,EAAU,CAAO,CACrF,CAaO,YAAoC,EAAQ,EAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACtF,MAAO,GAAM,EAAQ,4BAA6B,CAAE,IAAK,CAAK,EAAG,EAAU,CAAO,CACtF,CAWO,YAAyB,EAAQ,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACrE,MAAO,GAAM,EAAQ,iBAAkB,CAAC,EAAG,EAAU,CAAO,CAChE,CAWO,YAAuB,EAAQ,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACnE,MAAO,GAAM,EAAQ,eAAgB,CAAC,EAAG,EAAU,CAAO,CAC9D,CAWO,YAAkB,EAAQ,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAC9D,MAAO,GAAM,EAAQ,UAAW,CAAC,EAAG,EAAU,CAAO,CACzD,CAYO,YAAc,EAAQ,EAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAChE,MAAO,GAAM,EAAQ,MAAO,CAAE,IAAK,CAAK,EAAG,EAAU,CAAO,CAChE,CAYO,WAAc,EAAQ,EAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAEhE,GAAI,GACE,EAAiB,EAAY,EAAQ,CAAC,EAAO,KAAM,EAGzD,MAFA,AAAK,GAAW,CAAS,EAAM,CAAE,EAAQ,CAAS,EAAI,CAAE,EAAU,GAAK,CAAE,EAC/D,EAAO,MAAS,GAAS,IAC9B,YAAgB,IAAc,GAAQ,EAAgB,EAAM,EAAK,EAAU,CAAO,EAEhF,GAAc,EAAgB,EAAM,GAAS,CAChD,GAAM,GAAU,CAAE,GAAG,CAAM,EAC3B,MAAS,YAAe,EAAS,EAAQ,EAAQ,CAC7C,GAAK,CAAC,EAAO,OAAS,MAAO,GAAO,CAAQ,EAC5C,GAAM,GAAO,EAAO,MAAM,EAC1B,GAAK,CAAC,CAAE,SAAU,SAAU,QAAS,EAAE,SAAU,MAAO,EAAK,EACzD,KAAM,IAAI,OAAO,qBAAsB,YAAiB,EAG5D,WAAqB,EAAY,EAAQ,OAAY,CACjD,GAAM,GAAQ,GAAW,GAAW,MAAQ,EAAO,EAAM,CAAE,GAAG,EAAS,EAAO,MAAQ,EAAO,WAAa,EAAa,CAAM,EAAqD,EAAQ,CAAM,GAChM,GAAK,UAAU,OAAS,EAAI,MAAO,GAAO,CAAM,EAChD,GAAK,CAAC,EAAe,CAAe,EAAI,MAAO,GAAO,IAAkB,EAAW,IAAM,EACzF,GAAM,GAAoB,EAAG,EAAgB,oBAAqB,EAAM,EAClE,EAAkB,GAAqB,EAAkB,IAAK,EAAW,GAAI,EACnF,GAAK,GAAmB,EAAgB,OAAO,EAC3C,MAAO,GAAO,EAAgB,SAAU,EAAO,uBAAwB,CAAE,EAE7E,GAAK,EAAO,wBAA0B,CAClC,GAAM,GAAO,OAAO,yBAA0B,EAAgB,EAAW,GAAI,EAC7E,MAAK,cAAgB,IAAW,SAAW,IAAS,GAAK,MAAQ,EAAO,YACjE,EAAO,CAAK,CACvB,CACA,MAAK,cAAgB,GAAkB,EAAO,EAAO,UAAW,EACzD,EAAO,QAAQ,IAAK,EAAgB,EAAW,IAAK,GAAK,EAAO,SAAW,CAAE,EAAO,QAAS,EAAI,CAAC,CAAI,CAAE,CACnH,CAEA,GAAM,GAAa,GAAI,GAAY,EAAgB,CAC/C,KAAM,MACN,IAAK,EACL,MAAO,OACP,UAAW,MACX,SACJ,CAAE,EACF,GAAK,CAAC,EAAe,CAAe,EAAI,MAAO,GAAY,CAAW,EACtE,GAAM,GAAgB,EAAc,YAAa,EAAgB,GAAO,EAAO,SAAU,EACzF,MAAK,GACM,EAAc,KAAM,EAAY,CAAW,EAE/C,EAAY,CAAW,CAClC,EAAK,CAAC,EAAG,EAAM,MAAO,CAAE,EAAG,GAAW,CAClC,GAAM,GAAW,GAAa,CAAiB,EAAI,EAAU,EAAS,GACtE,MAAK,IAAU,EAAe,CAAe,EAElC,AADM,GAAM,EAAgB,EAAM,EAAU,CAAO,EAC7C,CAAS,EAEnB,EAAU,CAAS,CAC9B,CAAE,CACN,EAAG,CAAO,CACd,CAaO,YAAgB,EAAQ,EAAU,EAAS,CAAC,EAAI,CACnD,SAAS,EAAY,CAAO,EACrB,GAAiB,YAAa,EAAQ,GAAM,EAAO,SAAU,EAAE,MAAO,CAAS,CAC1F,CAWO,YAAe,EAAQ,EAAQ,EAAS,CAAC,EAAI,CAChD,EAAS,EAAY,CAAO,EAC5B,EAAS,EAAY,CAAO,EAC5B,GAAM,GAAS,GAAO,MAAQ,CAAC,GAAI,MAAO,CAAE,EAAG,EAAW,GAAO,QAAU,CAAC,GAAI,MAAO,CAAE,EACnF,EAAa,GAAS,EAAO,OAAS,CAAE,GAAG,CAAO,EAAI,CAAO,EAAE,IAAK,GAAK,AAAC,MAAO,CAAE,EAAoB,EAAhB,SAAU,CAAE,CAAM,EACzG,EAAe,EAAK,OAAS,EAAK,OAAQ,GAAK,EAAW,SAAU,CAAE,CAAE,EAAI,EAAW,OAAQ,GAAK,CAAC,EAAO,SAAU,CAAE,CAAE,EAC1H,EAAa,GACV,CAAC,MAAM,QAAS,CAAO,GAAK,MAAO,CAAE,EAAW,EAC9C,EAAI,EAAO,OAAQ,GAAK,EAAI,CAAE,EAAE,OAErC,EAAQ,GAAO,CACjB,GAAM,GAAa,GAA0B,EAAQ,EAAK,CAAO,EACjE,AAAO,SAAW,IAAgB,EAAW,UAAY,EAAW,YAAc,EAAW,aACzF,GAAK,EAAQ,EAAY,CAAI,EAAG,EAAW,MAAO,CAAO,EACjD,GAAW,YAAc,EAAO,iBAAmB,KAAU,GAAgB,EAAQ,EAAK,CAAE,GAAG,EAAY,aAAc,EAAK,EAAG,CAAO,CACxJ,EACA,UAAO,EAAQ,IAAM,CACjB,EAAa,QAAS,CAAM,CAChC,CAAE,EACK,GAAS,EAAQ,GAAa,CAE7B,EAAU,OAAQ,GAAK,EAAK,OAAS,EAAK,SAAU,EAAE,GAAI,EAAI,CAAC,EAAO,SAAU,EAAE,GAAI,CAAE,EAAE,QAAS,GAAK,CACpG,GAAK,EAAE,YAAc,iBAAmB,MAAO,IAAgB,EAAQ,EAAY,EAAE,GAAI,EAAG,CAAO,EACnG,GAAK,EAAE,YAAc,iBAAmB,CACpC,AAAK,GAAE,MAAM,YAAc,EAAO,iBAAmB,KACjD,GAAgB,EAAQ,EAAY,EAAE,GAAI,EAAG,CAAE,GAAG,EAAE,MAAO,aAAc,EAAK,EAAG,CAAO,EAE5F,MACJ,CACA,EAAO,EAAE,GAAI,CACjB,CAAE,CAEV,EAAG,CAAE,GAAG,EAAQ,wBAAyB,EAAK,CAAE,CACpD,CAcO,YAAc,EAAQ,EAAM,EAAO,EAAW,GAAK,EAAG,EAAS,CAAC,EAAG,EAAM,GAAQ,CAEpF,GAAM,GAAiB,EAAY,CAAO,EACtC,EAAU,CAAE,CAAE,EAAM,CAAM,CAAE,EAChC,AAAK,EAAW,CAAK,GACjB,EAAY,CAAU,CAAE,EAAW,GAAK,EAAG,EAAS,CAAC,EAAG,EAAM,EAAM,EAAI,UACxE,EAAU,OAAO,QAAS,CAAK,GAE9B,EAAW,CAAS,GAAM,EAAE,EAAK,EAAQ,CAAS,EAAI,CAAE,MAAO,IAAW,UAAY,EAAS,EAAK,EAAU,GAAK,CAAE,GAE1H,GAAM,GAAU,EAAQ,IAAK,CAAE,CAAE,KAAY,CAAK,EAClD,MAAS,YAAe,EAAa,EAAS,EAAQ,CAClD,GAAK,CAAC,EAAQ,OAAS,MAAO,GAAO,CAAY,EACjD,GAAM,CAAE,EAAM,GAAU,EAAQ,MAAM,EAEtC,WAAqB,EAAY,EAAS,OAAY,CAClD,GAAM,GAAQ,GAAY,GAAW,OAAS,EAAQ,EAAM,EAAY,OAAQ,CAAW,EAAG,EAAS,CAAM,GAC7G,GAAK,UAAU,OAAS,EAAI,MAAO,GAAO,EAAY,CAAO,EAC7D,GAAM,GAAoB,EAAG,EAAgB,oBAAqB,EAAM,EAClE,EAAkB,GAAqB,EAAkB,IAAK,EAAW,GAAI,EACnF,MAAK,GAAW,YAAc,iBACrB,IAAmB,CAAC,EAAgB,QAAQ,GAAI,EAAO,EAAM,EAClE,OAAO,eAAgB,EAAgB,EAAW,IAAK,EAAW,KAAM,EACjE,EAAO,EAAK,GAElB,GAAmB,EAAgB,OAAO,EACpC,EAAO,EAAgB,SAAU,EAAW,KAAM,CAAE,EAExD,EAAO,QAAQ,IAAK,EAAgB,EAAW,IAAK,EAAW,KAAM,CAAE,CAClF,CAEA,WAAe,EAAU,EAAW,CAChC,GAAK,EAAO,MAAQ,IAAU,EAAW,MAAO,GAAM,EAAa,EAAS,CAAM,EAClF,GAAM,GAAa,GAAI,GAAY,EAAgB,CAC/C,KAAM,EAAM,MAAQ,MACpB,IAAK,EACL,QACA,WACA,WACA,QAAS,CAAE,GAAG,CAAQ,EACtB,UAAW,EAAM,iBAAmB,MACpC,OAAQ,EAAO,MACnB,CAAE,EACI,EAAgB,EAAc,YAAa,EAAgB,GAAO,EAAO,SAAU,EACzF,MAAO,GACD,EAAc,KAAM,EAAY,CAAW,EAC3C,EAAY,CAAW,CACjC,CAEA,MAAO,IAAK,EAAgB,EAAM,GAAU,CACxC,GAAK,CAAC,EAAS,MAAO,GAAM,CAAO,EACnC,GAAM,GAAU,CAAE,GAAG,EAAQ,wBAAyB,CAAI,EAC1D,MAAK,iBAAmB,IAAW,GAAQ,WAAa,EAAO,eACxD,EAAK,EAAgB,EAAM,GAAY,EAAM,EAAQ,CAAS,EAAG,CAAQ,CACpF,EAAG,CAAO,CAEd,EAAK,CAAC,EAAG,EAAQ,MAAO,CAAE,EAAG,GAAe,CACxC,GAAM,GAAmB,GAAiB,YAAa,EAAgB,GAAO,EAAO,SAAU,EAC/F,MAAK,IAAmB,EAAiB,KAAM,EAAa,CAAI,EACzD,EACH,GAAa,CAAiB,EAAI,EAAY,IAAK,GAAO,EAAI,MAAO,EAAI,EAAa,IAAK,MAC/F,CACJ,CAAE,CACN,CAaO,YAAyB,EAAQ,EAAM,EAAY,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACvF,MAAO,IAAK,EAAQ,EAAM,EAAY,EAAU,EAAQ,EAAY,CACxE,CAaO,YAA2B,EAAQ,EAAa,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACpF,MAAO,IAAK,EAAQ,EAAa,EAAU,EAAQ,EAAY,CACnE,CAYO,YAAyB,EAAQ,EAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAE3E,EAAS,EAAY,CAAO,EACvB,EAAW,CAAS,GAAM,EAAE,EAAQ,CAAS,EAAI,CAAE,EAAU,GAAK,CAAE,GAEzE,GAAM,GAAQ,GAAU,EAAM,EAAM,EAAG,EAAU,CAAE,GAAG,CAAM,EAC5D,MAAS,YAAe,EAAa,EAAO,EAAQ,CAChD,GAAK,CAAC,EAAM,OAAS,MAAO,GAAO,CAAY,EAC/C,GAAM,GAAO,EAAM,MAAM,EAEzB,WAAqB,EAAY,EAAS,OAAY,CAClD,GAAM,GAAQ,GAAY,GAAW,OAAS,EAAQ,EAAM,EAAY,OAAQ,CAAW,EAAG,EAAO,CAAM,GAC3G,GAAK,UAAU,OAAS,EAAI,MAAO,GAAO,EAAY,CAAO,EAC7D,GAAM,GAAoB,EAAG,EAAQ,oBAAqB,EAAM,EAC1D,EAAkB,GAAqB,EAAkB,IAAK,EAAW,GAAI,EACnF,MAAK,IAAmB,CAAC,EAAgB,QAAQ,GAAI,EAAO,EAAM,EAC3D,EAAO,QAAQ,eAAgB,EAAQ,EAAW,GAAI,CAAE,CACnE,CAEA,WAAe,EAAW,CACtB,GAAM,GAAa,GAAI,GAAY,EAAQ,CACvC,KAAM,SACN,IAAK,EACL,WACA,QAAS,CAAE,GAAG,CAAQ,EACtB,UAAW,iBACX,OAAQ,EAAO,MACnB,CAAE,EACI,EAAmB,EAAc,YAAa,EAAQ,GAAO,EAAO,SAAU,EACpF,MAAO,GACD,EAAiB,KAAM,EAAY,CAAW,EAC9C,EAAY,CAAW,CACjC,CAEA,MAAO,GAAK,EAAQ,EAAM,EAAM,CAAO,CAE3C,EAAK,CAAC,EAAG,EAAM,MAAO,CAAE,EAAG,GAAe,CACtC,GAAM,GAAmB,GAAiB,YAAa,EAAQ,GAAO,EAAO,SAAU,EACvF,MAAK,IAAmB,EAAiB,KAAM,CAAY,EACpD,EACH,GAAa,CAAiB,EAAI,EAAY,IAAK,GAAO,EAAI,MAAO,EAAI,EAAa,GAAI,MAC9F,CACJ,CAAE,CACN,CAKO,YAA2B,EAAQ,EAAO,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAC9E,MAAO,IAAgB,GAAG,SAAU,CACxC,CAeO,YAAoB,EAAQ,EAAe,EAAY,KAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACjG,MAAO,GAAM,EAAQ,YAAa,UAAU,OAAS,EAAI,CAAE,gBAAe,WAAU,EAAI,CAAE,eAAc,EAAG,EAAU,CAAO,CAChI,CAaO,YAAgB,EAAQ,EAAc,EAAe,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACzF,MAAO,GAAM,EAAQ,QAAS,CAAE,eAAc,eAAc,EAAG,EAAU,CAAO,CACpF,CAYO,YAAyB,EAAQ,EAAO,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAC5E,MAAO,GAAM,EAAQ,iBAAkB,CAAE,OAAM,EAAG,EAAU,CAAO,CACvE,CAWO,YAA4B,EAAQ,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACxE,MAAO,GAAM,EAAQ,oBAAqB,CAAC,EAAG,EAAU,CAAO,CACnE,CAcA,YAAe,EAAQ,EAAM,EAAU,EAAS,CAAC,EAAI,CACjD,GAAI,GACJ,AAAM,EAAO,QACT,GAAa,GAAI,iBACjB,EAAS,CAAE,GAAG,EAAQ,OAAQ,EAAW,MAAO,EAChD,GAAU,kBAAmB,EAAG,EAAW,MAAO,GAEtD,GAAM,GAAmB,GAAiB,YAAa,EAAQ,GAAM,EAAO,SAAU,EACtF,MAAO,YAAe,EAAc,EAAmB,KAAO,CAC1D,GAAkB,OAAO,EAEzB,GAAM,GAAQ,CAAE,OAAQ,AADC,EAAiB,gBAAiB,EAAM,EAAM,CAAO,EACrC,MAAQ,EACjD,GAAK,UAAU,OAAS,CACpB,GAAM,GAAqB,EAAU,EAAc,CAAM,EACzD,GAAK,UAAU,OAAS,EAAI,MAAO,EACvC,CACA,MAAO,EACX,CACJ,CAaA,WAAe,EAAQ,EAAW,EAAU,CAAC,EAAG,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAE7E,EAAS,EAAY,CAAO,EACvB,EAAW,CAAS,GAAM,EAAE,EAAQ,CAAS,EAAI,CAAE,EAAU,GAAK,CAAE,GAEzE,WAAsB,EAAY,EAAS,CACvC,MAAK,WAAU,OAAS,EAAW,EAAU,CAAO,EAC7C,EAAY,SAAS,IAAe,OAAQ,IAAe,EAAQ,GAAG,OAAO,OAAQ,CAAQ,CAAE,CAAE,CAC5G,CAEA,GAAM,GAAa,GAAI,GAAY,EAAQ,CAAE,YAAW,GAAG,CAAQ,CAAE,EAC/D,EAAmB,EAAc,YAAa,EAAQ,GAAO,EAAO,SAAU,EACpF,MAAK,GACM,EAAiB,KAAM,EAAY,CAAY,EAEnD,EAAa,CAAW,CACnC,CAGA,YAAsB,EAAO,CACzB,MAAO,KAAS,KAAY,MAAM,QAAS,CAAK,CACpD,CAGA,WAAqB,EAAK,EAAS,GAAO,CACzC,GAAO,EAAC,GAAO,CAAC,EAAe,CAAI,IAAO,EAAS,KAAM,IAAI,OAAO,4CAA6C,GAAU,CAAI,WAAa,EACzI,MAAK,aAAe,IAChB,GAAM,EAAI,OAEV,GAAO,GAAS,CAAI,CAC5B,CAGA,YAAuB,EAAK,EAAM,EAAU,EAAS,CAAC,EAAI,CACtD,MAAK,KAAS,IACL,EAAO,OAAS,CAAC,EAAe,CAAI,EAAW,EAAU,CAAC,CAAE,EAC1D,GAAS,EAAK,EAAU,CAAO,EAEnC,EAAU,GAAU,EAAM,EAAM,CAAE,CAC7C,CwBhpBA,GAAM,IAAW,CAAE,GAAG,GAAM,GAAG,EAAO,EAE/B,EAAQ,GCRR,GAAM,IAAQ,CAAE,KAAc,IAAU,CAC3C,GAAM,GAAW,EAAK,IAAI,EAC1B,MAAK,GAAU,YAAY,OAAS,gBAAyB,EAAQ,EAAU,KAAM,GAAG,CAAK,EAAG,CAAS,EAClG,EAAU,EAAU,KAAM,GAAG,CAAK,CAAE,CAC/C,EAEa,EAAS,CAAE,EAAc,IAC3B,YAAwB,SAAU,EAAa,KAAM,CAAS,EAAI,EAAU,CAAa,EAGvF,GAAgB,GACnB,MAAO,IAAQ,UAAY,GAAS,MAAO,IAAQ,WAGtD,YAAyB,EAAO,CACnC,GAAM,GAAS,MAAO,GAAM,EAAK,OAAS,IAAQ,SAAW,EAAK,IAAI,EAAI,CAAC,EACrE,EAAS,EAAK,IAAI,GAAK,GAC7B,SAAO,eAAiB,EACjB,CAAE,SAAQ,QAAO,CAC5B,CAEO,GAAM,IAAQ,CAAC,EClBf,GAAM,IAAW,OAAO,OAAQ,IAAK,ECC5C,GAAqB,IAArB,aAA0C,YAAY,CAElD,cAAgB,GAAI,KACpB,YAAc,GAAI,KAElB,aAAc,CACV,MAAM,EACN,GAAM,kBAAmB,EAAG,IAAK,CACrC,CAEA,KAAM,EAAW,CAAE,MAAO,MAAK,cAAe,GAAI,OAAO,EAAU,CAAE,WAAY,EAAK,CAAE,CAAE,CAAG,CAE7F,MAAO,EAAO,CACV,YAAK,iBAAkB,GAAG,CAAK,EACxB,IAAM,KAAK,oBAAqB,GAAG,CAAK,CACnD,CAEA,MAAO,EAAQ,GAAQ,CACnB,KAAK,cAAc,QAAS,GAAK,EAAE,MAAQ,EAAE,MAAO,CAAM,EAAI,EAAG,CAAM,CAAE,EACzE,KAAK,YAAY,QAAS,GAAK,EAAE,MAAQ,EAAE,MAAO,CAAM,EAAI,EAAG,CAAM,CAAE,EACvE,KAAK,YAAY,MAAM,EACvB,KAAK,KAAM,OAAQ,CACvB,CAEA,OAAQ,EAAI,CAAE,KAAK,cAAc,IAAK,CAAE,CAAG,CAC3C,KAAM,EAAI,CAAE,KAAK,YAAY,IAAK,CAAE,CAAG,CAE3C,ECxBA,GAAqB,IAArB,aAAoC,GAAY,CAE5C,YAAc,GAAI,KAClB,QAAU,GAAI,KAEd,YAAa,EAAS,EAAM,EAAQ,CAChC,MAAM,EACN,KAAK,QAAU,EACf,KAAK,SAAS,KAAM,IAAM,KAAK,MAAM,CAAE,EACvC,KAAK,KAAM,IAAM,KAAK,UAAW,EAAM,CAAE,EACzC,KAAK,KAAO,EACZ,KAAK,MAAQ,CACjB,CAEA,GAAI,OAAO,CAAE,MAAO,CAAE,GAAG,KAAK,SAAS,QAAQ,KAAK,GAAK,CAAC,CAAE,EAAE,KAAM,GAAK,KAAK,QAAQ,QAAQ,IAAK,CAAE,IAAM,IAAK,CAAG,CAEnH,OAAQ,EAAM,EAAO,OAAS,CAC1B,GAAI,GAAS,KAAK,QAAQ,IAAK,CAAK,EACpC,MAAM,IAEF,GAAS,GAAI,IACT,KACA,EACA,IAAS,SAAW,EAAS,GAAe,KAAK,KAAM,EAAI,EAAS,IAAK,KAAK,MAAO,CAAK,EAAI,MAClG,EACA,KAAK,QAAQ,IAAK,EAAM,CAAO,EAE1B,KAAK,QAAQ,OAAS,GAAM,KAAK,UAAU,EAEhD,EAAO,KAAM,IAAM,CAEf,KAAK,QAAQ,OAAQ,CAAK,EAEpB,KAAK,QAAQ,MAAS,KAAK,UAAW,EAAM,CACtD,CAAE,GAEC,CACX,CAEA,UAAW,EAAU,CACjB,KAAK,YAAY,IAAK,CAAQ,EAC9B,EAAQ,KAAM,IAAM,CAEhB,KAAK,YAAY,OAAQ,CAAQ,EAE3B,KAAK,YAAY,MAAS,KAAK,MAAM,CAC/C,CAAE,CACN,CAEA,UAAW,EAAO,GAAO,CAErB,AADA,KAAK,gBAAgB,MAAM,EACtB,GAAC,GAAQ,CAAC,KAAK,QAAQ,MAAQ,CAAC,GAAe,KAAK,KAAM,IAC/D,MAAK,eAAiB,EAAS,QAAS,KAAK,MAAO,GAAa,CAE7D,GAAM,GAAY,CAAE,IAAK,GAAI,KAAK,IAAK,EAAU,EAAW,CACxD,OAAY,KAAW,GACnB,AAAK,EAAQ,KAAK,iBAAkB,CAAS,IAAM,IAC7C,MAAK,IAAI,IAAK,EAAQ,OAAQ,GAAM,KAAK,IAAI,IAAK,EAAQ,QAAS,GAAI,IAAI,EACjF,KAAK,IAAI,IAAK,EAAQ,OAAQ,EAAE,IAAK,CAAQ,EAErD,CAAE,EACF,OAAY,KAAY,GAAY,CAChC,GAAM,GAAS,KAAK,QAAQ,IAAK,EAAS,GAAI,EAC9C,AAAK,CAAC,GACN,GAAU,IAAK,EAAO,YAAa,CAAS,EAC5C,EAAO,QAAS,EAAS,KAAM,EACnC,CAEA,GAAM,GAAc,AAAC,EAAU,IAAI,KAAuB,CAAE,GAAG,EAAU,GAAI,EAAE,KAAM,CAAE,EAAG,IAAO,EAAE,QAAU,EAAE,QAAU,GAAK,CAAE,EAAtF,EAAU,IAEpD,OAAY,CAAE,EAAS,IAAc,GACjC,AAAK,EAAQ,QAAU,WACvB,EAAQ,SAAU,GAAG,CAAS,CAEtC,EAAG,CAAE,WAAY,YAAa,CAAE,EACpC,CAEA,QAAS,EAAW,CAChB,KAAK,MAAQ,EACb,OAAY,CAAE,EAAM,IAAY,MAAK,QACjC,EAAO,QAAS,EAAS,IAAK,KAAK,OAAS,CAAC,EAAG,CAAK,CAAE,EAE3D,KAAK,UAAU,CACnB,CAEJ,ECvFA,GAAqB,GAArB,aAAmC,GAAO,CAEtC,QAAU,GAAI,KACd,YAAa,EAAS,EAAM,EAAQ,OAAY,CAC5C,MAAO,EAAS,EAAM,GAAS,OAAO,OAAQ,IAAK,CAAE,CACzD,CAEJ,ECJA,GAAqB,GAArB,aAAqC,GAAY,CAE7C,MAEA,YAAa,EAAS,EAAM,EAAM,EAAQ,EAAO,EAAU,CACvD,MAAM,EAEN,GAAS,KAAM,IAAK,EACpB,KAAK,QAAU,EACf,KAAK,KAAO,EACZ,KAAK,KAAO,EACZ,KAAK,MAAQ,EACR,GAAS,QAAU,GAEpB,KAAK,OAAQ,CAAM,EAEvB,KAAK,OAAS,EACT,GAAY,MAAK,QAAU,GAChC,AAAK,GAAS,OAAS,YAAgB,KAAK,KAAO,EAAQ,KAAK,OAAQ,KAAK,KAAK,KAAM,EACnF,AAAK,GAAS,OAAS,QAAY,KAAK,KAAO,EAAQ,KAAK,OAAQ,KAAK,MAAO,EAC9E,KAAK,KAAS,IAAS,MAAQ,CAAC,GAAI,MAAO,EAAG,EAAG,EAAE,OAAQ,KAAK,MAAO,EAC9E,KAAK,YAAc,GAAI,IAC3B,CAEA,GAAI,UAAU,CAAE,MAAO,MAAK,QAAQ,OAAS,CAE7C,SAAU,EAAO,CAAE,MAAO,QAAS,EAAK,SAAa,EAAK,SAAW,KAAK,SAAU,EAAK,OAAQ,CAAK,CAEtG,MAAO,EAAO,CACV,GAAK,CAAC,EAAO,MAAO,MACpB,GAAM,CAAE,EAAG,GAAM,EAAK,KAAK,OAAS,KAAK,KAAK,OAAS,CAAE,EAAM,IAAK,EAAI,CAAE,KAAM,CAAK,EACrF,MAAO,GAAE,KAAK,OAAQ,CAAE,EAAM,EAAK,IACxB,GAAQ,GAAO,EAAE,KAAM,GAC/B,EAAK,GAAK,GAAK,CACtB,CAEA,eAAgB,CACZ,KAAK,MAAQ,UAEb,GAAM,GAAoB,KAAK,YAC/B,YAAK,YAAc,GAAI,KAChB,CACX,CAEA,QAAS,EAAW,KAAO,CACvB,GAAI,CACA,YAAK,QAAQ,OAAO,QAAS,IAAK,EAC3B,EAAQ,KAAK,cAAc,EAAG,GAC1B,GAAO,KAAK,QAAS,KAAM,KAAM,GAC/B,MAAK,KAAK,UAAa,GAAc,KAAK,KAAK,SAAU,EAAa,IAAK,GAChF,KAAK,aAAc,CAAY,EAC/B,KAAK,QAAQ,OAAO,MAAM,EACnB,EAAW,EAAU,EAAa,IAAK,EAAI,EACpD,CACJ,CACN,OAAS,EAAP,CAEE,GAAK,EAAE,MAAQ,KAAM,GACrB,GAAM,GAAU,GAAI,EAAE,SAAW,IACjC,KAAK,QAAQ,MAAO,EAAS,CAAE,KAAK,OAAQ,KAAK,SAAS,MAAO,EAAG,WAAY,EAAE,KAAO,CAC7F,CACJ,CAEA,aAAc,EAAoB,CAC9B,KAAK,MAAQ,WAEb,GAAM,GAAmB,KAAK,YAE9B,KAAK,iBAAkB,EAAiB,KAAM,EAAkB,IAAK,EACrE,KAAK,kBAAmB,EAAiB,KAAM,EAAkB,IAAK,EACtE,OAAY,KAAO,CAAE,QAAS,WAAY,QAAS,EAC/C,AAAK,EAAiB,IAAK,CAAI,GAAK,CAAC,EAAiB,IAAK,CAAI,EAAE,SAAa,KAAK,iBAAkB,EAAK,EAAiB,IAAK,CAAI,EAAE,GAAI,EAChI,EAAkB,IAAK,CAAI,GAAK,CAAC,EAAkB,IAAK,CAAI,EAAE,UAAa,KAAK,iBAAkB,EAAK,EAAkB,IAAK,CAAI,EAAE,IAAK,EAAK,CAEhK,CAEA,MAAO,EAAI,EAAO,EAAO,OAAY,CACjC,GAAM,GAAY,MAAM,QAAS,CAAM,EAAI,QAAY,IAAU,KAAO,OAAS,MAAO,GACxF,GAAK,IAAc,GAAQ,IAAO,YAAc,IAAS,OAAO,WAAkB,IAAO,mBAAqB,CAAC,CAAE,YAAa,MAAO,EAAE,SAAU,CAAU,EAAM,MAAO,GACxK,KAAK,KAAO,WAAqB,GAAI,OAAO,wBAAyB,EAChE,IAAO,kBAA4B,GAAI,OAAS,GAAO,iBAAkB,MAAY,IAAO,6BAA8B,EACzH,GAAI,OAAO,yBAA0B,IAAO,CACtD,CAEA,IAAK,EAAM,EAAQ,EAAS,EAAO,CAAC,EAAI,CAAE,MAAO,MAAK,IAAK,EAAM,EAAQ,EAAS,CAAE,GAAG,EAAM,KAAM,KAAM,CAAE,CAAG,CAE9G,MAAO,EAAM,EAAQ,EAAS,EAAO,CAAC,EAAI,CAAE,MAAO,MAAK,IAAK,EAAM,EAAQ,EAAS,CAAE,GAAG,EAAM,KAAM,OAAQ,CAAE,CAAG,CAElH,IAAK,EAAM,EAAQ,EAAS,EAAO,CAAC,EAAI,CACpC,EAAO,CAAE,KAAM,MAAuB,GAAG,CAAK,EAExC,GAAU,GAAU,IAAG,IAC7B,GAAM,GAAW,AAAC,EAAK,OAAmB,IAAK,IAAU,CACrD,GAAI,CAAE,MAAO,GAAS,GAAG,CAAK,CAAG,OAC1B,EAAP,CAAa,KAAM,IAAI,OAAO,kBAAmB,MAAW,EAAE,SAAW,CAAG,CAChF,EAHgC,EAI1B,EAAW,CAAE,EAAa,IAAa,CACzC,GAAI,GAAQ,EAAK,OAAS,MAAQ,KAAK,QAAQ,MAAQ,EAAQ,MAE/D,KAAQ,EAAK,OAAS,OAAS,CAAC,CAAE,SAAU,UAAW,EAAE,SAAU,EAAM,IAAK,GAAK,CAAC,EAAS,IAAK,EAAM,MAAO,CAAK,GAAK,EAAM,SAC3H,EAAQ,EAAM,QAElB,GAAI,GAAc,EAAM,QAAQ,IAAK,CAAK,EAC1C,GAAK,GAAiB,GAAY,OAAS,EAAK,MAAU,EAAK,OAAS,OAAS,EAAY,SAAW,GACpG,KAAM,IAAI,OAAO,eAAgB,+BAAoC,EAEzE,GAAa,QAAQ,MAAM,EAC3B,EAAc,CAAE,SAAQ,KAAM,EAAK,IAAK,EACxC,GAAI,GAAgB,EACpB,MAAK,GAAK,QACN,CAAK,EAAK,OAAS,QACf,EAAgB,CAAC,EACZ,EAAgB,CAAC,EAC1B,EAAY,OAAS,EAAS,KAAM,EAAa,EAAe,CAAE,OAAQ,EAAK,OAAQ,OAAQ,EAAK,OAAS,OAAQ,CAAE,EACvH,EAAQ,KAAM,EAAY,MAAO,GAErC,EAAM,QAAQ,IAAK,EAAM,CAAY,EACrC,EAAS,IAAK,EAAM,MAAO,EAAM,CAAc,EACxC,CACX,EACA,MAAO,MAAK,QAAS,EAAK,KAAM,CAAE,WAAU,GAAG,CAAK,EAAG,EAAQ,CAAS,CAC5E,CAEA,OAAQ,EAAM,EAAS,EAAO,CAAC,EAAI,CAE/B,GAAI,GAAe,KAAK,MACxB,KAAO,GAAgB,CAAC,EAAS,IAAK,EAAa,MAAO,CAAK,GAAM,EAAe,EAAa,QAEjG,GAAK,CAAC,EAAiB,KAAM,IAAI,gBAAgB,GAAI,mBAAwB,EAC7E,GAAI,GAAc,EAAa,QAAQ,IAAK,CAAK,EACjD,GAAK,GAAa,OAAS,QAAY,KAAM,IAAI,gBAAgB,oCAAqC,KAAU,EAChH,GAAM,GAAc,EAAS,IAAK,EAAa,MAAO,CAAK,EACrD,EAAW,AAAC,EAAK,OAAmB,IAAK,IAAU,CACrD,GAAI,CAAE,MAAO,GAAS,GAAG,CAAK,CAAG,OAC1B,EAAP,CAAa,KAAM,IAAI,OAAO,iBAAkB,MAAW,EAAE,SAAW,CAAG,CAC/E,EAHgC,EAIhC,MAAO,IAAO,EAAU,OAAW,EAAa,GAAe,CAE3D,GAAa,QAAQ,MAAM,EAC3B,GAAI,GAAgB,EACpB,MAAK,GAAK,QACN,GAAc,GAAe,CAAC,EAC9B,AAAK,EAAK,OAAS,QACf,EAAgB,CAAC,EACZ,EAAgB,CAAC,EAC1B,EAAY,OAAS,EAAS,KAAM,EAAa,EAAe,CAAE,OAAQ,EAAK,OAAQ,OAAQ,EAAK,OAAS,OAAQ,CAAE,EACvH,KAAK,KAAM,EAAY,MAAO,GAGlC,EAAS,IAAK,EAAa,MAAO,EAAM,CAAc,EAC/C,CAAE,UAAW,SAAU,EAAE,SAAU,EAAK,IAAK,EAAI,EAAc,CAC1E,CAAE,CACN,CAEA,IAAK,KAAS,EAAO,CACjB,GAAI,GAAQ,EAAG,EAAO,CAAC,EACvB,AAAK,MAAO,GAAM,IAAQ,SACtB,GAAQ,EAAK,MAAM,EACnB,EAAO,EAAK,MAAM,GAAK,CAAC,GAChB,MAAO,GAAM,IAAQ,UAC7B,GAAO,EAAK,MAAM,GAGtB,GAAI,GAAe,KAAK,MACxB,KAAO,GAAgB,CAAC,EAAS,IAAK,EAAa,MAAO,CAAK,GAAM,EAAe,EAAa,QAEjG,GAAK,CAAC,EAAe,CACjB,GAAK,EAAK,YAAc,OACxB,KAAM,IAAI,OAAO,GAAI,mBAAwB,CACjD,CAEA,GAAM,GAAO,EAAa,QAAQ,IAAK,CAAK,GAAG,KACzC,EAAa,EAAa,OAAQ,EAAM,CAAK,EACnD,MAAK,GAAK,OAAU,KAAK,MAAO,EAAK,MAAO,EAAW,MAAO,CAAK,EAC5D,KAAK,SAAU,EAAY,EAAO,CAAK,CAClD,CAEA,IAAK,KAAQ,EAAO,CAChB,GAAI,GAAQ,EAAG,EAAO,CAAC,EACvB,MAAK,OAAO,GAAM,IAAQ,SACtB,GAAQ,EAAK,MAAM,EACnB,EAAO,EAAK,MAAM,GAAK,CAAC,GAChB,MAAO,GAAM,IAAQ,UAC7B,GAAO,EAAK,MAAM,GAEf,KAAK,SAAU,KAAK,QAAQ,SAAS,OAAQ,EAAK,QAAS,EAAG,EAAO,CAAK,CACrF,CAEA,SAAU,EAAY,EAAO,EAAO,CAChC,GAAM,GAAqB,KAAK,QAAQ,QAAQ,mBAC1C,EAAU,EAAW,OAAU,QAC/B,EAAY,OAAS,KAAK,QAC1B,EAAY,KAAK,QAAU,UAC3B,EAAa,KACnB,MAAS,YAAgB,EAAQ,EAAQ,CAMrC,GAJK,GAAsB,CAAC,GAAW,CAAC,GAAa,CAAC,GAClD,EAAO,UAAW,CAAW,EAG5B,CAAC,GAAS,CAAC,EAAO,OAAS,MAAO,GAAO,OAAU,SAAW,CAC/D,GAAI,GAAc,EAAO,MACzB,MAAK,OAAO,GAAO,OAAU,YAEzB,GAAc,EAAS,MAAO,EAAO,MAAO,CAAE,SAAU,CAAO,CAAE,GAE9D,CACX,CAEA,GAAI,GACJ,MAAO,GAAS,MAAO,EAAO,MAAO,CAAC,EAAG,GAAW,EAChD,GAAG,EACH,IAAK,EAAQ,EAAM,EAAW,KAAO,CAEjC,MAAK,GAAgC,EAAM,IAAK,EAAQ,EAAM,CAAS,EACvE,GAAuB,GAChB,EAAO,EAAO,OAAQ,CAAK,EAAG,EAAQ,CAAE,EACnD,CACJ,EAAI,CACR,EAAK,EAAY,CAAM,CAC3B,CAEA,QAAS,KAAS,EAAO,CACrB,GAAI,GAAU,EAAK,IAAI,EACjB,EAAS,EAAK,IAAI,EAClB,EAAO,EAAK,IAAI,GAAK,CAAC,EAExB,EAAe,EAAS,EAAQ,KAAK,MACzC,GAAK,IAAS,YAAc,CACxB,GAAM,GAAa,KAAK,QAAQ,YAChC,EAAe,EAAQ,YAAY,OAAS,gBAAkB,EAAW,kBAAoB,EAAW,YAC5G,CACA,AAAK,CAAE,QAAS,WAAY,EAAE,SAAU,CAAK,GAAM,GAAQ,GAAI,GAAO,EAAO,CAAK,GAElF,GAAM,GAAU,GAAI,GAAc,KAAM,EAAM,EAAM,EAAQ,EAAO,CAAQ,EAC3E,GAAK,MAAS,cAEV,MAAK,WAAa,EAEb,KAAK,mBAAmB,IAGjC,MAAO,GAAQ,QAAQ,CAC3B,CAEA,SAAU,EAAe,EAAoB,EAAQ,EAAY,CAE7D,AAAK,GAAkB,EAAS,IAAK,KAAK,MAAM,MAAO,EAAU,KAAM,CAAU,EAEjF,GAAM,GAAQ,KACd,cAAO,eAAgB,EAAW,WAAY,CAAE,MAAO,SAAU,EAAW,GAAQ,CAChF,GAAK,GAAY,EAAqB,MAAO,UAAS,UAAU,SAAS,KAAM,CAAU,EACzF,GAAM,GAAiB,EAAM,QAAQ,cAAe,CAAO,EAC3D,MAAO,GAAe,WAAY,SAAU,EAAI,EAAe,QAAS,UAAW,EAAG,EAAI,CAC9F,CAAE,CAAE,EACG,CACX,CAEA,MAAO,EAAe,EAAQ,EAAc,CAExC,MAAK,IAAkB,EAAS,IAAK,KAAK,MAAM,MAAO,EAAO,KAAM,CAAO,EAE3E,EAAY,QAAS,CAAE,CAAE,OAAM,OAAQ,EAAU,qBAAoB,YAAc,CAC/E,KAAK,SAAU,GAAO,EAAoB,EAAQ,EAAW,EAAQ,GAAS,EAAO,UAAW,EAAO,CAC3G,CAAE,EACK,CACX,CAEA,KAAM,WAAW,EAAO,CAAE,MAAO,MAAK,QAAQ,OAAQ,GAAG,CAAK,CAAG,CAEjE,KAAM,WAAW,EAAO,CAAE,MAAO,MAAK,QAAQ,OAAQ,GAAG,CAAK,CAAG,CAEjE,SAAU,EAAQ,CAAE,MAAO,MAAK,iBAAkB,WAAY,CAAM,CAAG,CAEvE,MAAO,EAAQ,CAAE,MAAO,MAAK,iBAAkB,QAAS,CAAM,CAAG,CAEjE,OAAQ,EAAM,CAAE,MAAO,MAAK,iBAAkB,SAAU,CAAI,CAAG,CAE/D,iBAAkB,EAAK,EAAK,EAAQ,GAAQ,CACxC,GAAM,GAAa,KAAK,YAAY,KAIpC,GAHA,AAAK,EAAU,KAAK,YAAY,OAAQ,CAAI,EACrC,KAAK,YAAY,IAAK,EAAK,CAAE,KAAI,CAAE,EACrC,KAAK,OAAS,SAAY,MAAK,QAAQ,WAAa,MACpD,KAAK,OAAS,SAAW,CAAE,QAAS,UAAW,EAAE,SAAU,CAAI,GAAK,IAAQ,KAAK,SAAS,KAAK,MAAQ,CACxG,AAAM,GAAU,MAAK,YAAY,IAAK,CAAI,EAAE,SAAW,IAClD,KAAK,QAAU,WAAc,KAAK,kBAAmB,KAAK,YAAY,KAAM,CAAW,EAC5F,MACJ,CAGA,AAAK,KAAK,QAAU,WAChB,MAAK,iBAAkB,KAAK,YAAY,KAAM,CAAW,EACzD,KAAK,iBAAkB,GAAG,SAAU,EAE5C,CAEA,oBAAqB,EAAO,CAAE,MAAO,MAAK,SAAS,iBAAkB,GAAG,CAAK,CAAG,CAEhF,mBAAoB,EAAK,EAAM,CAC3B,MAAM,WAAU,OACX,UAAU,SAAW,EAAW,KAAK,YAAY,IAAK,CAAI,EACxD,KAAK,YAAY,IAAK,CAAI,GAAG,MAAQ,EAFZ,KAAK,YAAY,MAAQ,EAG7D,CAEA,iBAAkB,EAAW,EAAa,CACtC,GAAI,GACJ,AAAK,KAAK,OAAS,SAChB,CAAG,GAAa,KAAK,SAAS,aACjC,CAAK,EAAc,EAAW,MAAM,EAC1B,GACN,GAAW,MAAQ,WACnB,KAAK,QAAQ,SAAU,CAAW,GAE1C,CAEA,kBAAmB,EAAW,EAAa,CACvC,GAAK,KAAK,OAAS,QAAU,OAC7B,GAAI,GAAY,KAAM,EAAY,GAAI,KACtC,KAAO,EAAY,EAAU,WACzB,AAAK,EAAc,EAAU,MAAM,EACzB,GAAc,EAAU,QAAU,SACxC,GAAU,MAAQ,WAClB,EAAU,IAAK,CAAU,GAGjC,AAAK,EAAU,MAAS,KAAK,QAAQ,SAAU,GAAG,CAAU,EACvD,CAAC,GAAa,GACf,KAAK,QAAQ,GAAI,aAAc,IAAM,CACjC,AAAK,KAAK,QAAQ,WAClB,KAAK,QAAQ,QAAQ,CACzB,EAAG,CAAE,KAAM,EAAK,CAAE,CAE1B,CAEA,MAAO,EAAQ,GAAQ,CACnB,MAAK,IACI,MAAK,SAAS,aAAe,MAAS,MAAO,MAAK,QAAQ,WAC/D,KAAK,YAAY,MAAM,GAE3B,KAAK,MAAQ,EAAQ,QAAU,UACxB,MAAM,MAAO,CAAM,CAC9B,CAEJ,ECvVA,GAAqB,IAArB,aAA0C,EAAQ,CAE9C,OAAS,GAAI,KAEb,YAAa,EAAS,EAAM,EAAM,EAAQ,EAAO,EAAU,CACvD,EAAK,SAAW,EAChB,MAAO,EAAS,EAAM,EAAM,EAAQ,CAAM,EAC1C,KAAK,OAAQ,IAAM,CACf,MAAO,MAAK,WACZ,KAAK,OAAO,MAAM,CACtB,CAAE,CACN,CAEA,UAAW,EAAW,CAClB,YAAK,QAAQ,QAAQ,QAAS,IAAK,EAC5B,EAAQ,EAAS,EAAG,GACvB,MAAK,QAAQ,QAAQ,IAAI,EAClB,EACT,CACN,CAEA,gBAAiB,CACb,MAAK,MAAK,KAAK,OAAS,SAAoB,WAAa,CAAE,OAAU,KAAO,MAAK,SAAW,KAAM,EAAK,EAAI,KAAM,IAAK,EACjH,KAAK,KAAK,OAAS,SAAoB,WAAa,CAAE,OAAU,KAAO,MAAK,SAAW,KAAM,EAAK,EAAI,KAAM,IAAK,EAC/G,CAAE,KAAM,IAAO,EAAE,KAAM,CAAC,KAAK,UAAW,IAAM,KAAK,KAAK,KAAM,IAAK,CAAE,CAAG,EAAI,CACvF,CAEA,SAAU,CACN,AAAK,CAAE,SAAU,QAAS,EAAE,SAAU,KAAK,KAAK,IAAK,EACjD,EAAE,KAAK,WAAY,KAAK,QAAS,EAAI,KAAK,KAAK,WAAY,IAAK,EAChE,KAAK,SAAW,KAAK,eAAe,EACpC,KAAK,SAAS,SAAW,GACzB,KAAK,UAAU,GAEV,MAAK,KAAK,OAAS,OAAU,KAAK,KAAK,KAAM,IAAK,EACvD,KAAK,SAAW,KAAK,eAAe,GAExC,KAAK,QAAQ,CACjB,CAEA,YAAa,CAAE,MAAO,MAAK,YAAc,CAAC,KAAK,WAAW,mBAAoB,WAAY,KAAK,KAAK,KAAM,GAAK,KAAK,WAAW,mBAAmB,CAAG,CACrJ,SAAU,CAAE,AAAK,KAAK,KAAK,OAAS,OAAU,KAAK,UAAW,IAAM,KAAK,KAAK,QAAS,IAAK,CAAE,CAAK,CAEnG,SAAU,CACN,KAAK,UAAY,GACjB,GAAM,GAAQ,IAAM,CAAC,KAAK,WAAW,GAA2B,CAAG,MAAK,OAAS,KAAK,SAAS,KAAK,GAAI,KAClG,EAAS,IAAM,CAEjB,AADc,KAAK,YAAa,KAAK,OAAO,KAAM,EAC5C,QAAQ,EACd,KAAK,QAAQ,CACjB,EACA,GAAK,KAAK,KAAK,OAAS,WAAe,EAAG,GAAO,QAAW,EAAM,OAC3D,MAAQ,EAAM,GAAI,EAAO,EAChC,KAAK,UAAY,EACrB,CAEA,YAAa,EAAa,CACtB,GAAM,GAAQ,KAAK,OAAO,KAAM,EAAO,CAAE,OAAM,EAEzC,EAAQ,CAAE,SAAU,QAAS,EAAE,SAAU,KAAK,KAAK,IAAK,EAAI,CAAE,CAAE,KAAK,YAAc,CAAW,EAAI,CAAE,GAAG,KAAK,MAAM,KAAM,EACxH,EAAQ,GAAI,GAAO,KAAK,MAAO,QAAS,CAAM,EACpD,KAAK,MAAM,QAAQ,QAAS,CAAE,EAAM,IAAU,CAAE,EAAM,QAAQ,IAAK,EAAM,CAAK,CAAG,CAAE,EACnF,GAAM,GAAQ,GAAI,GAAS,KAAM,QAAS,EAAM,KAAK,OAAQ,EAAO,KAAK,KAAK,QAAS,EACjF,EAAM,KAAK,KAAK,OAAS,SAAW,EAAa,EACvD,YAAK,OAAO,IAAK,EAAK,CAAM,EACvB,KAAK,WACN,MAAK,UAAU,UAAY,EAC3B,EAAM,UAAY,KAAK,WAE3B,KAAK,UAAY,EACV,CACX,CAEA,WAAY,CACR,GAAM,GAAkB,CAAE,EAAW,IAAmB,CACpD,GAAM,GAAY,GAAI,KAAK,EAAY,GAAI,KAC3C,OAAY,KAAY,GAAY,CAChC,GAAK,MAAM,QAAS,KAAK,QAAS,GAAK,EAAS,MAAQ,SAAW,SACnE,GAAM,GAAa,KAAK,KAAK,OAAS,SAAW,EAAS,IAAM,EAAS,MACnE,EAAM,KAAK,KAAK,OAAS,SAAW,EAAS,IAAM,SAAU,EAAS,GAAI,EAC1E,EAAgB,KAAK,OAAO,IAAK,CAAI,EAC3C,GAAK,EAED,EAAS,IAAK,EAAc,MAAM,MAAO,KAAK,WAAY,CAAW,EAChE,EAAS,OAAS,UACnB,MAAK,OAAO,IAAK,EAAK,MAAU,EAC3B,EAAc,WAAc,GAAc,UAAU,UAAY,EAAc,WAC9E,EAAc,WAAc,GAAc,UAAU,UAAY,EAAc,WAEnF,EAAU,IAAK,CAAc,WAEzB,EAAS,OAAS,UAAY,CAAC,EAAS,SAAW,CAG3D,GAAK,KAAK,KAAK,OAAS,UAAY,KAAK,SAAS,UAAY,CAAC,EAAc,KAAO,SACpF,EAAU,IAAK,CAAW,CAC9B,CACJ,CACA,KAAK,QAAQ,GAAI,aAAc,IAAM,CACjC,EAAU,QAAS,GAAY,EAAS,MAAO,EAAK,CAAE,CAC1D,EAAG,CAAE,KAAM,EAAK,CAAE,EACb,EAAU,MACX,MAAK,SAAa,UAAY,EAAS,CACnC,MAAO,EACP,MAAO,CACX,EAAK,KAAK,QAAS,EACd,EAAc,MAAS,KAAK,QAAQ,EAEjD,EACA,KAAK,KAAM,EAAS,QAAS,KAAK,SAAU,GAAa,CACrD,EAAQ,KAAK,OAAQ,GAAiB,EAAiB,EAAW,CAAc,CAAE,CACtF,CAAE,CAAE,CACR,CAEJ,ECrHA,GAAqB,IAArB,aAA+C,GAAa,CAExD,KAAM,iBAAiB,CACnB,MAAK,MAAK,KAAK,OAAS,SAAoB,WAAa,CAAE,OAAU,KAAO,MAAK,SAAW,KAAM,EAAK,EAAI,KAAM,IAAK,EACjH,KAAK,KAAK,OAAS,SAAoB,WAAa,CAAE,OAAU,KAAO,MAAK,SAAW,KAAM,EAAK,EAAI,KAAM,IAAK,EAC/G,CAAE,KAAM,SAAa,EAAE,KAAM,CAAG,KAAM,MAAK,UAAW,IAAM,KAAK,KAAK,KAAM,IAAK,CAAE,CAAK,EAAI,CACvG,CAEA,KAAM,UAAU,CACZ,AAAK,CAAE,SAAU,QAAS,EAAE,SAAU,KAAK,KAAK,IAAK,EACjD,EAAE,KAAK,WAAY,KAAK,QAAS,EAAI,KAAM,MAAK,KAAK,WAAY,IAAK,EACtE,KAAK,SAAW,KAAM,MAAK,eAAe,EAC1C,KAAK,SAAS,SAAW,GACzB,KAAK,UAAU,GAEV,MAAK,KAAK,OAAS,OAAU,KAAM,MAAK,KAAK,KAAM,IAAK,EAC7D,KAAK,SAAW,KAAM,MAAK,eAAe,GAE9C,KAAM,MAAK,QAAQ,CACvB,CAEA,KAAM,UAAU,CACZ,GAAI,GAAQ,KAAK,UAAY,GAC7B,GAAM,GAAQ,SAAc,CAAC,KAAK,WAAW,GAA6B,MAAK,OAAS,KAAK,SAAS,KAAK,IAAS,GAAS,KAAM,MAAK,SAAY,CAAC,EAAO,KACtJ,EAAS,SAAY,CAEvB,KAAM,AADQ,MAAK,YAAa,EAAO,KAAM,EACjC,QAAQ,EACpB,KAAM,MAAK,QAAQ,CACvB,EACA,GAAK,KAAK,KAAK,OAAS,WAAe,EAAG,MAAM,GAAO,QAAW,KAAM,GAAM,OACvE,MAAQ,KAAM,GAAM,GAAI,KAAM,GAAO,EAC5C,KAAK,UAAY,EACrB,CAEJ,EClCA,GAAqB,IAArB,KAA2B,CAEvB,YAAa,EAAU,CACnB,OAAO,eAAgB,KAAM,UAAW,CAAE,MAAO,CAAQ,CAAE,EAC3D,GAAM,GAAS,CAAE,YAAa,IAAM,CAAE,EAAS,eAAgB,KAAM,QAAS,CAAE,MAAO,EAAQ,YAAY,IAAK,QAAS,GAAG,IAAK,WAAY,GAAM,aAAc,EAAK,CAAE,CAAG,CAAG,EAC9K,OAAY,KAAQ,GAChB,EAAQ,GAAI,EAAM,EAAQ,EAAO,EACjC,EAAQ,GAAO,EAEnB,AAAK,EAAQ,QAAQ,aAAe,UAChC,OAAO,eAAgB,KAAM,UAAW,CAAE,MAAO,EAAQ,OAAQ,CAAE,CAE3E,CAEA,SAAU,CAAE,MAAO,MAAK,QAAQ,MAAO,EAAK,CAAG,CAEnD,ECTA,GAAqB,IAArB,aAAqC,EAAQ,CAKzC,UAAY,CAAC,EACb,MAAQ,GAAI,KACZ,OAAS,CAAC,EACV,QAAU,CAAC,EAEX,YAAa,EAAS,EAAM,EAAQ,EAAO,EAAU,CACjD,MAAO,EAAS,EAAM,CAAC,EAAa,GAAI,EAAO,CAAQ,EACvD,GAAM,CAAE,UAAU,KAAM,GAAY,EACpC,KAAK,QAAU,EACf,KAAK,QAAU,EAEf,KAAK,SAAW,GAAI,GAAO,OAAW,SAAU,EAChD,KAAK,OAAQ,KAAK,QAAS,EAE3B,KAAK,QAAU,OAAO,OAAQ,IAAK,EACnC,KAAK,UAAY,CAAE,QAAS,CAAC,EAAG,QAAS,CAAC,CAAE,EAC5C,KAAK,OAAQ,IAAM,CACf,EAAS,iBAAkB,KAAK,QAAS,OAAO,KAAM,KAAK,OAAQ,CAAE,EACrE,KAAK,UAAU,QAAQ,OAAQ,CAAE,EACjC,KAAK,UAAU,QAAQ,OAAQ,CAAE,CACrC,CAAE,CACN,CAEA,cAAe,EAAQ,EAAO,GAAQ,CAClC,GAAM,CAAE,CAAE,EAAU,EAAM,GAAU,CAAE,IAAa,KAAK,UAAW,GAC7D,EAAO,KAAK,QAAQ,eAAe,MAAO,EAAU,CAAO,EACjE,MAAO,GAAO,CAAE,OAAM,OAAM,QAAO,EAAI,CAC3C,CAEA,MAAO,EAAS,EAAS,EAAa,KAAM,EAAY,KAAO,CAC3D,GAAI,GAAO,EAAW,IAAc,KAAO,IAAK,OAAiB,IAAa,EACxE,EAAQ,EAAQ,IAAK,GAAU,IAAW,IAAM,KAAK,cAAe,EAAQ,EAAK,CAAE,EAAE,OAAQ,GAAK,CAAE,EAC1G,EAAM,KAAM,CAAE,OAAQ,KAAK,QAAQ,cAAe,CAAE,EACpD,EAAQ,GAAM,IAAc,OAAS,EAAU,CAAE,OAAM,CAAE,EACzD,GAAM,GAAW,KAAK,QAAQ,aAAe,UAAY,KAAK,QAAQ,uBAAyB,IAAS,KAAK,QAAQ,iBAAmB,KAAK,QAAQ,SACrJ,KAAK,IAAa,GAAM,SAAW,GAC9B,GAAc,GAAM,KAAO,GAC1B,CACV,CAEA,GAAI,UAAU,CAAE,MAAO,KAAM,CAE7B,GAAI,aAAa,CAAE,MAAO,MAAK,OAAQ,EAAK,CAE5C,YAAa,EAAW,CAEpB,GAAM,GAAW,KAAK,MAAM,KAC5B,OAAY,KAAW,GAAa,KAAK,MAAM,IAAK,CAAQ,EAC5D,GAAK,GAEL,YAAK,iBAAmB,GACf,WAAmB,EAAY,EAAU,CAE9C,GAAI,GACJ,OAAY,KAAW,MAAK,MAAQ,CAIhC,GAAK,GAAW,EAAQ,MAAO,CAAQ,IAAM,GAAW,CAAE,UAAW,SAAU,EAAE,SAAU,EAAQ,KAAM,GAAK,KAAK,QAAS,IAAK,SAAU,CAAQ,EAAI,CACnJ,KAAK,MAAM,OAAQ,CAAQ,EAAG,QAClC,CAEA,EAAY,EAAY,EAAU,MAAO,CAAQ,EAAI,EAC/C,GAAY,GAAU,EAChC,CAEA,MAAM,GAMN,GAAU,MAAM,EAET,EAAU,QAAS,GAEtB,MAAK,MAAM,OAAQ,CAAU,EAEtB,EAAS,KAAM,KAAM,EAAa,CAAU,EACrD,GAZE,MAAK,KAAM,YAAa,EACnB,KAAK,mBAAmB,GAAM,KAAK,KAAM,aAAc,EACrD,EAWf,EAAI,KAAM,KAAM,OAAW,KAAK,UAAW,CAC/C,CAEA,QAAS,EAAW,KAAO,CACvB,MAAO,OAAM,QAAS,GAAe,CACjC,GAAM,GAAoB,KAAK,QAAQ,mBACjC,GAAI,IAAO,IAAK,EAChB,EACN,MAAO,GAAW,EAAU,EAAmB,IAAK,EAAI,CAC5D,CAAE,CACN,CAEA,MAAO,EAAoB,EAAa,EAAU,CAC9C,GAAM,GAAU,KAAK,YAAc,KAC7B,EAAS,CAAG,GAAG,KAAK,QAAS,QAAS,KAAK,QAAU,EAAG,oBAAmB,EAC3E,EAAQ,GAAI,GAAO,EAAQ,MAAO,WAAY,CAAE,AAAE,KAAU,CAAY,CAAE,EAEhF,MAAO,AADY,IAAI,MAAK,YAAa,EAAS,WAAY,EAAQ,EAAO,CAAQ,EACnE,QAAQ,CAC9B,CAEA,KAAM,WAAW,EAAO,CACpB,GAAM,GAAS,EAAK,IAAI,EAClB,EAAU,MAAO,IAAW,SAAW,CAAE,QAAO,EAAI,EACpD,EAAS,GAAW,CACtB,GAAK,EAAQ,WAAa,EAAQ,UAAY,MAAO,GACrD,KAAK,cAAe,EAAM,KAAK,MAAM,MAAO,EAAS,EAAO,MAAO,CACvE,EACA,GAAK,KAAK,QAAQ,uBAAyB,IAAS,GAAU,EAAQ,QAClE,MAAO,GAAQ,GAAU,EAAQ,OAAS,EAE9C,GAAM,GAAY,UAAY,CAC1B,GAAM,GAAa,KAAK,QAAQ,aAAe,UAAY,KAAK,QAAQ,uBAAyB,IAAS,KAAK,QAAQ,iBAAmB,KAAK,QAAQ,SACvJ,GAAI,CAAE,MAAO,GAAQ,KAAM,QAAQ,EAAQ,OAAS,CAAG,OAAS,EAAP,CACrD,KAAK,GAAE,OAAS,wBAA2B,KAAK,MAAO,wBAAyB,EAAQ,UAAY,EAAa,iBAAkB,KAAiB,MAAQ,CAAE,EAAQ,MAAO,EAAG,KAAM,EAAE,IAAK,EACvL,CACV,CACJ,GAAI,EACJ,MAAM,GAAQ,WACV,KAAK,UAAW,EAAQ,UAAY,UAAY,WAAY,KAAM,CAAQ,EAEvE,CACX,CAEA,KAAM,WAAW,EAAO,CACpB,GAAM,GAAS,AAAC,MAAM,QAAS,EAAM,EAAK,OAAS,EAAI,EAAiB,KAAb,EAAK,IAAI,EAE9D,EAAU,EAAS,KAAM,MAAK,OAAQ,CAAE,GAAG,EAAQ,UAAW,EAAK,CAAE,EAAI,KAAK,MAAM,MAE1F,KAAK,cAAe,EAAM,KAAK,QAAS,EAAS,GAAQ,MAAO,CACpE,CAEA,cAAe,EAAY,EAAQ,EAAQ,EAAe,KAAO,CAC7D,GAAM,GAAc,CAAC,EACrB,OAAY,CAAE,EAAO,EAAQ,IAAW,GAAa,CACjD,GAAK,IAAU,KAAO,EAAQ,CAC1B,EAAS,IAAK,EAAQ,EAAO,CAAO,EACpC,QACJ,CACA,AAAM,EAAS,IAAK,EAAQ,CAAM,GAAM,KAAK,MAAO,0DAA2D,MAAY,CAAE,EAAQ,CAAa,CAAE,EACpJ,EAAS,IAAK,EAAQ,GAAS,EAAO,EAAS,IAAK,EAAQ,CAAM,CAAE,EACpE,EAAY,KAAM,CAAE,EAAO,EAAQ,CAAM,CAAE,CAC/C,CACA,AAAK,CAAC,EAAY,QAClB,KAAK,KAAM,EAAS,QAAS,EAAQ,GAAa,CAC9C,OAAY,CAAE,EAAmB,CAAE,IAAW,GAC1C,OAAY,KAAY,GACpB,AAAK,IAAU,IAAQ,EAAS,IAAK,EAAQ,EAAS,IAAK,EAAS,KAAM,EAChE,EAAS,MAAQ,GAAU,EAAS,IAAK,EAAQ,GAAS,EAAO,EAAS,KAAM,CAGtG,CAAE,CAAE,CACR,CAEA,gBAAiB,EAAO,CACpB,MAAK,MAAK,QAAQ,aAAe,UAAY,KAAK,QAAQ,uBAAyB,IAAS,KAAK,QAAQ,iBACrG,IAAU,KAAK,QAAQ,iBAAoB,KAAK,QAChD,KAAK,KAAM,IAAM,CAAE,MAAO,IAAU,KAAK,QAAQ,gBAAmB,CAAE,GAEnE,MAAM,aAAc,GAAG,CAAK,CACvC,CAEJ,EApKI,EAFiB,GAEV,oBAAoB,IAC3B,EAHiB,GAGV,eAAe,ICJnB,YAAgB,EAAY,EAAsB,EAAQ,EAAS,CAEtE,GAAM,CAAE,MAAK,iBAAiB,CAAC,EAAG,kBAAiB,YAAa,EAC1D,CAAE,eAAc,iBAAgB,iBAAmB,GAAe,CAAO,EAG/E,GAAK,IAAe,SAChB,EAAa,WAAa,EAC1B,EAAa,0BAA4B,WACjC,CAAE,WAAY,gBAAiB,EAAE,SAAU,CAAW,EAAI,CAElE,GAAM,GAAO,KAAO,EAAO,MAAO;AAAA,CAAK,EAAE,KAAM;AAAA,GAAO,EACtD,EAAS,UAAW,IAAe,iBAAmB,SAAW,gBAAkB,EAAe,KAAM,IAAK;AAAA,EAAW;AAAA,GACxH,EAAe,YAAc,EACjC,SAAY,CAAC,CAAE,SAAU,cAAe,EAAE,SAAU,CAAW,EAC3D,KAAM,IAAI,OAAO,uCAAwC,KAAgB,EAI7E,EAAe,WAAa,EAC5B,GAAM,GAAiB,EAAsB,EAAQ,CAAE,eAAc,gBAAe,CAAE,EACtF,GAAK,YAA0B,UAAW,CAAC,CAAE,iBAAkB,eAAgB,QAAS,EAAE,SAAU,CAAW,EAC3G,KAAM,IAAI,OAAO,gGAAiG,EAItH,SAAc,WAAa,EAC3B,EAAc,gBAAkB,EAChC,EAAc,SAAW,EAClB,EAAQ,EAAgB,GAAkB,CAG7C,GAAM,GAAY,CAAE,eAAgB,QAAS,EAAE,SAAU,CAAW,EAK9D,EAAO,AAJC,EAAE,EAAQ,IACf,EAAc,gBAAyB,EAAc,gBAAiB,EAAQ,CAAO,EACnF,GAAM,GAAc,gBAAiB,CAAC,EAAI,YAAc,UAAY,GAAG,EAAO,OAAQ,CAAO,CAAE,GAEtF,CAAE,EAAe,WAAa,EAAG,EAAG,EAAiB,EAAG,EACtE,EAAa,CAAE,WAAY,gBAAiB,EAAE,SAAU,CAAW,EACnE,EAAgB,GAAe,CACjC,GAAI,GAAQ,EACZ,AAAK,GAAgB,GAAQ,EAAM,KAAM,CAAY,GAErD,GAAI,GAAc,SAAU,EAAQ,GAAI,GAAO,OAAW,EAAa,UAAW,EAElF,MAAK,GAAW,SAAU,QAAS,GAAK,IAAQ,GAAc,MAAO,EAAQ,GAAI,GAAO,EAAO,EAAa,CAAI,GAE3G,IAAe,UAAa,GAAc,SAAU,EAAQ,GAAI,GAAO,EAAO,CAAY,GAC1F,MAAO,GAAgB,KAAgB,GAAQ,GAAI,GAAO,EAAO,OAAQ,CAAE,AAAE,KAAU,CAAY,CAAE,GACnG,GAAI,IAAS,OAAW,EAAa,CAAE,GAAG,EAAe,eAAgB,EAAe,eAAgB,mBAAoB,CAAC,CAAW,EAAG,EAAO,CAAM,CAEnK,EACA,MAAO,GACD,EAAc,EAAE,QAAQ,EACxB,CAAE,gBAAe,gBAAe,CAC1C,CAAE,CACN,CC1DA,GAAqB,IAArB,KAA4C,CACxC,eAAgB,EAAO,CACnB,GAAM,GAAU,KAAK,YACf,EAAS,MAAO,GAAM,EAAK,OAAS,IAAQ,SAAW,EAAK,IAAI,EAAI,CAAC,EACrE,EAAS,EAAK,IAAI,GAAK,GAC7B,KAAK,SAAW,GAAO,EAAQ,WAAY,EAAQ,qBAAsB,EAAQ,CAAO,CAC5F,CAEA,SAAU,CAAE,MAAO,GAAQ,KAAK,SAAU,CAAE,CAAE,mBAAqB,EAAc,EAAE,QAAQ,CAAE,CAAG,CAEhG,KAAM,EAAc,CAAE,MAAO,GAAQ,KAAK,SAAU,CAAE,CAAE,mBAAqB,EAAe,CAAY,CAAE,CAAG,CAE7G,SAAU,EAAW,GAAQ,CACzB,MAAO,GAAQ,KAAK,SAAU,CAAE,CAAE,oBACzB,EAAkB,EAAiB,GACjC,EAAe,cACxB,CACN,CACJ,ECdO,eAAmC,EAAO,CAC7C,GAAM,CAAE,SAAQ,UAAW,GAAgB,CAAK,EAC1C,EAAmB,GAAO,iBAAkB,GAAsB,EAAQ,CAAO,EACvF,GAAK,CAAG,aAA4B,UAAY,MAAO,GAEvD,GAAM,GAAkB,kBAAmB,EAAO,CAAE,MAAS,MAAM,IAAmB,KAAM,KAAM,GAAG,CAAK,CAAG,EAC7G,cAAO,eAAgB,EAAiB,WAAY,CAAE,MAAO,kBAAmB,EAAO,CAAE,MAAS,MAAM,IAAmB,SAAU,GAAG,CAAK,CAAE,CAAE,CAAE,EAC5I,CACX,CAEO,GAAM,IAAN,aAAkC,GAAuB,CAGhE,EAFI,EADS,GACF,aAAa,gBACpB,EAFS,GAEF,uBAAuB,IAG3B,GAAM,IAAN,aAA6B,GAAuB,CAG3D,EAFI,EADS,GACF,aAAa,UACpB,EAFS,GAEF,uBAAuB,IAKlC,eAAkC,EAAO,CACrC,GAAM,GAAS,MAAO,GAAM,EAAK,OAAS,IAAQ,SAAW,EAAK,IAAI,EAAI,CAAC,EACrE,EAAS,EAAK,IAAI,GAAK,GAE7B,GAAK,WAAW,QAAQ,WAAa,CACjC,GAAM,CAAE,QAAO,WAAY,WAAW,OAAO,WACvC,EAAM,EAAO,EAAQ,EAAO,YAAa,EAC/C,MAAO,GAAS,EAAK,EAAO,cAAe,CAC/C,CAGA,GADA,WAAW,OAAS,WAAW,QAAU,CAAC,EACrC,CAAC,WAAW,OAAO,iBAAmB,CAGvC,GAAM,GAAmB;AAAA,kCACE,AAFJ,CADL,SAAS,cAAe,8BAA+B,GACvC,QAAQ,MAAO,GAAI,GAAK,CAAC,GAAI,OAAQ,wDAAyD,EAExF,KAAM,KAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAgBpD,WAAW,OAAO,iBAAmB,GAAI,QAAQ,+BAAgC,KAAM,CAAiB,GAAK,CACjH,CACA,MAAO,IAAI,SAAS,GAAO,CACvB,GAAI,GAAiB,GAAI,gBACzB,OAAO,iBAAiB,YAAa,CAAE,SAAQ,QAAO,EAAG,CAAE,EAAe,KAAM,CAAE,EAClF,EAAe,MAAM,UAAY,GAAK,CAClC,GAAM,CAAE,oBAAmB,GAAgB,EAAE,KAC7C,OAAO,eAAgB,EAAa,WAAY,CAAE,MAAO,IAAM,CAAe,CAAE,EAChF,EAAK,CAAY,CACrB,CACJ,CAAE,CACN,CC9EA,yaCQe,WAAS,EAAK,CAC5B,MAAO,CAAC,MAAM,QAAQ,CAAG,GAAK,MAAO,IAAQ,UAAY,CAC1D,CCFe,YAAS,EAAK,CAC5B,MAAO,OAAO,EACf,CCFe,WAAS,EAAK,CAC5B,MAAO,OAAM,QAAQ,CAAG,CACzB,CCMe,YAAS,EAAK,EAAM,EAAW,KAAM,CACnD,MAAO,AAAC,GAAS,CAAI,EAAS,EAAI,OAAO,GAAQ,EAC9C,EAAK,OAAO,GAAQ,EAAS,EAAM,CAAI,CAAC,EAAE,OAC1C,EAAK,QAAQ,CAAI,IAAM,EAC1B,EAHyB,CAAC,CAI3B,CCRe,YAAmB,KAAQ,EAAY,CAKlD,GAJK,WAAW,QAAU,YAAW,OAAS,CAAC,GAC1C,WAAW,OAAO,MACnB,OAAO,eAAe,WAAW,OAAQ,OAAQ,CAAC,MAAO,GAAI,GAAa,CAAC,EAE3E,CAAC,UAAU,OAAQ,MAAO,YAAW,OAAO,KAChD,GAAI,GAAQ,WAAW,OAAO,KAAK,IAAI,CAAG,EAC1C,AAAK,GACD,GAAQ,GAAI,IACZ,WAAW,OAAO,KAAK,IAAI,EAAK,CAAK,GAEzC,GAAI,GAAK,EACT,KAAQ,EAAM,EAAW,MAAM,GAC3B,AAAK,GAAS,IAAU,CAAE,GAAQ,EAAM,IAAI,CAAG,IAC3C,GAAQ,GAAI,IACZ,EAAO,IAAI,EAAK,CAAK,GAG7B,MAAO,EACX,CAEA,GAAM,IAAN,aAA4B,IAAI,CAC5B,eAAgB,EAAO,CACnB,MAAO,GAAG,CAAK,EACf,KAAK,UAAY,GAAI,IACzB,CACA,IAAK,EAAK,EAAQ,CACd,GAAI,GAAc,MAAM,IAAK,EAAK,CAAM,EACxC,YAAK,KAAM,MAAO,EAAK,EAAO,CAAI,EAC3B,CACX,CACA,OAAQ,EAAM,CACV,GAAI,GAAc,MAAM,OAAQ,CAAI,EACpC,YAAK,KAAM,SAAU,CAAI,EAClB,CACX,CACA,IAAK,EAAM,CACP,YAAK,KAAM,MAAO,CAAI,EACf,MAAM,IAAK,CAAI,CAC1B,CACA,IAAK,EAAM,CACP,YAAK,KAAM,MAAO,CAAI,EACf,MAAM,IAAK,CAAI,CAC1B,CACA,UAAW,CAAE,MAAO,OAAM,KAAM,MAAM,KAAK,CAAE,CAAG,CAChD,QAAS,EAAM,EAAK,EAAW,CAC3B,GAAM,GAAQ,CAAE,OAAM,MAAK,UAAS,EACpC,YAAK,UAAU,IAAK,CAAM,EACnB,IAAM,KAAK,UAAU,OAAQ,CAAM,CAC9C,CACA,UAAW,EAAM,EAAK,EAAW,CAC7B,GAAK,MAAM,QAAS,CAAK,GAAK,MAAM,QAAS,CAAI,EAC7C,KAAM,IAAI,OAAO,qDAAsD,EAE3E,OAAU,KAAS,MAAK,UACpB,AAAK,CAAG,IAAe,CAAE,EAAM,GAAI,EAAG,EAAM,IAAK,GAAK,GAAe,CAAE,EAAK,GAAI,EAAG,EAAM,GAAI,GAAK,EAAM,WAAa,IACrH,KAAK,UAAU,OAAQ,CAAM,CAErC,CACA,KAAM,EAAM,KAAQ,EAAO,CAGvB,OAAU,KAAS,MAAK,UACpB,AAAK,CAAG,IAAe,CAAE,EAAM,GAAI,EAAG,EAAM,IAAK,GAAK,GAAe,CAAE,EAAK,GAAI,EAAG,EAAM,GAAI,IAC7F,EAAM,SAAU,GAAG,CAAK,CAEhC,CACJ,EAEM,GAAgB,CAAE,EAAG,IAClB,MAAM,QAAS,CAAE,EAAW,GAAY,EAAG,CAAE,EAAE,OAC7C,EAAE,SAAU,CAAE,EC3EV,YAAS,EAAK,CAC5B,MAAO,OAAO,IAAQ,UACvB,CCHe,YAAS,EAAK,CAC5B,MAAO,KAAQ,MAAQ,IAAQ,EAChC,CCFe,WAAS,EAAK,CAC5B,MAAO,WAAU,QAAW,KAAQ,QAAa,MAAO,GAAQ,IACjE,CCIe,WAAS,EAAK,CAC5B,MAAO,OAAM,QAAQ,CAAG,GAAM,MAAO,IAAQ,UAAY,GAAQ,GAAgB,CAAG,CACrF,CCCe,YAAS,EAAK,CAC5B,MAAO,IAAQ,CAAG,GAAK,EAAa,CAAG,GAAK,IAAQ,IAAS,IAAQ,GAChE,EAAc,CAAG,GAAK,CAAC,OAAO,KAAK,CAAG,EAAE,MAC9C,CCPe,WAAS,EAAK,CAC5B,MAAO,IAAgB,CAAG,GAAM,GAAO,CAAC,EAAE,SAAS,KAAK,CAAG,IAAM,mBAClE,CCPe,YAAS,EAAK,CAC5B,MAAO,aAAe,SAAW,MAAO,IAAQ,QACjD,CCGe,WAAS,EAAK,CAC5B,MAAO,IAAU,CAAG,GAAM,IAAQ,IAAQ,IAAQ,IAAS,IAAQ,MAAQ,IAAQ,IAAM,CAAC,MAAM,EAAM,CAAC,CACxG,CCPe,YAAS,EAAK,CAC5B,MAAO,aAAe,SAAW,MAAO,IAAQ,UAAY,IAAQ,IACrE,CCKe,YAAS,EAAK,CAC5B,MAAO,CAAC,GAAU,CAAG,GAAK,CAAC,EAAa,EAAI,MAAM,CACnD,CCRe,YAAS,KAAQ,EAAO,CACtC,SAAM,QAAQ,GAAO,CACpB,AAAI,EAAI,QAAQ,CAAG,EAAI,GACtB,EAAI,KAAK,CAAG,CAEd,CAAC,EACM,CACR,CCFe,YAAS,EAAK,EAAO,CACnC,EAAQ,GAAS,OAAO,UACxB,EAAQ,GAAS,CAAC,EAAS,CAAK,EAAI,CAAC,CAAK,EAAI,EAI9C,OAFI,GAAkB,CAAC,EACnB,EAAM,EACH,GAAQ,EAAC,GAAS,EAAM,QAAQ,CAAG,EAAI,IAAM,EAAI,OAAS,WAChE,EAAgB,KAAK,CAAG,EACxB,EAAM,EAAM,OAAO,eAAe,CAAG,EAAI,KAE1C,MAAO,EACR,CCVe,YAAS,EAAK,EAAO,CACnC,GAAI,GAAU,CAAC,EACf,UAAmB,EAAK,CAAK,EAAE,QAAQ,GAAO,CAC7C,GAAY,EAAS,GAAG,OAAO,oBAAoB,CAAG,CAAC,CACxD,CAAC,EACM,CACR,CCFe,WAAuB,EAAM,EAAU,EAAY,GAAO,EAAY,GAAO,EAAc,GAAO,CAChH,GAAI,GAAQ,EACR,EAAO,EAAK,MAAM,EAKtB,GAJI,GAAW,CAAI,GAAK,IAAS,IAAQ,IAAS,KACjD,GAAQ,EACR,EAAO,EAAK,MAAM,GAEf,CAAC,EAAK,OACT,KAAM,IAAI,OAAM,8CAA8C,EAE/D,SAAK,QAAQ,CAAC,EAAM,IAAM,CACzB,AAAI,CAAC,EAAc,CAAI,GAAK,CAAC,EAAY,CAAI,GAG5C,GAAY,GAAqB,CAAI,EAAI,OAAO,KAAK,CAAI,GAAG,QAAQ,GAAO,CAC3E,GAAI,EAAC,EAAS,EAAK,EAAM,EAAM,CAAC,EAGhC,IAAI,GAAY,EAAK,GACjB,EAAY,EAAK,GACrB,GAAM,GAAS,CAAS,GAAK,EAAS,CAAS,GAAO,EAAU,CAAS,GAAK,EAAU,CAAS,IAC7F,KAAU,IAAQ,EAAQ,GAE7B,EAAK,GAAO,EAAS,CAAS,GAAK,EAAS,CAAS,EAAI,CAAC,EAAI,CAAC,EAC/D,EAAc,CAAC,EAAW,CAAK,EAAI,EAAQ,EAAI,EAAO,EAAK,GAAM,EAAW,CAAS,EAAG,EAAU,EAAW,EAAW,CAAW,UAE/H,EAAS,CAAI,GAAK,EAAS,CAAI,EAClC,AAAI,EACH,EAAK,GAAO,EAEZ,EAAK,KAAK,CAAS,MAIpB,IAAI,CACH,AAAI,EACH,OAAO,eAAe,EAAM,EAAK,OAAO,yBAAyB,EAAM,CAAG,CAAC,EAE3E,EAAK,GAAO,EAAK,EAEnB,MAAE,CAAU,EAGf,CAAC,CACF,CAAC,EACM,CACR,CCnDe,eAAY,EAAM,CAChC,MAAO,GAAe,EAAM,CAAC,EAAG,EAAM,IAC9B,GACL,GAAoB,GAAoB,EAAoB,CAChE,CCDe,WAAS,EAAK,EAAa,GAAM,CAC/C,MAAI,GAAS,CAAG,EACR,EAEJ,CAAC,GAAc,EAAU,CAAG,EACxB,CAAC,CAAG,EAER,IAAQ,IAAS,IAAQ,GAAK,GAAS,CAAG,EACtC,CAAC,EAEL,GAAa,CAAG,EACZ,MAAM,UAAU,MAAM,KAAK,CAAG,EAElC,EAAU,CAAG,EACT,OAAO,OAAO,CAAG,EAElB,CAAC,CAAG,CACZ,CC5BO,GAAM,GAAI,IAAK,IAAU,GAAY,eAAgB,GAAG,CAAK,EAEvD,GAAS,CAAE,EAAO,IAAc,YAAiB,SAAU,EAAM,KAAM,CAAS,EAAI,EAAU,CAAM,EAEpG,GAAQ,CAAC,ECHtB,GAAqB,IAArB,KAAkC,CAUjC,YAAa,EAAU,EAAM,CAC5B,KAAK,SAAW,EAChB,OAAO,OAAQ,KAAM,CAAE,GAAG,EAAK,OAAQ,EAAS,MAAO,CAAE,EACpD,KAAK,OAAO,QAChB,KAAK,OAAO,OAAO,iBAAkB,QAAS,IAAM,KAAK,OAAO,CAAE,CAEpE,CAOA,QAAS,CACR,YAAK,QAAU,GACR,KAAK,SAAS,mBAAoB,IAAK,CAC/C,CACD,ECpBA,GAAqB,IAArB,aAAkD,GAAa,CAK9D,aAAc,CACb,MAAO,GAAG,SAAU,EACpB,KAAK,KAAK,oBAAsB,KAChC,OAAO,eAAgB,KAAM,kBAAmB,CAAE,MAAO,GAAI,gBAAgB,CAAE,EAC/E,OAAO,eAAgB,KAAM,SAAU,CAAE,MAAO,KAAK,gBAAgB,MAAO,CAAE,EAC9E,GAAU,kBAAmB,EAAG,KAAK,MAAO,CAC7C,CAOA,QAAS,CACR,KAAK,gBAAgB,MAAM,EAC3B,MAAM,OAAO,CACd,CAUA,KAAM,EAAS,CACd,GAAK,KAAK,KAAK,iBAAmB,CAAC,CAAE,SAAU,cAAe,YAAa,EAAE,SAAU,KAAK,OAAO,UAAW,EAAI,OAClH,GAAI,GAAU,EAAQ,EAAS,KAAK,OAOpC,GANK,IAAW,KAAc,GAAS,EAAU,EAAQ,EAAM,IAC9D,GAAU,EAAO,OAAQ,GAAS,EAAO,SAAU,EAAM,GAAI,CAAE,GAE3D,KAAK,OAAO,MAChB,GAAU,EAAQ,OAAQ,GAAS,EAAM,OAAS,OAAS,EAAM,QAAU,EAAM,QAAS,GAEtF,EAAQ,OAAS,CACrB,GAAK,KAAK,KAAK,iBAAmB,KAAK,OAAO,aAAe,aAAe,CAC3E,KAAK,KAAK,gBAAgB,KAAM,GAAG,CAAQ,EAC3C,MACD,CACA,KAAK,KAAK,gBAAkB,KAAK,OAAO,aAAe,SAAW,EAAU,CAAC,EAC7E,GAAM,GAAO,KAAK,SAAW,KAAY,MAAM,QAAS,KAAK,MAAO,EACjE,KAAK,KAAM,EAAS,IAAK,EACzB,KAAK,KAAM,EAAS,GAAK,IAAK,EAEjC,MAAO,IAAQ,EAAM,GAAO,CAC3B,GAAM,GAAa,KAAK,KAAK,gBAE7B,MADA,OAAO,MAAK,KAAK,gBACZ,KAAK,OAAO,aAAe,eAC1B,EAAW,OAAgB,KAAK,KAAK,oBAAoB,KAAM,CAAW,EAEzE,CACR,CAAE,CACH,CACD,CACD,EC5DA,GAAqB,IAArB,KAA8B,CAS7B,YAAa,EAAS,CACrB,KAAK,OAAS,EACd,KAAK,QAAU,CAAC,CACjB,CAUA,gBAAiB,EAAe,CAC/B,YAAK,QAAQ,KAAM,CAAa,EACzB,CACR,CASA,mBAAoB,EAAe,CAClC,KAAK,QAAU,KAAK,QAAQ,OAAQ,GAAU,IAAW,CAAa,CACvE,CAYA,MAAO,cAAc,EAAM,EAAQ,EAAoB,GAAM,EAAY,KAAK,YAAc,CAC3F,GAAK,CAAC,EAAe,CAAO,EAAI,KAAM,IAAI,OAAO,oCAAqC,GAAU,CAAO,WAAa,EACpH,GAAI,GAAsB,KAC1B,MAAK,IAAa,EAAG,YAAa,EAAE,IAAK,EAAO,IAAM,CAAU,GAC/D,GAAsB,EAAG,YAAa,EAAE,IAAK,EAAO,IAAM,CAAU,EACpE,GAAQ,IAAM,GAEV,CAAC,EAAG,EAAQ,UAAW,EAAE,IAAK,CAAK,GAAK,GAC5C,EAAG,EAAQ,UAAW,EAAE,IAAK,EAAM,GAAI,GAAqB,CAAO,CAAE,EAE/D,EAAG,EAAQ,UAAW,EAAE,IAAK,CAAK,CAC1C,CAUA,MAAO,YAAY,EAAM,EAAW,EAAsB,KAAO,CAEhE,GADA,GAAQ,IAAM,EACT,UAAU,SAAW,EAAI,MAAO,GAAG,YAAa,EAAE,IAAK,CAAK,EACjE,GAAK,CAAG,GAAoB,oBAAqB,OAChD,KAAM,IAAI,OAAO,uCAAwC,KAAK,QAAU,2BAAqC,KAAK,OAAS,EAE5H,EAAG,YAAa,EAAE,IAAK,EAAM,CAAoB,EACjD,EAAoB,YAAc,CACnC,CACD,ECrFA,GAAqB,GAArB,KAAgC,CAU/B,YAAa,EAAQ,EAAM,CAE1B,GADA,KAAK,OAAS,EACT,CAAG,EAAI,UAAc,KAAM,IAAI,OAAO,mDAAoD,EAC/F,OAAO,OAAQ,KAAM,CAAI,CAC1B,CACD,ECPA,GAAqB,IAArB,aAA8C,GAAS,CAEtD,MAAO,aAAa,EAAQ,EAAoB,GAAM,EAAY,KAAO,CACxE,MAAO,OAAM,aAAc,YAAa,GAAG,SAAU,CACtD,CAEA,MAAO,WAAW,EAAW,EAAsB,KAAO,CACzD,MAAO,OAAM,WAAY,YAAa,GAAG,SAAU,CACpD,CAKA,YAAa,EAAS,CACrB,MAAO,CAAO,EACd,KAAK,QAAU,CAAC,CACjB,CAKA,gBAAiB,EAAQ,EAAM,EAAS,CACvC,MAAO,OAAM,gBAAiB,GAAI,IAAsB,KAAM,CAAE,SAAQ,OAAM,QAAO,CAAE,CAAE,CAC1F,CASA,KAAM,EAAQ,EAAwB,GAAQ,CAC7C,GAAK,KAAK,QAAQ,OAAS,CAC1B,KAAK,QAAS,GAAI,UAAU,KAAM,CAAE,OAAQ,CAAE,GAAG,CAAO,EAAG,uBAAsB,CAAE,EACnF,MACD,CACA,KAAK,MAAO,KAAK,QAAS,CAAE,CAAE,SAAQ,uBAAsB,CAAE,CAAE,CACjE,CAEA,MAAO,EAAS,EAAY,CAC3B,GAAM,GAA6B,EAAQ,OAAQ,GAAY,EAAS,OAAO,uBAAwB,EAAE,OACnG,EAAuB,EAAU,KAAM,GAAY,EAAS,qBAAsB,EAClF,EAAa,CAAC,EAAG,EAAoB,CAAC,EAAG,EAAgB,EAAQ,OACvE,EAAU,QAAS,GAAY,CAE9B,AAAK,IAA8B,CAAC,IAAyB,EAAW,KAAM,GAAG,EAAS,MAAO,EAE5F,IAA+B,GAAiB,GACpD,CAAK,EAAS,sBACb,EAAkB,KAAM,GAAG,EAAS,OAAO,IAAK,GAAK,CACpD,GAAI,CAAE,SAAQ,UAAS,GAAY,EAC7B,EAAO,GAAI,GAAY,EAAQ,CAAE,KAAM,MAAO,GAAG,CAAQ,CAAE,EACjE,cAAO,eAAgB,EAAM,QAAS,OAAS,GAAQ,MAAQ,CAAE,IAAK,IAAM,EAAQ,MAAM,IAAI,CAAE,EAAI,CAAE,MAAO,EAAQ,MAAM,KAAM,CAAE,EAC9H,EAAQ,UACZ,OAAO,eAAgB,EAAM,WAAY,OAAS,GAAQ,SAAW,CAAE,IAAK,IAAM,EAAQ,SAAS,IAAI,CAAE,EAAI,CAAE,MAAO,EAAQ,SAAS,KAAM,CAAE,EAEzI,CACR,CAAE,CAAE,EACI,EAAkB,KAAM,GAAG,EAAS,MAAO,EAEtD,CAAE,EACF,EAAQ,QAAS,GAAY,CAC5B,AAAK,EAAS,OAAO,wBACpB,EAAS,KAAM,EAAW,OAAS,EAAa,CAAkB,EAC1D,EAAS,KAAM,EAAkB,OAAS,EAAoB,CAAW,CACnF,CAAE,CACH,CASA,MAAO,EAAW,CACjB,KAAK,QAAQ,QAAS,CAAE,QAAS,CAAE,GAAG,KAAK,OAAQ,EAAG,UAAW,CAAC,CAAE,CAAE,EACtE,GAAM,GAAc,EAAS,EAC7B,MAAO,IAAQ,EAAa,GAAe,CAC1C,GAAM,GAAQ,KAAK,QAAQ,MAAM,EACjC,MAAM,GAAM,UAAU,QACtB,KAAK,MAAO,EAAM,QAAS,EAAM,SAAU,EACpC,CACR,CAAE,CACH,CAED,EC1FA,GAAqB,IAArB,aAA+C,GAAa,CAY3D,KAAM,EAAY,EAAM,EAAW,CAClC,MAAK,MAAK,SAAW,CAAC,KAAK,MAAO,EAAW,WACrC,EAAM,GAAG,MAAM,UAAU,MAAM,KAAM,UAAW,CAAE,CAAE,EAE5D,MAAK,QAAU,GACR,KAAK,MAAO,EAAW,WAAa,EAAY,EAAU,IAAK,IACrE,MAAK,QAAU,GACR,EAAM,GAAG,CAAK,EACpB,EACH,CACD,ECrBA,GAAqB,GAArB,aAA2C,GAAS,CAEnD,MAAO,aAAa,EAAQ,EAAoB,GAAM,EAAY,KAAO,CACxE,MAAO,OAAM,aAAc,QAAS,GAAG,SAAU,CAClD,CAEA,MAAO,WAAW,EAAW,EAAsB,KAAO,CACzD,MAAO,OAAM,WAAY,QAAS,GAAG,SAAU,CAChD,CAKA,gBAAiB,EAAM,CACtB,MAAO,OAAM,gBAAiB,GAAI,IAAmB,KAAM,CAAI,CAAE,CAClE,CAUA,KAAM,EAAY,EAAiB,KAAO,CACzC,GAAM,GAAQ,KACd,MAAS,YAAe,KAAU,EAAQ,CACzC,GAAM,GAAe,EAAM,QAAS,GACpC,MAAK,GACG,EAAa,KAAM,EAAY,IAAK,IACnC,EAAM,EAAQ,EAAG,GAAG,CAAK,EACtB,GAAG,CAAM,EAEd,EAAiB,EAAgB,EAAY,GAAG,CAAM,EAAI,EAAO,EACzE,EAAK,CAAE,CACR,CACD,EClDA,uFAqBO,YAAsB,EAAQ,EAAO,EAAS,CAAC,EAAI,CACtD,EAAS,GAAe,CAAO,EAC/B,GAAM,GAAoB,EAAG,EAAQ,mBAAoB,EAEzD,WAA4B,EAAO,CAC/B,GAAI,GAAY,EAAQ,EACxB,EACI,GAAa,OAAO,yBAA0B,EAAO,CAAK,QACpD,CAAC,GAAgB,GAAQ,OAAO,eAAgB,CAAM,IAChE,MAAO,GACD,CAAE,QAAO,YAAW,EACpB,CAAE,WAAY,CAAE,MAAO,OAAW,aAAc,GAAM,WAAY,GAAM,SAAU,EAAK,CAAE,CACnG,CAEA,WAA0B,EAAO,CAC7B,GAAK,EAAkB,IAAK,EAAO,EAAG,EAAI,MAAO,GAGjD,GAAM,GAA0B,EAAmB,CAAK,EACxD,EAAwB,SAAW,SAAU,EAA0B,GAAQ,CAC3E,MAAK,GAAiC,KAAK,WACpC,KAAK,WAAW,IAAM,KAAK,WAAW,IAAI,EAAI,KAAK,WAAW,KACzE,EACA,EAAwB,SAAW,SAAU,EAAO,EAA0B,GAAQ,CAElF,GADA,KAAK,MAAQ,GACR,EAA0B,CAAE,KAAK,WAAa,EAAO,MAAQ,CAClE,MAAO,MAAK,WAAW,IAAM,KAAK,WAAW,IAAK,CAAM,IAAM,GAAU,MAAK,WAAW,MAAQ,EAAO,GAC3G,EACA,EAAwB,OAAS,UAAW,CACxC,GAAM,GAAoB,OAAO,yBAA0B,EAAQ,CAAK,EACxE,MAAO,IAAmB,MAAQ,EAAgB,KAC3C,GAAmB,MAAQ,EAAgB,KAC3C,EAAkB,IAAK,EAAO,EAAG,IAAM,IAClD,EACA,EAAwB,QAAU,UAAW,CACzC,MAAM,MAAK,OAAO,EAClB,CAAO,KAAK,OAAS,KAAK,QAAU,GAAc,CAAC,KAAK,OAAS,CAAC,KAAK,MAAY,MAAO,GAAQ,GAC3F,OAAO,eAAgB,EAAQ,EAAM,KAAK,UAAW,EAC5D,EAAkB,OAAQ,EAAO,EAAG,EAC7B,IAJsB,EAKjC,EACA,EAAkB,IAAK,AAAC,MAAO,CAAK,EAAuB,EAAnB,SAAU,CAAK,EAAU,CAAwB,EAGzF,GAAM,CAAE,aAAa,IAAS,EAAwB,WAChD,EAAkB,CAAE,aAAY,aAAc,EAAK,EAEzD,AAAO,UAAW,GAAwB,YAAgB,EAAwB,WAAW,MACzF,GAAgB,IAAM,SAAW,EAAQ,CAAE,MAAO,IAAK,KAAM,EAAM,EAAO,CAAO,CAAG,GAEjF,UAAW,GAAwB,YAAgB,EAAwB,WAAW,MACzF,GAAgB,IAAM,UAAY,CAAE,MAAO,GAAK,KAAM,EAAM,CAAO,CAAG,GAE1E,GAAI,CACA,cAAO,eAAgB,EAAQ,EAAM,CAAgB,EAC9C,EACX,MAAE,CACE,SAAkB,OAAQ,EAAO,EAAG,EAC7B,EACX,CACJ,CAIA,GAAM,GAAW,AAHF,OAAM,QAAS,CAAM,EAAI,EACpC,IAAU,OAAY,OAAO,KAAM,CAAO,EAAI,CAAE,CAAM,GAElC,IAAK,CAAgB,EAC7C,MAAO,KAAU,QAAa,MAAM,QAAS,CAAM,EAC7C,EACA,EAAU,EACpB,CAWO,YAAwB,EAAQ,EAAO,EAAS,CAAC,EAAI,CACxD,EAAS,GAAe,CAAO,EAC/B,GAAM,GAAoB,EAAG,EAAQ,mBAAoB,EACzD,WAA4B,EAAO,CAC/B,MAAM,GAAkB,IAAK,EAAO,EAAG,EAChC,EAAkB,IAAK,EAAO,EAAG,EAAE,QAAQ,EADA,EAEtD,CAIA,GAAM,GAAW,AAHF,OAAM,QAAS,CAAM,EAAI,EACpC,IAAU,OAAY,OAAO,KAAM,CAAO,EAAI,CAAE,CAAM,GAElC,IAAK,CAAkB,EAC/C,MAAO,KAAU,QAAa,MAAM,QAAS,CAAM,EAC7C,EACA,EAAU,EACpB,CAcO,YAAgB,EAAQ,EAAS,CAAC,EAAG,EAAiB,OAAY,CAErE,GAAM,GAAiB,GAAe,CAAO,EAE7C,GAAK,MAAO,GAAO,UAAa,UAAY,KAAM,IAAI,OAAO,0DAA2D,EACxH,GAAK,EAAO,UAAY,EAAG,EAAgB,aAAc,EAAE,IAAK,EAAO,QAAS,EAAM,MAAO,GAAG,EAAgB,aAAc,EAAE,IAAK,EAAO,QAAS,EACrJ,GAAM,GAAQ,CACV,MAAO,EAAQ,EAAc,EAAgB,CACzC,GAAK,MAAM,QAAS,CAAa,EAAI,CAEjC,GAAM,GAAe,GAAe,CAAa,EACjD,SAAG,CAAa,EAAE,IAAK,UAAW,EAAa,MAAO,EAE/C,GAAO,EAAc,IAAO,GAAO,EAAQ,EAAc,CAAc,CAAE,CACpF,CACA,MAAO,IAAO,EAAQ,GAAS,CAAa,EAAG,CAAc,CACjE,EACA,UAAY,CAAE,EAAQ,EAAe,EAAY,OAAU,GAAW,EAAQ,EAAe,EAAW,CAAO,EAC/G,eAAiB,CAAE,EAAQ,EAAa,IAAgB,GAAgB,EAAQ,EAAa,EAAY,CAAO,EAChH,eAAgB,CAAE,EAAQ,IAAiB,GAAgB,EAAQ,EAAa,CAAO,EACvF,IAAK,CAAE,EAAQ,EAAa,EAAW,OAAU,CAC7C,GAAM,GAAU,CAAE,GAAG,EAAQ,UAAS,EACtC,AAAK,MAAM,QAAS,CAAO,GAAK,IAAgB,UAAY,EAAG,CAAO,EAAE,IAAK,SAAU,GACnF,GAAQ,WAAa,EAAG,CAAO,EAAE,IAAK,SAAU,GAEpD,GAAM,GAAc,EAAK,EAAQ,EAAa,CAAQ,EACtD,MAAK,OAAM,QAAS,CAAO,GAAK,MAAO,IAAgB,WAE5C,GAAO,EAAa,CAAE,GAAG,EAAQ,SAAU,CAAmG,CAAE,EAEpJ,CACX,EACA,yBAA0B,CAAE,EAAQ,IAAiB,GAA0B,EAAQ,EAAa,CAAO,EAC3G,eAAgB,GAAU,GAAgB,EAAQ,CAAO,EACzD,IAAK,CAAE,EAAQ,IAAiB,GAAK,EAAQ,EAAa,CAAO,EACjE,aAAc,GAAU,GAAc,EAAQ,CAAO,EACrD,QAAS,GAAU,GAAS,EAAQ,CAAO,EAC3C,kBAAmB,GAAU,GAAmB,EAAQ,CAAO,EAC/D,IAAK,CAAE,EAAQ,EAAa,EAAO,EAAW,OAAU,CACpD,GAAM,GAAU,CAAE,GAAG,EAAQ,UAAS,EACtC,MAAK,OAAM,QAAS,CAAO,GAAK,IAAgB,UAC5C,GAAQ,cAAgB,EAAG,CAAO,EAAE,IAAK,SAAU,EACnD,EAAG,CAAO,EAAE,IAAK,UAAW,CAAM,GAE/B,GAAK,EAAQ,EAAa,EAAO,CAAQ,CACpD,EACA,eAAgB,CAAE,EAAQ,IAAe,GAAgB,EAAQ,EAAW,CAAO,CACvF,EAEM,EAAS,IAAkB,CAAM,GAAK,EAEtC,EAAS,GAAI,OAAO,EAAgB,CAAO,EACjD,MAAK,GAAO,UAAa,EAAG,EAAgB,aAAc,EAAE,IAAK,EAAO,SAAU,CAAO,EACzF,EAAG,CAAO,EAAE,IAAK,EAAQ,CAAe,EACpC,CACR,CASO,YAAkB,EAAS,CAE9B,MAAO,GAAG,CAAO,EAAE,IAAK,CAAO,GAAK,CACxC,CAWA,YAAwB,EAAS,CAChC,GAAK,CAAC,GAAU,CAAC,EAAe,CAAO,EAAI,KAAM,IAAI,OAAM,gCAAgC,EAC3F,MAAO,IAAS,CAAO,CACxB,C9B5LA,GAAM,IAAN,aAAmB,MAAM,CAAC,EACnB,eAAkB,EAAW,CAChC,MAAO,IAAI,IAAM,GAAG,CAAS,CACjC,CAeO,YAAiB,EAAQ,EAAM,EAAU,EAAQ,GAAK,EAAG,EAAS,CAAC,EAAI,CAC1E,GAAK,EAAC,EAAK,OACX,MAAS,YAAc,EAAQ,EAAM,EAAU,CAC3C,GAAM,GAAU,EAAM,EAAQ,OACxB,EAAgB,EAAQ,QAAU,EAAK,OAAS,EACtD,MAAK,aAAkB,IAAc,EAAO,YAAc,MAEtD,EAAU,CAAE,GAAG,EAAS,MAAO,QAAS,EAChC,EAAQ,QAAU,UAE1B,GAAU,CAAE,GAAG,EAAS,MAAO,CAAC,CAAc,GAG3C,EAAU,EAAQ,EAAS,CAAE,KAAW,IAAU,CAErD,GAAM,GAAW,GAAQ,CACrB,AAAQ,YAAgB,IACxB,GAAK,KAAO,CAAE,EAAK,GAAI,EAClB,YAAkB,IACnB,GAAK,KAAO,EAAO,KAAK,OAAQ,EAAK,GAAI,EACzC,OAAO,eAAgB,EAAM,UAAW,CAAE,IAAK,IAAM,EAAQ,aAAc,EAAK,CAAE,GAE1F,EACM,EAAU,GAAU,CACtB,GAAM,GAAS,EAAY,EAAuD,EAAM,EACxF,MAAO,IAAQ,EAAgC,GAAU,CACrD,AAAK,YAAkB,GACnB,EAAO,MAAQ,EAEf,EAAS,EAEb,GAAM,GAAQ,EAAM,IAAO,CAAC,EAC5B,MAAO,GAAK,EAAQ,EAAM,CAAE,GAAG,EAAS,GAAG,EAAO,MAAO,EAAQ,MAAQ,CAAG,CAAE,CAClF,CAAE,CACN,EAEA,MAAK,IAAa,CAAQ,GAAK,MAAM,QAAS,CAAO,EACjD,GAAO,QAAS,CAAS,EACpB,EAAuB,EAAO,EAAQ,GAAG,CAAK,EAC5C,EAAO,IAAK,CAAQ,GAG/B,GAAU,CAAO,EACZ,EAAuB,EAAO,EAAQ,GAAG,CAAK,EAC5C,EAAS,CAAO,EAE3B,EAAG,CAAQ,CACf,EAAK,EAAQ,EAAK,MAAO,CAAE,EAAG,CAAE,GAAG,EAAQ,MAAO,CAAE,CAAE,CAC1D,CAYO,YAAkB,EAAQ,EAAM,EAAU,EAAS,CAAC,EAAI,CAO9D,GALG,EAAS,EAAY,EAAQ,CAAC,EAAO,KAAM,EACzC,EAAa,UAAW,EAAI,GAC1B,EAAE,CAAE,EAAU,EAAS,CAAC,CAAE,EAAI,UAC9B,EAAO,KAET,CAAC,EAAa,CAAS,EAAI,KAAM,IAAI,OAAO,gCAAiC,GAAU,CAAS,WAAa,EAC/G,GAAK,YAAgB,IAAO,MAAO,IAAQ,EAAQ,EAAM,GAAS,EAAU,CAAO,EAInF,GAFA,EAAS,CAAE,GAAG,EAAQ,WAAY,EAAK,EACvC,MAAO,GAAO,KACT,CAAC,EAAe,CAAO,EAAI,MAAO,GAAO,OAAS,EAAK,EAAQ,EAAM,EAAU,CAAO,EAE3F,GAAM,GAAO,GAAM,EAAQ,EAAM,EAAU,CAAO,EAClD,MAAK,GAAO,MACD,EAAK,EAAQ,EAAM,EAAM,CAAO,EAEpC,EAAK,CAChB,CAWO,YAAoB,EAAQ,EAAO,EAAS,CAAC,EAAI,CAEpD,SAAS,EAAY,CAAO,EACtB,EAAW,CAAM,GACnB,EAAY,CAAe,CAAa,CAAE,EAAS,CAAC,CAAE,EAAI,UAC1D,EAAQ,CAAE,CAAE,UAAW,IAAO,UAAW,EAAI,GAG1C,EAAc,YAAa,EAAQ,GAAM,EAAO,SAAU,EAAE,gBAAiB,CAAE,QAAO,QAAO,CAAE,CAC1G,CAcO,YAAmC,EAAQ,EAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACrF,MAAO,GAAM,EAAQ,2BAA4B,CAAE,IAAK,CAAK,EAAG,EAAU,CAAO,CACrF,CAaO,YAAoC,EAAQ,EAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACtF,MAAO,GAAM,EAAQ,4BAA6B,CAAE,IAAK,CAAK,EAAG,EAAU,CAAO,CACtF,CAWO,YAAyB,EAAQ,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACrE,MAAO,GAAM,EAAQ,iBAAkB,CAAC,EAAG,EAAU,CAAO,CAChE,CAWO,YAAuB,EAAQ,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACnE,MAAO,GAAM,EAAQ,eAAgB,CAAC,EAAG,EAAU,CAAO,CAC9D,CAWO,YAAkB,EAAQ,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAC9D,MAAO,GAAM,EAAQ,UAAW,CAAC,EAAG,EAAU,CAAO,CACzD,CAYO,YAAc,EAAQ,EAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAChE,MAAO,GAAM,EAAQ,MAAO,CAAE,IAAK,CAAK,EAAG,EAAU,CAAO,CAChE,CAYO,WAAc,EAAQ,EAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAEhE,GAAI,GACE,EAAiB,EAAY,EAAQ,CAAC,EAAO,KAAM,EAGzD,MAFA,AAAK,GAAW,CAAS,EAAM,CAAE,EAAQ,CAAS,EAAI,CAAE,EAAU,GAAK,CAAE,EAC/D,EAAO,MAAS,GAAS,IAC9B,YAAgB,IAAc,GAAQ,EAAgB,EAAM,EAAK,EAAU,CAAO,EAEhF,GAAc,EAAgB,EAAM,GAAS,CAChD,GAAM,GAAU,CAAE,GAAG,CAAM,EAC3B,MAAS,YAAe,EAAS,EAAQ,EAAQ,CAC7C,GAAK,CAAC,EAAO,OAAS,MAAO,GAAO,CAAQ,EAC5C,GAAM,GAAO,EAAO,MAAM,EAC1B,GAAK,CAAC,CAAE,SAAU,SAAU,QAAS,EAAE,SAAU,MAAO,EAAK,EACzD,KAAM,IAAI,OAAO,qBAAsB,YAAiB,EAG5D,WAAqB,EAAY,EAAQ,OAAY,CACjD,GAAM,GAAQ,GAAW,GAAW,MAAQ,EAAO,EAAM,CAAE,GAAG,EAAS,EAAO,MAAQ,EAAO,WAAa,EAAa,CAAM,EAAqD,EAAQ,CAAM,GAChM,GAAK,UAAU,OAAS,EAAI,MAAO,GAAO,CAAM,EAChD,GAAK,CAAC,EAAe,CAAe,EAAI,MAAO,GAAO,IAAkB,EAAW,IAAM,EACzF,GAAM,GAAoB,EAAG,EAAgB,oBAAqB,EAAM,EAClE,EAAkB,GAAqB,EAAkB,IAAK,EAAW,GAAI,EACnF,GAAK,GAAmB,EAAgB,OAAO,EAC3C,MAAO,GAAO,EAAgB,SAAU,EAAO,uBAAwB,CAAE,EAE7E,GAAK,EAAO,wBAA0B,CAClC,GAAM,GAAO,OAAO,yBAA0B,EAAgB,EAAW,GAAI,EAC7E,MAAK,cAAgB,IAAW,SAAW,IAAS,GAAK,MAAQ,EAAO,YACjE,EAAO,CAAK,CACvB,CACA,MAAK,cAAgB,GAAkB,EAAO,EAAO,UAAW,EACzD,EAAO,QAAQ,IAAK,EAAgB,EAAW,IAAK,GAAK,EAAO,SAAW,CAAE,EAAO,QAAS,EAAI,CAAC,CAAI,CAAE,CACnH,CAEA,GAAM,GAAa,GAAI,GAAY,EAAgB,CAC/C,KAAM,MACN,IAAK,EACL,MAAO,OACP,UAAW,MACX,SACJ,CAAE,EACF,GAAK,CAAC,EAAe,CAAe,EAAI,MAAO,GAAY,CAAW,EACtE,GAAM,GAAgB,EAAc,YAAa,EAAgB,GAAO,EAAO,SAAU,EACzF,MAAK,GACM,EAAc,KAAM,EAAY,CAAW,EAE/C,EAAY,CAAW,CAClC,EAAK,CAAC,EAAG,EAAM,MAAO,CAAE,EAAG,GAAW,CAClC,GAAM,GAAW,GAAa,CAAiB,EAAI,EAAU,EAAS,GACtE,MAAK,IAAU,EAAe,CAAe,EAElC,AADM,GAAM,EAAgB,EAAM,EAAU,CAAO,EAC7C,CAAS,EAEnB,EAAU,CAAS,CAC9B,CAAE,CACN,EAAG,CAAO,CACd,CAaO,YAAgB,EAAQ,EAAU,EAAS,CAAC,EAAI,CACnD,SAAS,EAAY,CAAO,EACrB,GAAiB,YAAa,EAAQ,GAAM,EAAO,SAAU,EAAE,MAAO,CAAS,CAC1F,CAWO,YAAe,EAAQ,EAAQ,EAAS,CAAC,EAAI,CAChD,EAAS,EAAY,CAAO,EAC5B,EAAS,EAAY,CAAO,EAC5B,GAAM,GAAS,GAAO,MAAQ,CAAC,GAAI,MAAO,CAAE,EAAG,EAAW,GAAO,QAAU,CAAC,GAAI,MAAO,CAAE,EACnF,EAAa,GAAS,EAAO,OAAS,CAAE,GAAG,CAAO,EAAI,CAAO,EAAE,IAAK,GAAK,AAAC,MAAO,CAAE,EAAoB,EAAhB,SAAU,CAAE,CAAM,EACzG,EAAe,EAAK,OAAS,EAAK,OAAQ,GAAK,EAAW,SAAU,CAAE,CAAE,EAAI,EAAW,OAAQ,GAAK,CAAC,EAAO,SAAU,CAAE,CAAE,EAC1H,EAAa,GACV,CAAC,MAAM,QAAS,CAAO,GAAK,MAAO,CAAE,EAAW,EAC9C,EAAI,EAAO,OAAQ,GAAK,EAAI,CAAE,EAAE,OAErC,EAAQ,GAAO,CACjB,GAAM,GAAa,GAA0B,EAAQ,EAAK,CAAO,EACjE,AAAO,SAAW,IAAgB,EAAW,UAAY,EAAW,YAAc,EAAW,aACzF,GAAK,EAAQ,EAAY,CAAI,EAAG,EAAW,MAAO,CAAO,EACjD,GAAW,YAAc,EAAO,iBAAmB,KAAU,GAAgB,EAAQ,EAAK,CAAE,GAAG,EAAY,aAAc,EAAK,EAAG,CAAO,CACxJ,EACA,UAAO,EAAQ,IAAM,CACjB,EAAa,QAAS,CAAM,CAChC,CAAE,EACK,GAAS,EAAQ,GAAa,CAE7B,EAAU,OAAQ,GAAK,EAAK,OAAS,EAAK,SAAU,EAAE,GAAI,EAAI,CAAC,EAAO,SAAU,EAAE,GAAI,CAAE,EAAE,QAAS,GAAK,CACpG,GAAK,EAAE,YAAc,iBAAmB,MAAO,IAAgB,EAAQ,EAAY,EAAE,GAAI,EAAG,CAAO,EACnG,GAAK,EAAE,YAAc,iBAAmB,CACpC,AAAK,GAAE,MAAM,YAAc,EAAO,iBAAmB,KACjD,GAAgB,EAAQ,EAAY,EAAE,GAAI,EAAG,CAAE,GAAG,EAAE,MAAO,aAAc,EAAK,EAAG,CAAO,EAE5F,MACJ,CACA,EAAO,EAAE,GAAI,CACjB,CAAE,CAEV,EAAG,CAAE,GAAG,EAAQ,wBAAyB,EAAK,CAAE,CACpD,CAcO,YAAc,EAAQ,EAAM,EAAO,EAAW,GAAK,EAAG,EAAS,CAAC,EAAG,EAAM,GAAQ,CAEpF,GAAM,GAAiB,EAAY,CAAO,EACtC,EAAU,CAAE,CAAE,EAAM,CAAM,CAAE,EAChC,AAAK,EAAW,CAAK,GACjB,EAAY,CAAU,CAAE,EAAW,GAAK,EAAG,EAAS,CAAC,EAAG,EAAM,EAAM,EAAI,UACxE,EAAU,OAAO,QAAS,CAAK,GAE9B,EAAW,CAAS,GAAM,EAAE,EAAK,EAAQ,CAAS,EAAI,CAAE,MAAO,IAAW,UAAY,EAAS,EAAK,EAAU,GAAK,CAAE,GAE1H,GAAM,GAAU,EAAQ,IAAK,CAAE,CAAE,KAAY,CAAK,EAClD,MAAS,YAAe,EAAa,EAAS,EAAQ,CAClD,GAAK,CAAC,EAAQ,OAAS,MAAO,GAAO,CAAY,EACjD,GAAM,CAAE,EAAM,GAAU,EAAQ,MAAM,EAEtC,WAAqB,EAAY,EAAS,OAAY,CAClD,GAAM,GAAQ,GAAY,GAAW,OAAS,EAAQ,EAAM,EAAY,OAAQ,CAAW,EAAG,EAAS,CAAM,GAC7G,GAAK,UAAU,OAAS,EAAI,MAAO,GAAO,EAAY,CAAO,EAC7D,GAAM,GAAoB,EAAG,EAAgB,oBAAqB,EAAM,EAClE,EAAkB,GAAqB,EAAkB,IAAK,EAAW,GAAI,EACnF,MAAK,GAAW,YAAc,iBACrB,IAAmB,CAAC,EAAgB,QAAQ,GAAI,EAAO,EAAM,EAClE,OAAO,eAAgB,EAAgB,EAAW,IAAK,EAAW,KAAM,EACjE,EAAO,EAAK,GAElB,GAAmB,EAAgB,OAAO,EACpC,EAAO,EAAgB,SAAU,EAAW,KAAM,CAAE,EAExD,EAAO,QAAQ,IAAK,EAAgB,EAAW,IAAK,EAAW,KAAM,CAAE,CAClF,CAEA,WAAe,EAAU,EAAW,CAChC,GAAK,EAAO,MAAQ,IAAU,EAAW,MAAO,GAAM,EAAa,EAAS,CAAM,EAClF,GAAM,GAAa,GAAI,GAAY,EAAgB,CAC/C,KAAM,EAAM,MAAQ,MACpB,IAAK,EACL,QACA,WACA,WACA,QAAS,CAAE,GAAG,CAAQ,EACtB,UAAW,EAAM,iBAAmB,MACpC,OAAQ,EAAO,MACnB,CAAE,EACI,EAAgB,EAAc,YAAa,EAAgB,GAAO,EAAO,SAAU,EACzF,MAAO,GACD,EAAc,KAAM,EAAY,CAAW,EAC3C,EAAY,CAAW,CACjC,CAEA,MAAO,IAAK,EAAgB,EAAM,GAAU,CACxC,GAAK,CAAC,EAAS,MAAO,GAAM,CAAO,EACnC,GAAM,GAAU,CAAE,GAAG,EAAQ,wBAAyB,CAAI,EAC1D,MAAK,iBAAmB,IAAW,GAAQ,WAAa,EAAO,eACxD,EAAK,EAAgB,EAAM,GAAY,EAAM,EAAQ,CAAS,EAAG,CAAQ,CACpF,EAAG,CAAO,CAEd,EAAK,CAAC,EAAG,EAAQ,MAAO,CAAE,EAAG,GAAe,CACxC,GAAM,GAAmB,GAAiB,YAAa,EAAgB,GAAO,EAAO,SAAU,EAC/F,MAAK,IAAmB,EAAiB,KAAM,EAAa,CAAI,EACzD,EACH,GAAa,CAAiB,EAAI,EAAY,IAAK,GAAO,EAAI,MAAO,EAAI,EAAa,IAAK,MAC/F,CACJ,CAAE,CACN,CAaO,YAAyB,EAAQ,EAAM,EAAY,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACvF,MAAO,IAAK,EAAQ,EAAM,EAAY,EAAU,EAAQ,EAAY,CACxE,CAaO,YAA2B,EAAQ,EAAa,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACpF,MAAO,IAAK,EAAQ,EAAa,EAAU,EAAQ,EAAY,CACnE,CAYO,YAAyB,EAAQ,EAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAE3E,EAAS,EAAY,CAAO,EACvB,EAAW,CAAS,GAAM,EAAE,EAAQ,CAAS,EAAI,CAAE,EAAU,GAAK,CAAE,GAEzE,GAAM,GAAQ,EAAU,EAAM,EAAM,EAAG,EAAU,CAAE,GAAG,CAAM,EAC5D,MAAS,YAAe,EAAa,EAAO,EAAQ,CAChD,GAAK,CAAC,EAAM,OAAS,MAAO,GAAO,CAAY,EAC/C,GAAM,GAAO,EAAM,MAAM,EAEzB,WAAqB,EAAY,EAAS,OAAY,CAClD,GAAM,GAAQ,GAAY,GAAW,OAAS,EAAQ,EAAM,EAAY,OAAQ,CAAW,EAAG,EAAO,CAAM,GAC3G,GAAK,UAAU,OAAS,EAAI,MAAO,GAAO,EAAY,CAAO,EAC7D,GAAM,GAAoB,EAAG,EAAQ,oBAAqB,EAAM,EAC1D,EAAkB,GAAqB,EAAkB,IAAK,EAAW,GAAI,EACnF,MAAK,IAAmB,CAAC,EAAgB,QAAQ,GAAI,EAAO,EAAM,EAC3D,EAAO,QAAQ,eAAgB,EAAQ,EAAW,GAAI,CAAE,CACnE,CAEA,WAAe,EAAW,CACtB,GAAM,GAAa,GAAI,GAAY,EAAQ,CACvC,KAAM,SACN,IAAK,EACL,WACA,QAAS,CAAE,GAAG,CAAQ,EACtB,UAAW,iBACX,OAAQ,EAAO,MACnB,CAAE,EACI,EAAmB,EAAc,YAAa,EAAQ,GAAO,EAAO,SAAU,EACpF,MAAO,GACD,EAAiB,KAAM,EAAY,CAAW,EAC9C,EAAY,CAAW,CACjC,CAEA,MAAO,GAAK,EAAQ,EAAM,EAAM,CAAO,CAE3C,EAAK,CAAC,EAAG,EAAM,MAAO,CAAE,EAAG,GAAe,CACtC,GAAM,GAAmB,GAAiB,YAAa,EAAQ,GAAO,EAAO,SAAU,EACvF,MAAK,IAAmB,EAAiB,KAAM,CAAY,EACpD,EACH,GAAa,CAAiB,EAAI,EAAY,IAAK,GAAO,EAAI,MAAO,EAAI,EAAa,GAAI,MAC9F,CACJ,CAAE,CACN,CAKO,YAA2B,EAAQ,EAAO,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAC9E,MAAO,IAAgB,GAAG,SAAU,CACxC,CAeO,YAAoB,EAAQ,EAAe,EAAY,KAAM,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACjG,MAAO,GAAM,EAAQ,YAAa,UAAU,OAAS,EAAI,CAAE,gBAAe,WAAU,EAAI,CAAE,eAAc,EAAG,EAAU,CAAO,CAChI,CAaO,YAAgB,EAAQ,EAAc,EAAe,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACzF,MAAO,GAAM,EAAQ,QAAS,CAAE,eAAc,eAAc,EAAG,EAAU,CAAO,CACpF,CAYO,YAAyB,EAAQ,EAAO,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAC5E,MAAO,GAAM,EAAQ,iBAAkB,CAAE,OAAM,EAAG,EAAU,CAAO,CACvE,CAWO,YAA4B,EAAQ,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CACxE,MAAO,GAAM,EAAQ,oBAAqB,CAAC,EAAG,EAAU,CAAO,CACnE,CAcA,YAAe,EAAQ,EAAM,EAAU,EAAS,CAAC,EAAI,CACjD,GAAI,GACJ,AAAM,EAAO,QACT,GAAa,GAAI,iBACjB,EAAS,CAAE,GAAG,EAAQ,OAAQ,EAAW,MAAO,EAChD,GAAU,kBAAmB,EAAG,EAAW,MAAO,GAEtD,GAAM,GAAmB,GAAiB,YAAa,EAAQ,GAAM,EAAO,SAAU,EACtF,MAAO,YAAe,EAAc,EAAmB,KAAO,CAC1D,GAAkB,OAAO,EAEzB,GAAM,GAAQ,CAAE,OAAQ,AADC,EAAiB,gBAAiB,EAAM,EAAM,CAAO,EACrC,MAAQ,EACjD,GAAK,UAAU,OAAS,CACpB,GAAM,GAAqB,EAAU,EAAc,CAAM,EACzD,GAAK,UAAU,OAAS,EAAI,MAAO,EACvC,CACA,MAAO,EACX,CACJ,CAaA,WAAe,EAAQ,EAAW,EAAU,CAAC,EAAG,EAAW,GAAK,EAAG,EAAS,CAAC,EAAI,CAE7E,EAAS,EAAY,CAAO,EACvB,EAAW,CAAS,GAAM,EAAE,EAAQ,CAAS,EAAI,CAAE,EAAU,GAAK,CAAE,GAEzE,WAAsB,EAAY,EAAS,CACvC,MAAK,WAAU,OAAS,EAAW,EAAU,CAAO,EAC7C,EAAY,SAAS,IAAe,OAAQ,IAAe,EAAQ,GAAG,OAAO,OAAQ,CAAQ,CAAE,CAAE,CAC5G,CAEA,GAAM,GAAa,GAAI,GAAY,EAAQ,CAAE,YAAW,GAAG,CAAQ,CAAE,EAC/D,EAAmB,EAAc,YAAa,EAAQ,GAAO,EAAO,SAAU,EACpF,MAAK,GACM,EAAiB,KAAM,EAAY,CAAY,EAEnD,EAAa,CAAW,CACnC,CAGA,YAAsB,EAAO,CACzB,MAAO,KAAS,KAAY,MAAM,QAAS,CAAK,CACpD,CAGA,WAAqB,EAAK,EAAS,GAAO,CACzC,GAAO,EAAC,GAAO,CAAC,EAAe,CAAI,IAAO,EAAS,KAAM,IAAI,OAAO,4CAA6C,GAAU,CAAI,WAAa,EACzI,MAAK,aAAe,IAChB,GAAM,EAAI,OAEV,GAAO,GAAS,CAAI,CAC5B,CAGA,YAAuB,EAAK,EAAM,EAAU,EAAS,CAAC,EAAI,CACtD,MAAK,KAAS,IACL,EAAO,OAAS,CAAC,EAAe,CAAI,EAAW,EAAU,CAAC,CAAE,EAC1D,GAAS,EAAK,EAAU,CAAO,EAEnC,EAAU,EAAU,EAAM,EAAM,CAAE,CAC7C,C+BhpBA,GAAM,IAAW,CAAE,GAAG,GAAM,GAAG,EAAO,EAE/B,GAAQ,GCRf,GAAqB,GAArB,KAA0B,CAOtB,MAAO,QAAQ,EAAM,CACjB,GAAI,GACJ,MAAQ,GAAO,KAAK,UAAU,IAAK,CAAI,IACnC,GAAO,KAAK,OAAO,EACnB,KAAK,UAAU,IAAK,EAAK,CAAK,GAE3B,CACX,CAGA,MAAO,UAAU,EAAO,CACpB,GAAI,GACJ,YAAK,UAAU,QAAS,CAAE,EAAO,IAAU,CACvC,AAAK,IAAU,GAAO,GAAM,EAChC,CAAE,EACK,CACX,CACJ,EArBI,EAHiB,EAGV,YAAY,GAAI,MACvB,EAJiB,EAIV,SAAS,IAAO,GAAE,KAAK,OAAO,EAAE,KAAK,SAAS,EAAE,GCmB5C,YAAS,EAAM,EAAM,EAAO,CAAC,EAAG,EAAW,CAAC,EAAG,CAC7D,EAAO,EAAS,CAAI,EAAE,MAAM,EAE5B,OADI,GAAQ,EACN,CAAC,EAAa,CAAK,GAAK,CAAC,GAAQ,CAAK,GAAK,EAAK,QAAQ,CAC7D,GAAI,GAAO,EAAK,MAAM,EACtB,GAAI,CAAE,GAAK,IAAM,EAAK,IAAI,EAAO,CAAI,EAAK,EAAc,CAAK,EAAI,IAAQ,GAAQ,EAAM,IAAS,CAC/F,EAAS,OAAS,GAClB,MACD,CACA,EAAQ,EAAK,IAAM,EAAK,IAAI,EAAO,CAAI,EAAI,EAAM,EAClD,CACA,SAAS,OAAS,GACX,CACR,CCfe,YAAS,EAAK,EAAM,EAAK,EAAY,CAAC,EAAG,EAAO,CAAC,EAAG,CAClE,GAAM,GAAO,CAAC,EAAQ,EAAK,IACtB,EAAK,IACD,EAAK,IAAI,EAAQ,EAAK,CAAG,EAEhC,CAAI,EAAW,EAAK,EAAE,GAAK,EAAS,CAAM,EACzC,EAAO,KAAK,CAAG,EAEf,EAAO,GAAO,EAER,IAGT,EAAO,EAAS,CAAI,EAEpB,OADI,GAAS,EACL,EAAI,EAAG,EAAI,EAAK,OAAQ,IAC/B,GAAI,EAAI,EAAK,OAAS,EAAG,CACxB,GAAI,CAAC,GAAW,CAAC,EAAc,CAAM,GAAK,CAAC,EAAY,CAAM,EAC5D,MAAO,GAER,GAAI,GAAS,GAAK,EAAQ,EAAK,GAAI,CAAI,EACvC,GAAI,CAAC,EAAc,CAAM,EAAG,CAC3B,GAAI,EAAK,YAAc,GACtB,MAAO,GAER,EAAS,EAAY,EAAK,SAAS,EAAI,EAAK,UAAU,CAAC,EAAK,EAAW,EAAK,EAAI,EAAE,EAAI,CAAC,EAAI,CAAC,EAC5F,GAAI,GAAgB,EAAK,EAAQ,EAAK,GAAI,CAAM,EAChD,GAAI,CAAC,EACJ,MAAO,EAET,CACA,EAAS,CACV,KACC,OAAO,GAAK,EAAQ,EAAK,GAAI,CAAG,CAGnC,CClDA,GAAqB,IAArB,KAA+B,CAO9B,YAAa,EAAQ,EAAW,GAAO,CACtC,OAAO,eAAgB,KAAM,SAAU,CAAE,MAAO,CAAO,CAAE,EACzD,OAAO,eAAgB,KAAM,gBAAiB,CAAE,MAAO,GAAI,IAAI,CAAE,EACjE,OAAO,eAAgB,KAAM,iBAAkB,CAAE,MAAO,GAAI,IAAI,CAAE,EAClE,KAAK,MAAQ,EACb,AAAK,KAAK,OAAO,sBAChB,KAAK,KAAK,EAEV,KAAK,MAAQ,EAEf,CAEA,MAAO,CACN,KAAK,OAAO,sBAAuB,IAAM,CACxC,OAAY,KAAY,MAAK,cAC5B,EAAS,EACT,KAAK,cAAc,OAAQ,CAAS,EAErC,OAAY,KAAY,MAAK,eAC5B,EAAS,EACT,KAAK,eAAe,OAAQ,CAAS,EAEtC,KAAK,KAAK,CACX,CAAE,CACH,CAUA,OAAQ,EAAU,EAAc,GAAQ,CACvC,GAAK,EACJ,MAAO,IAAI,SAAS,GAAW,CAC9B,AAAK,KAAK,QAAU,GACnB,EAAS,EAAS,CAAE,EAEpB,KAAK,cAAc,IAAK,IAAM,CAC7B,EAAS,EAAS,CAAE,CACrB,CAAE,CAEJ,CAAE,EAEH,AAAK,KAAK,QAAU,GACnB,EAAS,EAET,KAAK,cAAc,IAAK,CAAS,CAEnC,CAUA,QAAS,EAAU,EAAc,GAAQ,CACxC,GAAK,EACJ,MAAO,IAAI,SAAS,GAAW,CAC9B,AAAK,KAAK,QAAU,GACnB,EAAS,EAAS,CAAE,EAEpB,KAAK,eAAe,IAAK,IAAM,CAC9B,EAAS,EAAS,CAAE,CACrB,CAAE,CAEJ,CAAE,EAEH,AAAK,KAAK,QAAU,GACnB,EAAS,EAET,KAAK,eAAe,IAAK,CAAS,CAEpC,CAYA,MAAO,EAAQ,EAAS,EAAkB,CACzC,KAAK,OAAQ,IAAM,CAElB,GAAM,GAAa,EAAQ,CAAgB,EAErC,EAAY,AAAE,GAAgB,CACnC,AAAK,IAAe,QACpB,KAAK,QAAS,IAAM,CACnB,GAAM,GAAc,EAAS,EAAY,CAAgB,EAEnD,EAAoB,AAAE,GAAiB,CAC5C,AAAK,IAAgB,QACrB,KAAK,MAAO,EAAQ,EAAS,CAAY,CAC1C,EAIA,AAAK,YAAuB,SAC3B,EAAY,KAAM,CAAkB,EAEpC,EAAmB,CAAY,CAEjC,CAAE,CACH,EAIA,AAAK,YAAsB,SAC1B,EAAW,KAAM,CAAU,EAE3B,EAAW,CAAW,CAExB,CAAE,CACH,CAED,EC1IO,YAAkB,EAAO,CAAE,MAAS,GAAO,EAAK,KAAK,IAAO,EAAK,WAAY,GAAI,GAAK,EAAK,SAAU,GAAI,CAAE,CAE3G,YAAgB,EAAQ,EAAS,EAAM,EAAU,GAAO,CAC3D,EAAS,OAAM,QAAS,CAAK,EAAI,EAAO,CAAE,CAAK,GAAI,IAAK,GAAO,GAAI,IAAK,QAAS,IAAK,EAAU,OAAS,KAAM,CAAE,EAAE,KAAM,GAAI,EAC7H,GAAM,GAAS,EAAO,SAAS,SAAU,EAAM,EAAS,KAAM,YAAY,QAAS,EAC/E,EAAQ,CAAC,EAAG,EAChB,KAAQ,EAAO,EAAO,YAAY,GAAI,EAAM,KAAM,CAAK,EACvD,MAAO,EACX,CAEO,YAAgB,EAAQ,EAAM,EAAO,CACxC,SAAS,OAAM,QAAS,CAAK,EAAI,EAAO,CAAE,CAAK,GAAI,IAAK,GAAO,GAAI,IAAK,QAAS,IAAK,SAAU,CAAE,EAAE,KAAM,GAAI,EACvG,EAAO,SAAS,SAAU,GAAI,IAAS,EAAM,KAAM,YAAY,YAAa,EAAE,YACzF,CAEO,YAAgB,EAAG,EAAQ,IAAM,CACpC,MAAO,CAAE,GAAG,CAAE,EAAE,OAAQ,CAAE,CAAE,EAAO,GAAU,IACpC,IAAM,GAAS,IAAU,EAAW,CAAE,EAAO,CAAE,EAAG,EAAE,OAAQ,CAAO,CAAE,EACrE,EAAE,IAAK,GAAI,EAAE,SAAU,CAAE,GAAK,CAAC,EAAQ,GAAI,SAAU,IAAK,GAAI,IAC9D,CAAE,IAAK,GAAI,EAAE,SAAU,CAAE,GAAK,CAAC,EAAQ,GAAI,SAAU,IAAK,GAAI,IACnE,EAAQ,IAAO,EACR,CAAE,EAAO,CAAO,GACxB,CAAE,EAAG,CAAE,EAAG,CAAE,CAAE,EAAG,GAAI,QAAQ,CACpC,CCnBA,GAAqB,GAArB,KAA6B,CACzB,YAAa,EAAU,CACnB,KAAK,QAAU,EACf,KAAK,KAAO,MAAO,IAAY,SAAW,WAAa,WACvD,KAAK,KAAO,KAAK,OAAS,WAAa,KAAO,AAAM,GAAS,CAAQ,EAAI,QAAU,MAC9E,KAAK,OAAS,SACf,MAAK,YAAc,AAAM,GAAO,EAAQ,KAAK,EAAE,MAAO,EAAG,EAAG,EAAG,GAAI,EAAE,OAAS,EAEtF,CACA,UAAW,CAAE,MAAO,MAAK,OAAS,CACtC,ECJA,GAAqB,IAArB,KAA8B,CAO7B,YAAa,EAAS,EAAW,EAAS,CACzC,KAAK,QAAU,EACf,KAAK,UAAY,EACjB,KAAK,OAAS,EAAQ,aAAe,EAAQ,eAAe,aAAe,EAC3E,KAAK,SAAW,KAAK,OAAO,SAC5B,KAAK,OAAS,KAAK,OAAO,OAC1B,OAAO,eAAgB,KAAM,IAAK,CAAE,MAAO,CAAC,CAAE,CAAE,CACjD,CASA,YAAa,EAAO,CAOnB,GANA,AAAK,EAAa,EAAM,EAAI,EAAM,EAAO,CAAE,CAAC,EAAG,GAAG,CAAK,EAClD,AAAK,EAAW,EAAM,EAAI,GAAK,CAAG,GAAM,YAAe,KAAa,EAAK,SAAW,EACxF,EAAO,CAAE,CAAC,EAAG,OAAW,EAAM,EAAI,EAC5B,AAAK,EAAW,EAAM,EAAI,GAAK,EAAK,SAAW,EACrD,EAAO,CAAE,EAAU,EAAM,GAAK,EAAoB,EAAG,OAAW,EAAM,EAAI,EAClE,EAAM,GAAM,EAAU,EAAM,GAAK,EAAoB,EACzD,EAAM,GAAI,OAAQ,GAAK,MAAO,IAAM,UAAY,CAAG,aAAa,KAAa,CAAG,aAAa,MAAK,OAAO,KAAO,EAAE,OACtH,KAAM,IAAI,OAAO,2EAA4E,EAE9F,SAAM,GAAM,EAAM,GAAI,IAAK,GAAK,YAAa,GAAU,EAAI,GAAI,GAAS,CAAE,CAAE,EACrE,CACR,CASA,YAAa,EAAO,CACnB,MAAO,IAAY,mBAAoB,KAAK,OAAQ,KAAK,UAAW,GAAG,CAAK,CAC7E,CASA,uBAAwB,CACvB,MAAO,CACN,UAAW,CAEV,YAAK,gBAAgB,MAAM,EAC3B,KAAK,eAAiB,GAAI,iBACZ,CAAE,OAAQ,KAAK,eAAe,MAAO,CAEpD,EACA,YAAa,CAAE,KAAK,gBAAgB,MAAM,CAAG,CAC9C,CACD,CAWA,uBAAwB,EAAoB,EAAU,EAAW,CAChE,GAAM,CAAE,UAAW,KAAM,EAAU,MAAM,QAAS,CAAS,EAAI,EAAW,CAAE,CAAS,EACjF,EAAgB,GAAI,KACxB,OAAY,CAAE,EAAO,IAAgB,MAAK,SAAU,CAAmB,EACtE,OAAY,CAAE,EAAS,IAAc,GAAa,CAEjD,GAAI,GAAU,EAAQ,OAAQ,GACvB,EAAQ,SAAU,EAAO,MAAO,EAC/B,IAAU,WAAa,EAAO,SAAW,EADC,EAEhD,EACF,GAAK,EAAC,EAAQ,OAEd,CAAM,MAAM,QAAS,CAAS,GAAM,GAAU,EAAS,IACvD,OAAY,KAAgB,GAC3B,EAAc,IAAK,CAAE,EAAc,EAAS,CAAQ,CAAE,EAGxD,CAID,OAAY,CAAE,EAAc,EAAU,IAAa,GAClD,EAAS,KAAM,EAAQ,EAAc,EAAU,CAAQ,CAEzD,CAUA,gBAAiB,KAAW,EAAU,CACrC,GAAM,GAAiB,CAAE,YAAa,CACrC,EAAQ,QAAS,GAChB,GAAK,EAAa,EAAE,UAAW,GAAK,EAAE,WAAW,GAC9C,EAAa,CAAE,GAAK,EAAE,GACtB,EAAW,CAAE,GAAO,GAAE,aAAe,GACvC,CACH,CAAE,EACF,MAAK,IAAS,EAAO,iBAAkB,QAAS,IAAM,EAAe,WAAW,CAAE,EAC3E,CACR,CACD,EC3HA,GAAqB,IAArB,aAA0C,GAAS,CAKlD,YAAa,KAAY,EAAO,CAC/B,MAAO,EAAS,OAAQ,GAAG,CAAK,CACjC,CAWA,IAAK,EAAM,EAAW,OAAW,EAAS,CAAC,EAAI,CAC9C,GAAM,GAAyB,MAAO,IAAS,UAAY,YAAgB,GAC3E,CAAE,EAAO,CAAC,EAAG,EAAW,OAAW,EAAS,CAAC,CAAE,EAAI,KAAK,YAAa,SAAU,EAC/E,GAAM,CAAE,WAAY,KAEd,EAAU,GAAkB,EAAS,CAAK,EAChD,GAAK,CAAC,EAAW,MAAO,GACxB,GAAM,GAAkB,EAAO,kBAAoB,KAAK,sBAAsB,EAC9E,GAAM,EAIL,OAAY,KAAU,GAAU,CAC/B,GAAM,GAAQ,GAAiB,SAAS,GAAK,CAAC,EAC9C,EAAU,EAAQ,EAAO,CAAQ,CAClC,KAP8B,CAC9B,GAAM,GAAQ,GAAiB,SAAS,GAAK,CAAC,EAC9C,EAAU,EAAS,EAAO,CAAQ,CACnC,CAOA,GAAK,EAAO,KAAO,CAClB,AAAK,GAAoB,GAAS,CAAE,GAAG,EAAQ,iBAAgB,GAC/D,GAAM,GAAsB,KAAK,QAAS,EAAyB,EAAM,GAAM,EAAM,EAAU,CAAE,SAAU,GAAM,GAAG,CAAO,CAAE,EAC7H,MAAO,MAAK,gBAAiB,EAAO,OAAQ,CAAoB,CACjE,CACD,CAWA,QAAS,EAAM,EAAU,EAAS,CAAC,EAAI,CACtC,GAAM,GAAyB,MAAO,IAAS,UAAY,YAAgB,GAG3E,GAFA,CAAE,EAAO,CAAC,EAAG,EAAU,EAAS,CAAC,CAAE,EAAI,KAAK,YAAa,SAAU,EAE9D,CAAE,OAAQ,WAAY,EAAE,SAAU,EAAO,MAAO,EAAI,MAAO,MAAK,YAAa,EAAyB,EAAM,GAAM,EAAM,EAAU,CAAO,EAC9I,GAAK,EAAO,QAAU,EAAO,SAAW,QAAU,KAAM,IAAI,OAAO,kBAAmB,EAAO,kBAAoB,EAEjH,GAAM,CAAE,UAAS,SAAQ,UAAW,KAEpC,AAAK,EAAO,cAAgB,CAAC,EAAO,QAAQ,uBAAuB,cAClE,GAAiB,KAAM,EAAQ,YAAa,IAAM,CAAC,CAAE,EAGtD,GAAM,GAAiB,GAAI,GAAO,iBAAkB,GAAW,CAC9D,EAAU,GAAO,CAAQ,EAAE,IAAK,GAAO,GAAqB,KAAM,EAAQ,CAAI,CAAE,EAChF,GAAS,KAAM,EAAQ,EAAc,EAAS,CAAQ,CACvD,CAAE,EAEI,EAAU,CAAE,WAAY,GAAM,kBAAmB,EAAO,SAAU,QAAS,EAAO,OAAQ,EAChG,AAAK,EAAK,QAAW,GAAQ,gBAAkB,EAAK,IAAK,GAAK,EAAI,EAAG,GACrE,EAAe,QAAS,EAAS,CAAQ,EAEzC,GAAM,GAAkB,EAAO,iBAAmB,EAAO,kBAAoB,KAAK,sBAAsB,EAClG,EAAe,CAAE,UAAS,OAAM,WAAU,SAAQ,QAAS,GAAI,KAAK,yBAAwB,kBAAiB,gBAAe,EAElI,MAAO,MAAK,gBAAiB,EAAO,OAAQ,EAAgB,CAAgB,CAC7E,CAWA,YAAa,EAAM,EAAU,EAAS,CAAC,EAAI,CAC1C,GAAM,GAAyB,MAAO,IAAS,UAAY,YAAgB,GAC3E,CAAE,EAAM,EAAU,EAAS,CAAC,CAAE,EAAI,KAAK,YAAa,SAAU,EAC9D,GAAM,CAAE,UAAS,UAAW,KAE5B,GAAK,EAAO,QAAU,CAAC,CAAE,OAAQ,WAAY,EAAE,SAAU,EAAO,MAAO,EAAI,KAAM,IAAI,OAAO,kBAAmB,EAAO,kBAAoB,EAC1I,GAAM,GAAqB,EAAO,SAAW,YAAc,YAAc,OACnE,EAAoB,EAAO,QAAU,UAAY,WACvD,AAAM,KAAK,SAAU,CAAmB,EAAE,MAEzC,GAAiB,KAAM,EAAQ,EAAoB,GAAW,CAC7D,KAAK,uBAAwB,EAAoB,EAAS,EAAS,CACpE,CAAE,EAGH,GAAM,GAAiB,CAAE,YAAa,CACrC,EAAS,OAAQ,CAAa,EACxB,EAAS,MAAS,EAAW,OAAQ,CAAQ,CACpD,CAAE,EACI,EAAkB,EAAO,iBAAmB,EAAO,kBAAoB,KAAK,sBAAsB,EAClG,EAAe,CAAE,UAAS,OAAM,WAAU,SAAQ,QAAS,GAAI,KAAK,yBAAwB,kBAAiB,gBAAe,EAE5H,EAAa,KAAK,SAAU,EAAoB,CAAkB,EACxE,AAAM,EAAW,IAAK,CAAQ,GAAM,EAAW,IAAK,EAAS,GAAI,IAAI,EACrE,GAAM,GAAW,EAAW,IAAK,CAAQ,EACzC,SAAS,IAAK,CAAa,EAEpB,KAAK,gBAAiB,EAAO,OAAQ,EAAgB,CAAgB,CAC7E,CACD,EASA,YAAgB,EAAU,CACzB,MAAO,GAAQ,OAAQ,CAAE,EAAM,EAAK,IAC9B,EAAM,EAAI,IAAK,gBAAkB,EAAI,cAAuB,EAC1D,EAAK,OAAQ,CAAI,EACtB,CAAC,CAAE,CACP,CAUA,YAAmB,EAAc,EAAU,CAC1C,GAAM,CAAE,UAAS,OAAM,WAAU,SAAQ,UAAS,yBAAwB,mBAAoB,EACxF,EAAQ,EAAK,IAAK,GAAK,EAAI,EAAG,EAMpC,GALA,AAAK,EAAO,QAAU,CAAC,EAAQ,KAC9B,EAAU,GAAkB,EAAS,EAAM,CAAQ,EACxC,EAAO,SAAW,SAAW,EAAK,QAC7C,GAAU,EAAQ,OAAQ,GAAK,EAAM,SAAU,EAAE,IAAK,CAAE,GAEpD,CAAC,EAAQ,OAAS,OAEvB,AAAQ,EAAO,WAAa,MAAQ,EAAO,WAAa,MAAQ,EAAO,cACtE,GAAU,EAAQ,IAAK,GAAO,CAC7B,GAAI,GACJ,MAAM,GAAO,cACV,EAAE,MAAO,EAAW,GAAG,CAAI,EAAI,GAE7B,CAAC,EAAO,UAAc,YAAc,IACtC,EAAE,SAAU,EAAW,GAAG,CAAI,EAAI,GAErC,AAAK,CAAC,EAAO,UAAc,SAAW,GACnC,CAAE,MAAO,EAAW,GAAG,CAAI,EAAI,EACtB,EAAO,UAAY,MAAO,GAAI,MAAU,KACnD,GAAM,CAAG,GAAG,EAAK,MAAO,EAAI,OAAO,aAAc,EAAI,IAAK,CAAE,GAEtD,CACR,CAAE,GAEE,EAAO,QACX,GAAQ,QAAS,GAAU,EAAQ,IAAK,EAAO,KAAM,CAAO,CAAE,EAC9D,EAAU,MAAM,KAAM,EAAQ,QAAQ,CAAE,EAAE,IAAK,CAAE,CAAE,CAAE,KAAa,CAAM,GAEzE,GAAM,GAAW,EAAyB,EAAS,GAAM,EACnD,EAAQ,GAAiB,SAAS,GAAK,CAAC,EAC9C,EAAU,EAAU,EAAO,CAAQ,CACpC,CAWA,YAA2B,EAAS,EAAM,EAAU,CAAC,EAAI,CACxD,GAAM,GAAQ,CAAE,MAAO,KAAM,KAAM,WAAY,EAC/C,MAAK,GAAK,OACF,EAAK,IAAK,GAChB,GAAW,EAAW,GACf,EAAQ,KAAM,GAAK,EAAE,OAAS,CAAS,GAAK,CAAE,OAAQ,EAAS,KAAM,EAAU,MAAO,EAAQ,aAAc,CAAS,EAAG,GAAG,CAAM,EACvI,EAGI,AADO,MAAM,KAAM,EAAQ,UAAW,EAChC,IAAK,GACV,EAAQ,KAAM,GAAK,EAAE,OAAS,EAAK,QAAS,GAAK,CAAE,OAAQ,EAAS,KAAM,EAAK,SAAU,MAAO,EAAK,UAAW,GAAG,CAAM,CAC/H,CACH,CASA,YAA+B,CAAE,SAAQ,gBAAe,QAAO,YAAa,CAE3E,GAAM,GAAQ,AADkB,CAAjB,KAAwB,OAAO,QAAQ,yBAAyB,IAAK,CAAO,GAAK,CAAC,GACzE,KAAmB,IAAO,WAElD,MADe,CAAE,SAAQ,KAAM,EAAe,QAAO,WAAU,KAAM,cAAe,OAAM,CAE3F,CAUA,YAA2B,EAAQ,EAAW,CAC7C,GAAM,GAAS,KACT,CAAE,SAAQ,WAAU,WAAY,EACtC,AAAM,EAAO,QAAQ,uBAA0B,OAAO,eAAgB,EAAO,QAAS,wBAAyB,CAAE,MAAO,GAAI,IAAI,CAAE,EAC5H,EAAO,QAAQ,sBAAsB,IAAK,CAAO,GAAM,EAAO,QAAQ,sBAAsB,IAAK,EAAQ,GAAI,IAAI,EACvH,EAAO,QAAQ,sBAAsB,IAAK,CAAO,EAAE,IAAK,CAAS,EACjE,GAAM,GAAK,IAAM,EAAO,QAAQ,sBAAsB,IAAK,CAAO,EAAE,OAAQ,CAAS,EACrF,GAAK,EAAO,QAAQ,uBAAuB,aAAe,MAAO,GACjE,QAAQ,KAAM,+CAAgD,EAC9D,EAAO,QAAQ,sBAAsB,aAAe,GACpD,OAAO,eAAgB,EAAO,QAAS,0BAA2B,CAAE,MAAO,GAAI,IAAI,CAAE,EAGrF,GAAM,GAAgB,CAAE,EAAQ,IAAmB,CAClD,AAAM,EAAO,QAAQ,wBAAwB,IAAK,EAAO,MAAO,GAAM,EAAO,QAAQ,wBAAwB,IAAK,EAAO,OAAQ,CAAC,CAAE,EACpI,GAAM,GAAW,EAAO,QAAQ,wBAAwB,IAAK,EAAO,MAAO,EAE3E,EAAU,EAAO,MAAS,EAAU,EAAO,OAAU,CAAC,EACtD,EAAU,EAAO,MAAO,QAAS,EAAO,KAAM,EAE9C,EAAO,QAAQ,sBAAsB,IAAK,WAAY,GAAG,QAAS,GAAY,EAAU,CAAE,CAAO,CAAE,CAAE,EACrG,GAAM,GAAc,EAAc,EAClC,SAAO,QAAQ,sBAAsB,IAAK,MAAO,GAAG,QAAS,GAAY,EAAU,CAAE,CAAO,CAAE,CAAE,EACzF,CACR,EAaA,AAVW,GAAI,GAAO,iBAAkB,GAAW,CAMlD,AALA,EAAU,EAAQ,OAAQ,GAElB,CAAC,AADS,GAAO,OAAO,QAAQ,yBAAyB,IAAK,EAAI,MAAO,GAAK,CAAC,GACpE,EAAI,gBAAiB,MAAM,CAC5C,EACF,EAAU,GAAO,CAAQ,EAAE,IAAK,GAAO,GAAqB,KAAM,EAAQ,CAAI,CAAE,EAC3E,AAAC,EAAQ,QACd,GAAO,QAAQ,sBAAsB,IAAK,WAAY,GAAG,QAAS,GAAY,EAAU,CAAQ,CAAE,EAClG,EAAO,QAAQ,sBAAsB,IAAK,MAAO,GAAG,QAAS,GAAY,EAAU,CAAQ,CAAE,EAC9F,CAAE,EACC,QAAS,EAAU,CAAE,WAAY,GAAM,QAAS,GAAM,kBAAmB,EAAK,CAAE,EAGnF,GAAM,GAAe,OAAO,OAAQ,IAAK,EACzC,OAAE,eAAgB,kBAAmB,iBAAmB,EAAE,QAAS,GAAW,CAC7E,EAAc,GAAY,EAAQ,UAAW,GAC7C,EAAQ,UAAW,GAAY,YAAa,EAAO,CAClD,GAAI,GAAO,EAAW,KAAK,aAAc,EAAM,EAAI,EACnD,AAAK,CAAE,eAAgB,iBAAkB,EAAE,SAAU,CAAQ,GAAM,GAAQ,EAAM,IAC5E,IAAY,mBAAqB,IAAU,QAC/C,GAAQ,IAAa,MAEtB,GAAM,GAAS,CAAE,OAAQ,KAAM,KAAM,EAAM,GAAK,QAAO,WAAU,KAAM,eAAgB,MAAO,CAAE,KAAM,CAAQ,CAAE,EAEhH,MAAO,GAAe,EADT,IAAM,EAAc,GAAU,KAAM,KAAM,GAAG,CAAK,CAC5B,CACpC,CACD,CAAE,EAEK,CACR,CCpRA,GAAqB,IAArB,aAAyC,GAAS,CAKjD,YAAa,KAAY,EAAO,CAC/B,MAAO,EAAS,OAAQ,GAAG,CAAK,CACjC,CAKA,KAAM,EAAQ,EAAW,OAAW,EAAS,CAAC,EAAI,CACjD,GAAM,CAAE,UAAS,UAAW,KAC5B,MAAS,IAAI,IAAc,EAAS,CAAO,EAAI,IAAK,GAAG,SAAU,CAClE,CAWA,MAAO,EAAM,EAAW,OAAW,EAAS,CAAC,EAAI,CAChD,CAAE,EAAM,EAAW,OAAW,EAAS,CAAC,CAAE,EAAI,KAAK,YAAa,SAAU,EAC1E,GAAM,CAAE,WAAY,KAEd,EAAU,GAAI,KAAK,EAAY,GAC9B,GAAQ,IAAK,CAAO,GAAM,EAAQ,IAAK,EAAQ,CAAE,SAAQ,SAAU,CAAC,EAAG,MAAO,CAAC,EAAG,KAAM,QAAS,MAAO,IAAK,CAAE,EAC9G,EAAQ,IAAK,CAAO,GAG5B,GAAK,CAAC,EAAO,YAAc,EAAO,aAAe,YAChD,GAAK,CAAC,EAAK,OAEV,CAAE,GAAG,EAAQ,QAAS,EAAE,QAAS,GAAQ,EAAW,CAAQ,EAAE,SAAS,KAAM,CAAK,CAAE,UACzE,EAAK,MAAO,GAAK,EAAE,OAAS,UAAW,EAAI,CACtD,GAAM,CAAE,EAAc,GAAiB,EAAK,OAAQ,CAAE,CAAE,EAAK,GAAS,IAC9D,EAAE,OAAS,QAAU,CAAE,EAAK,EAAM,OAAQ,CAAE,CAAE,EAAI,CAAE,EAAI,OAAQ,CAAE,EAAG,CAAM,EAChF,CAAE,CAAC,EAAG,CAAC,CAAE,CAAE,EACR,EAAU,CAAC,EACjB,AAAK,EAAO,QACN,GAAa,QAAW,EAAQ,KAAM,GAAG,EAAQ,iBAAkB,EAAa,KAAM,GAAI,CAAE,CAAE,EAC9F,EAAa,QAAW,EAAQ,KAAM,GAAG,AAAM,GAAO,KAAK,OAAQ,EAAS,CAAa,CAAE,GAE3F,GAAa,QAAW,EAAQ,KAAM,GAAG,CAAE,GAAG,EAAQ,QAAS,EAAE,OAAQ,GAAQ,EAAK,QAAS,CAAa,CAAE,CAAE,EAChH,EAAa,QAAW,EAAQ,KAAM,GAAG,AAAM,GAAO,KAAK,OAAQ,EAAS,EAAc,EAAM,CAAE,GAExG,EAAQ,QAAS,GAAQ,EAAW,EAAK,YAAc,CAAQ,EAAE,SAAS,KAAM,CAAK,CAAE,CACxF,EAGD,GAAK,CAAC,EAAW,MAAO,GACxB,GAAM,GAAiB,CAAE,aAAc,EAAM,EACvC,EAAkB,GAAY,EAAO,kBAAoB,KAAK,sBAAsB,EAC1F,OAAY,CAAE,CAAE,IAAY,GAAU,CACrC,GAAK,EAAe,aAAe,MACnC,GAAM,GAAQ,GAAiB,SAAS,GAAK,CAAC,EAC9C,EAAU,EAAQ,EAAO,CAAQ,CAClC,CAEA,GAAK,EAAO,KAAO,CAClB,AAAK,GAAoB,GAAS,CAAE,GAAG,EAAQ,iBAAgB,GAC/D,GAAM,GAAsB,KAAK,QAAS,EAAM,EAAU,CAAO,EACjE,MAAO,MAAK,gBAAiB,EAAO,OAAQ,EAAgB,CAAoB,CACjF,CACA,MAAO,MAAK,gBAAiB,EAAO,OAAQ,EAAgB,CAAgB,CAC7E,CAKA,SAAU,EAAM,EAAW,OAAW,EAAS,CAAC,EAAI,CACnD,OAAE,EAAM,EAAW,OAAW,EAAS,CAAC,CAAE,EAAI,KAAK,YAAa,SAAU,EACnE,KAAK,MAAO,EAAM,EAAU,CAAE,GAAG,EAAQ,QAAS,EAAM,CAAE,CAClE,CAKA,QAAS,EAAM,EAAW,OAAW,EAAS,CAAC,EAAI,CAClD,OAAE,EAAM,EAAW,OAAW,EAAS,CAAC,CAAE,EAAI,KAAK,YAAa,SAAU,EACnE,KAAK,MAAO,EAAM,EAAU,CAAE,GAAG,EAAQ,QAAS,EAAK,CAAE,CACjE,CAWA,QAAS,EAAM,EAAU,EAAS,CAAC,EAAI,CAGtC,GAFA,CAAE,EAAM,EAAU,EAAS,CAAC,CAAE,EAAI,KAAK,YAAa,SAAU,EAEzD,CAAE,OAAQ,WAAY,EAAE,SAAU,EAAO,MAAO,EAAI,MAAO,MAAK,YAAa,EAAM,EAAU,CAAO,EACzG,GAAK,EAAO,QAAU,EAAO,SAAW,QAAU,KAAM,IAAI,OAAO,kBAAmB,EAAO,kBAAoB,EAEjH,GAAM,CAAE,UAAS,SAAQ,SAAQ,YAAa,KAE9C,AAAK,EAAO,cAAiB,GAAO,QAAQ,+BAAiC,IACtE,GAAS,aAAe,WAAa,EAAO,QAAQ,iCAAoC,CAAC,EAAO,QAAQ,sBAAsB,cACpI,GAAgB,KAAM,EAAQ,OAAQ,IAAM,CAAC,CAAE,EAGhD,GAAM,GAAiB,GAAI,GAAO,iBAAkB,GAAW,EAAQ,QAAS,GAAU,CACzF,GAAS,KAAM,EAAQ,EAAc,GAAiB,KAAM,EAAQ,CAAO,EAAG,CAAQ,CACvF,CAAE,CAAE,EACJ,EAAe,QAAS,EAAS,CAAE,UAAW,GAAM,QAAS,EAAO,OAAS,CAAE,EAC/E,GAAM,GAAkB,EAAO,iBAAmB,EAAO,kBAAoB,KAAK,sBAAsB,EAClG,EAAe,CAAE,UAAS,OAAM,WAAU,SAAQ,kBAAiB,gBAAe,EAExF,GAAK,EAAO,kBAAoB,CAC/B,GAAM,GAAsB,GAAkB,KAAM,EAAQ,CAAa,EACzE,MAAO,MAAK,gBAAiB,EAAO,OAAQ,EAAgB,EAAiB,CAAoB,CAClG,CACA,MAAO,MAAK,gBAAiB,EAAO,OAAQ,EAAgB,CAAgB,CAC7E,CAWA,YAAa,EAAM,EAAU,EAAS,CAAC,EAAI,CAC1C,CAAE,EAAM,EAAU,EAAS,CAAC,CAAE,EAAI,KAAK,YAAa,SAAU,EAC9D,GAAM,CAAE,UAAS,UAAW,KAE5B,GAAK,EAAO,QAAU,CAAC,CAAE,OAAQ,WAAY,EAAE,SAAU,EAAO,MAAO,EAAI,KAAM,IAAI,OAAO,kBAAmB,EAAO,kBAAoB,EAC1I,GAAM,GAAqB,EAAO,SAAW,YAAc,YAAc,OACnE,EAAoB,EAAO,QAAU,UAAY,WACvD,AAAM,KAAK,SAAU,CAAmB,EAAE,MAEzC,GAAgB,KAAM,EAAQ,EAAoB,GAAU,CAC3D,KAAK,uBAAwB,EAAoB,EAAQ,EAAS,CACnE,CAAE,EAEH,GAAM,GAAK,GAAI,GAAO,iBAAkB,GAAW,EAAQ,QAAS,GAAU,CAC7E,AAAK,MAAM,QAAW,GAAS,GAAiB,KAAM,EAAQ,CAAO,GAAI,KAAM,GAC/E,GAAS,KAAM,EAAQ,EAAc,EAAQ,CAAQ,CACtD,CAAE,CAAE,EACJ,EAAG,QAAS,EAAS,CAAE,UAAW,GAAM,QAAS,EAAO,OAAQ,CAAE,EAElE,GAAM,GAAiB,CAAE,YAAa,CACrC,EAAG,WAAW,EACd,EAAS,OAAQ,CAAa,EACxB,EAAS,MAAS,EAAW,OAAQ,CAAQ,CACpD,CAAE,EACI,EAAkB,EAAO,iBAAmB,EAAO,kBAAoB,KAAK,sBAAsB,EAClG,EAAe,CAAE,UAAS,OAAM,WAAU,SAAQ,kBAAiB,gBAAe,EAElF,EAAa,KAAK,SAAU,EAAoB,CAAkB,EACxE,AAAM,EAAW,IAAK,CAAQ,GAAM,EAAW,IAAK,EAAS,GAAI,IAAI,EACrE,GAAM,GAAW,EAAW,IAAK,CAAQ,EAGzC,GAFA,EAAS,IAAK,CAAa,EAEtB,EAAO,kBAAoB,CAC/B,GAAM,GAAsB,GAAkB,KAAM,EAAQ,CAAa,EACzE,MAAO,MAAK,gBAAiB,EAAO,OAAQ,EAAgB,EAAiB,CAAoB,CAClG,CACA,MAAO,MAAK,gBAAiB,EAAO,OAAQ,EAAgB,CAAgB,CAC7E,CACD,EASA,YAA4B,EAAe,CAC1C,GAAM,GAAS,KACT,CAAE,UAAS,OAAM,WAAU,SAAQ,mBAAoB,EACvD,EAAe,EAAK,OAAQ,GAAK,EAAE,OAAS,KAAM,EAClD,EAAW,GAAY,EAAS,MAAO,aAAc,GAAG,OAAS,CAAE,OAAQ,EAAI,CAAC,EAChF,EAAY,GAAY,EAAS,MAAO,YAAa,GAAG,OAAS,CAAE,IAAK,EAAI,CAAC,EAC7E,EAAQ,GAAY,CAAE,GAAG,EAAS,SAAU,4BAA6B,CAAE,EAAE,IAAK,GAAK,EAAG,EAAI,EAAE,OAAQ,EAAU,CAAS,CAAE,EAAE,OAAQ,EAAW,CAAS,CAAE,EACnK,GAAK,CAAG,GAAa,OAAS,MAAM,KAAM,GAAI,KAAK,EAAa,OAAQ,GAAO,GAAI,IAAK,SAAU,GAAI,CAAE,EAAE,OAAQ,CAAE,EAAO,IAAc,EAAM,OAAQ,EAAO,EAAW,EAAG,CAAE,EAAG,CAAC,CAAE,CAAE,CAAE,GAAI,OAAS,OAErM,GAAM,GAAW,GAAI,KAAK,EAAQ,GAAI,KACtC,SAAS,KAAO,GAAS,GAAM,OAAQ,CAAI,EAAG,EAAS,IAAK,CAAI,GAChE,EAAM,KAAO,GAAS,GAAS,OAAQ,CAAI,EAAG,EAAM,IAAK,CAAI,GAC7D,EAAa,eAAiB,CAAE,WAAU,OAAM,EAEvC,GAAI,IAAc,EAAS,CAAO,EAAI,QAAS,EAAa,OAAQ,GAAY,CACxF,GAAM,GAAU,GAAI,KAAK,EAAY,GAC9B,GAAQ,IAAK,CAAO,GAAM,EAAQ,IAAK,EAAQ,CAAE,SAAQ,SAAU,CAAC,EAAG,MAAO,CAAC,EAAG,KAAM,SAAU,MAAO,IAAK,CAAE,EAC/G,EAAQ,IAAK,CAAO,GAGtB,EAAe,GAAI,SACnB,EAAU,GACT,GAAa,IAAK,CAAK,GAAM,EAAa,IAAK,EAAM,EAAa,KAAM,GAAK,EAAK,QAAS,EAAI,EAAG,CAAE,CAAE,EACrG,EAAa,IAAK,CAAK,GAG/B,OAAY,KAAW,GACtB,CAAE,WAAY,OAAQ,EAAE,QAAS,GAAc,CAC9C,AAAK,EAAO,YAAc,IAAe,EAAO,YAC3C,EAAa,eAAgB,GAAa,IAAK,EAAQ,MAAO,GAAO,KAAe,WAAa,CAAC,EAAS,EAAQ,MAAO,EAAI,EAAS,EAAQ,MAAO,IAC3J,GAAa,eAAgB,GAAa,KAAM,EAAQ,MAAO,EAC/D,EAAW,EAAQ,MAAO,EAAG,GAAa,KAAM,EAAQ,MAAO,EAC/D,EAAW,EAAQ,MAAO,EAAE,MAAQ,EAAQ,MAC7C,CAAE,EAGH,OAAY,CAAE,CAAE,IAAY,GAAU,CACrC,GAAM,GAAQ,GAAiB,SAAS,GAAK,CAAC,EAC9C,EAAU,EAAQ,EAAO,CAAQ,CAClC,CACD,EAAG,CAAE,QAAS,EAAO,QAAS,OAAQ,EAAO,OAAQ,aAAc,EAAO,YAAa,CAAE,CAC1F,CAUA,YAAmB,EAAc,EAAU,CAC1C,GAAM,CAAE,UAAS,OAAM,WAAU,SAAQ,kBAAiB,kBAAmB,EAEvE,EAAS,CAAE,GAAG,EAAS,SAAU,CAAC,EAAG,MAAO,CAAC,CAAE,EAerD,GAdM,EAAO,cAAiB,MAAO,GAAO,MAC5C,CAAE,WAAY,OAAQ,EAAE,QAAS,GAAc,CAC9C,GAAK,IAAO,YAAc,IAAe,EAAO,aAChD,CAAK,EAAK,OACT,EAAQ,GAAe,GAAkB,KAAM,KAAM,EAAM,EAAS,GAAc,EAAQ,QAAU,OAAQ,EAE5G,EAAQ,GAAe,CAAE,GAAG,EAAS,EAAa,EAE9C,EAAC,GACN,OAAY,KAAQ,GAAQ,GAC3B,EAAgB,GAAa,KAAM,CAAK,CAE1C,CAAE,EAEG,CAAC,EAAO,SAAS,QAAU,CAAC,EAAO,MAAM,OAAS,OACvD,GAAM,GAAQ,GAAiB,SAAS,GAAK,CAAC,EAC9C,EAAU,EAAQ,EAAO,CAAQ,CAClC,CAWA,YAA4B,EAAM,EAAS,EAAgB,CAC1D,EAAU,MAAM,QAAS,CAAQ,EAAI,EAAU,CAAE,GAAG,CAAQ,EAC5D,GAAM,GAAQ,CAAE,EAAS,IAAO,CAE/B,GAAK,EAAE,OAAS,WAAa,CAE5B,GAAI,GAAU,EAAE,YAAc,CAAC,EAAI,EAAQ,OAAQ,GAAU,EAAE,OAAS,QAAU,AAAM,GAAO,KAAM,EAAQ,EAAI,EAAG,EAAI,EAAO,SAAW,EAAO,QAAS,EAAI,EAAG,CAAE,EAQnK,GANK,IAAiB,EAAE,cACvB,GAAU,EAAQ,OAAQ,CAAE,EAAY,IAClC,EAAE,OAAS,QAAmB,CAAE,GAAG,EAAY,GAAG,AAAM,GAAO,KAAM,EAAQ,EAAG,CAAc,CAAE,EAC9F,EAAO,iBAAmB,CAAE,GAAG,EAAY,GAAG,EAAO,iBAAkB,EAAI,EAAG,CAAE,EAAI,EACzF,CAAQ,GAEP,EAAQ,OAAS,MAAO,EAC9B,SAEM,EAAQ,SAAU,EAAE,OAAQ,GAChC,GAAiB,EAAQ,KAAM,GAAU,EAAO,SAAU,EAAE,OAAQ,CAAE,EACjE,MAAO,CAAE,EAAE,OAAQ,CAE3B,EAGA,MAAM,GAAQ,eAAkB,GAAQ,cAAgB,GAAI,MACrD,EAAK,OAAQ,CAAE,EAAS,IAAO,CACrC,GAAI,GACJ,MAAK,GAAQ,cAAc,IAAK,EAAE,OAAQ,EACzC,EAAW,EAAQ,cAAc,IAAK,EAAE,OAAQ,EAEhD,GAAW,EAAO,EAAS,CAAE,GAAK,CAAC,EAC9B,EAAE,OAAS,YACf,EAAQ,cAAc,IAAK,EAAE,QAAS,CAAS,GAG1C,EAAQ,OAAQ,CAAS,CACjC,EAAG,CAAC,CAAE,CACP,CASA,YAA2B,CAAE,SAAQ,aAAY,gBAAiB,CACjE,GAAI,GAAS,KAAM,EACnB,SAAQ,EAAU,CAAW,EAAE,OAAQ,CAAE,EAAM,IAAU,GAAQ,EAAO,OAAO,QAAQ,wBAAwB,IAAK,CAAK,EAAG,IAAK,EACjI,EAAQ,EAAU,CAAa,EAAE,OAAQ,CAAE,EAAM,IAAU,GAAQ,EAAO,OAAO,QAAQ,wBAAwB,IAAK,CAAK,EAAG,CAAM,EACpI,EAAQ,GAAS,EAAO,SAAS,aAAe,WAAa,SAAW,WACjE,CAAE,SAAQ,SAAU,EAAY,MAAO,EAAc,KAAM,cAAe,OAAM,CACxF,CAUA,YAA0B,EAAQ,EAAW,CAC5C,GAAM,GAAS,KACT,CAAE,SAAQ,WAAU,OAAM,gBAAe,UAAS,cAAa,sBAAqB,oBAAqB,EAC/G,AAAM,EAAO,QAAQ,sBAAyB,OAAO,eAAgB,EAAO,QAAS,uBAAwB,CAAE,MAAO,GAAI,IAAI,CAAE,EAC1H,EAAO,QAAQ,qBAAqB,IAAK,CAAO,GAAM,EAAO,QAAQ,qBAAqB,IAAK,EAAQ,GAAI,IAAI,EACrH,EAAO,QAAQ,qBAAqB,IAAK,CAAO,EAAE,IAAK,CAAS,EAChE,GAAM,GAAK,IAAM,EAAO,QAAQ,qBAAqB,IAAK,CAAO,EAAE,OAAQ,CAAS,EACpF,GAAK,EAAO,QAAQ,sBAAsB,aAAe,MAAO,GAChE,QAAQ,KAAM,8CAA+C,EAC7D,EAAO,QAAQ,qBAAqB,aAAe,GACnD,OAAO,eAAgB,EAAO,QAAS,yBAA0B,CAAE,MAAO,GAAI,IAAI,CAAE,EAGpF,GAAM,GAAY,CAAE,EAAQ,IAAmB,CAC9C,EAAO,SAAS,OAAQ,EAAO,KAAM,EAAE,QAAS,GAAQ,CACvD,aAAc,EAAO,QAAQ,uBAAuB,IAAK,CAAK,GAAG,OAAQ,EACzE,EAAO,QAAQ,uBAAuB,IAAK,EAAM,EAAO,KAAM,EAC9D,GAAM,GAAU,WAAY,IAAM,CAAE,EAAO,QAAQ,uBAAuB,OAAQ,CAAK,CAAG,EAAG,CAAE,EAC/F,OAAO,eAAgB,EAAO,MAAO,UAAW,CAAE,MAAO,EAAS,aAAc,EAAK,CAAE,CACxF,CAAE,EACF,EAAO,QAAQ,qBAAqB,IAAK,WAAY,GAAG,QAAS,GAAY,EAAU,CAAO,CAAE,EAChG,GAAM,GAAc,EAAc,EAClC,SAAO,QAAQ,qBAAqB,IAAK,MAAO,GAAG,QAAS,GAAY,EAAU,CAAO,CAAE,EACpF,CACR,EAGM,EAAgB,CAAE,cAAe,OAAO,OAAQ,IAAK,EAAG,MAAO,OAAO,OAAQ,IAAK,CAAE,EAC3F,CAAE,eAAwB,wBAAyB,qBAAsB,UACxE,kBAAmB,cAAe,SAAU,eAAwB,cACpE,SAAU,QAAS,SAAU,UAAW,aACzC,EAAE,QAAS,GAAW,CACrB,cAAoB,EAAO,CAC1B,GAAM,GAAe,eAAgB,GAAgB,EAAc,cAAgB,EAAc,MAE3F,EAAO,IAAM,EAAc,GAAU,KAAM,KAAM,GAAG,CAAK,EAC/D,GAAK,CAAG,gBAAgB,IAAiB,eAAgB,IAAW,eAAgB,IAAqB,MAAO,GAAK,EAGrH,GAAI,GAAQ,CAAC,EAAG,EAAW,CAAC,EAAG,EAAS,KACxC,AAAK,CAAE,cAAe,EAAE,SAAU,CAAQ,EACzC,EAAW,CAAE,EAAM,EAAI,EACjB,AAAK,CAAE,wBAAyB,oBAAqB,EAAE,SAAU,CAAQ,EAC/E,GAAW,CAAE,EAAM,EAAI,EAClB,CAAE,cAAe,UAAW,EAAE,SAAU,EAAM,EAAI,GACtD,GAAS,KAAK,aAET,AAAK,CAAE,UAAW,iBAAkB,EAAE,SAAU,CAAQ,EAC9D,GAAQ,CAAE,GAAG,KAAK,UAAW,EAC7B,EAAW,IAAY,kBAAoB,CAAE,GAAG,CAAK,EAAI,CAAE,EAAM,EAAI,GAC/D,AAAK,CAAE,cAAe,QAAS,EAAE,SAAU,CAAQ,EACzD,GAAQ,CAAE,IAAK,EACf,EAAW,IAAY,cAAgB,CAAE,GAAG,CAAK,EAAI,CAAC,EACtD,EAAS,KAAK,YACR,AAAK,CAAE,cAAe,EAAE,SAAU,CAAQ,EAChD,GAAQ,CAAE,EAAM,EAAI,EACpB,EAAW,CAAE,EAAM,EAAI,GACjB,AAAK,CAAE,aAAc,EAAE,SAAU,CAAQ,EAC/C,EAAQ,CAAE,GAAG,CAAK,EAGlB,GAAW,CAAE,GAAG,CAAK,EAChB,CAAE,SAAU,OAAQ,EAAE,SAAU,CAAQ,GAC5C,GAAS,KAAK,aAKhB,GAAI,IAAe,EACnB,GAAK,CAAE,qBAAsB,SAAU,EAAE,SAAU,CAAQ,EAAI,CAC9D,GAAI,IAAe,KAAK,SACxB,GAAK,IAAY,sBAAwB,CAAE,cAAe,UAAW,EAAE,SAAU,EAAM,EAAI,EAAI,CAE9F,GAAK,CAAC,KAAK,WAAa,MAAO,GAAc,GAAU,KAAM,KAAM,GAAG,CAAK,EAC3E,GAAe,KAAK,WAAW,QAChC,CACA,GAAM,IAAO,EAAS,cAAe,EAAa,EAClD,EAAa,QAAQ,KAAM,GAAM,EAAU,GAAK,IAAY,UAAY,EAAM,GAAM,CAAC,CAAE,EACvF,EAAW,CAAE,GAAG,GAAK,UAAW,EAEhC,AAAK,IAAY,qBAChB,IAAe,wBACf,EAAM,GAAM,GAAI,GAChB,EAAM,GAAI,aAAe,GACzB,EAAM,GAAI,OAAQ,GAAG,GAAK,UAAW,GAErC,IAAe,kBACf,EAAO,CAAE,GAAG,GAAK,UAAW,EAE9B,CAGA,MAAO,GADQ,CAAE,SAAQ,WAAU,QAAO,KAAM,eAAgB,MAAO,CAAE,KAAM,CAAQ,CAAE,EAC/D,IAClB,EAAc,IAAe,KAAM,KAAM,GAAG,CAAK,CACvD,CACH,CAEA,AAAK,CAAE,eAAgB,eAAgB,cAAe,aAAc,EAAE,SAAU,CAAQ,EACvF,GAAc,MAAO,GAAY,EAAK,UAAW,GACjD,EAAK,UAAW,GAAY,GAGvB,EAAE,QAAS,SAAU,SAAU,aAAc,EAAE,SAAU,CAAQ,GACrE,GAAc,cAAe,GAAY,EAAc,UAAW,GAClE,EAAc,UAAW,GAAY,GAGjC,EAAQ,UAAW,IACvB,GAAc,MAAO,GAAY,EAAQ,UAAW,GACpD,EAAQ,UAAW,GAAY,GAGlC,CAAE,EAEF,GAAM,GAAe,OAAO,OAAQ,IAAK,EAEzC,OAAE,YAAa,YAA4B,YAC1C,YAA2B,cAAuB,WACnD,EAAE,QAAS,GAAW,CAErB,GAAM,GAAY,CAAE,cAAe,WAAY,EAAE,SAAU,CAAQ,EAAI,EACtE,CAAE,YAAa,WAAY,EAAE,SAAU,CAAQ,EAAI,EAAc,EAElE,EAAc,GAAY,OAAO,yBAA0B,EAAU,UAAW,CAAQ,EACxF,OAAO,eAAgB,EAAU,UAAW,EAAS,CAAE,GAAG,EAAc,GAAW,IAAK,SAAU,EAAQ,CACzG,GAAI,GAAO,IAAM,EAAc,GAAU,IAAI,KAAM,KAAM,CAAM,EAE/D,GAAK,CAAG,gBAAgB,IAAY,MAAO,GAAK,EAGhD,GAAI,GAAQ,CAAC,EAAG,EAAW,CAAC,EAAG,EAAS,KAYxC,GAXA,AAAK,CAAE,YAAa,WAAY,EAAE,SAAU,CAAQ,EACnD,GAAQ,CAAE,IAAK,EACf,EAAS,KAAK,YAGd,EAEK,CAAE,GAAG,KAAK,UAAW,EAItB,CAAE,YAAa,WAAY,EAAE,SAAU,CAAQ,EAAI,CACvD,GAAI,IAAe,KAAK,SACxB,GAAK,IAAY,YAAc,CAE9B,GAAK,CAAC,KAAK,WAAa,MAAO,GAAK,EACpC,GAAe,KAAK,WAAW,QAChC,CACA,GAAM,IAAO,EAAS,cAAe,KAAiB,WAAa,MAAQ,EAAa,EACxF,EAAc,GAAU,IAAI,KAAM,GAAM,CAAM,EAC9C,EAAsC,eAAgB,GAAsB,CAAC,EAAI,CAAE,GAAG,GAAK,UAAW,EAEtG,AAAK,IAAY,YAChB,GAAQ,GAAI,GACZ,EAAM,aAAe,GACrB,EAAM,OAAQ,GAAG,GAAK,UAAW,EACjC,EAAO,IAAM,EAAQ,UAAU,YAAY,KAAM,KAAM,CAAM,GAE7D,AAAK,eAAgB,GACpB,EAAO,IAAM,KAAK,QAAQ,gBAAiB,GAAG,GAAK,UAAW,EAE9D,EAAO,IAAM,EAAQ,UAAU,gBAAgB,KAAM,KAAM,GAAG,GAAK,UAAW,CAGjF,CAGA,MAAO,GADQ,CAAE,SAAQ,WAAU,QAAO,KAAM,eAAgB,MAAO,CAAE,KAAM,CAAQ,CAAE,EAC/D,CAAK,CAChC,CAAE,CAAE,CACL,CAAE,EAGF,CAAE,SAAU,UAAW,iBAAkB,EAAE,QAAS,GAAW,CAC9D,CAAE,EAAU,EAAiB,SAAU,EAAE,QAAS,GAAU,CAC3D,GAAM,GAAc,EAAQ,GAC5B,EAAQ,GAAY,YAAa,EAAO,CACvC,GAAK,KAAK,aAAe,MAAO,GAAY,KAAM,KAAM,GAAG,CAAK,EAChE,GAAM,GAAQ,IAAY,kBAAoB,CAAE,GAAG,KAAK,UAAW,EAAI,CAAC,EAQxE,MAAO,GAPQ,CACd,OAAQ,KACR,SAAU,EACV,QACA,KAAM,eACN,MAAO,CAAE,KAAM,CAAQ,CACxB,EAC0B,IAClB,EAAY,KAAM,KAAM,GAAG,CAAK,CACtC,CACH,CACD,CAAE,CACH,CAAE,EAEK,CACR,CCjhBe,aAAW,CACtB,GAAW,KAAM,IAAK,EACtB,GAAiB,KAAM,IAAK,EAC5B,GAAgB,KAAM,IAAK,CAC/B,CAOO,aAAsB,CACzB,GAAM,GAAS,KACf,AAAM,EAAO,KAAQ,GAAO,IAAM,CAAC,GAC7B,EAAO,IAAI,QAQb,GAAO,IAAI,OAAS,GAAO,EAAI,QAAS,iBAAkB,MAAO,EAEzE,CASO,aAA4B,CAC/B,GAAM,GAAS,KACf,AAAQ,eAAiB,GAAO,KAAK,WACjC,OAAO,eAAgB,EAAO,KAAK,UAAW,cAAe,CAAE,IAAK,UAAW,CAC3E,MAAO,CAAC,KAAK,eAAiB,CAC1B,MAAK,cAAc,wBAAyB,IAAK,EAC/C,KAAK,+BACf,CAAE,CAAE,CAEZ,CASO,aAA2B,CAC9B,GAAM,GAAS,KACf,AAAM,EAAO,QAAQ,UAAU,SAC3B,GAAO,QAAQ,UAAU,QACzB,EAAO,QAAQ,UAAU,iBACzB,EAAO,QAAQ,UAAU,oBACzB,EAAO,QAAQ,UAAU,mBACzB,EAAO,QAAQ,UAAU,kBACzB,EAAO,QAAQ,UAAU,uBACzB,SAAU,EAAI,CAGV,OAFI,GAAY,MAAK,UAAY,KAAK,eAAgB,iBAAkB,CAAE,EACtE,EAAI,EAAQ,OACR,EAAE,GAAK,GAAK,EAAQ,KAAM,CAAE,IAAM,MAAO,CACjD,MAAO,GAAI,EACf,EAER,CC5De,aAAW,CACtB,GAAM,GAAS,KAEf,GADM,EAAO,QAAS,GAAO,OAAS,CAAC,GAClC,EAAO,OAAO,QAAU,MAAO,GAAO,OAAO,QAClD,EAAO,OAAO,QAAU,CAAC,EACzB,GAAS,KAAM,CAAO,EAEtB,EAAO,OAAO,QAAQ,KAAO,IAAK,IAAU,GAAK,KAAM,EAAQ,GAAG,CAAK,EACvE,EAAO,OAAO,QAAQ,MAAQ,IAAK,IAAU,GAAM,KAAM,EAAQ,GAAG,CAAK,EAEzE,EAAO,OAAO,QAAQ,SAAW,CAAE,EAAS,EAAY,QAAW,CAC/D,GAAK,IAAc,MAAQ,MAAO,IAAI,IAAa,EAAS,CAAO,EACnE,GAAK,IAAc,OAAS,MAAO,IAAI,IAAc,EAAS,CAAO,CACzE,EAEA,GAAM,GAAY,GAAI,IAAW,CAAO,EACxC,SAAO,OAAO,QAAQ,SAAW,CAAE,KAAS,IACjC,EAAW,KAAM,KAAW,GAAG,CAAK,EAGxC,EAAO,OAAO,OACzB,CAUA,eAAmB,EAAO,CACtB,GAAI,GAAS,cAAe,EAC5B,AAAK,GAAW,EAAM,EAAI,EACtB,GAAS,EAAM,GACV,EAAa,EAAM,EAAI,GAAM,GAAW,EAAM,KAC3C,EAAa,EAAM,EAAI,GAAM,GAAW,EAAM,IAE1D,GAAM,GAAU,CAAE,YAAa,CAAE,cAAe,UAAW,EAAG,SAAU,CAAE,UAAW,CAAG,EACxF,GAAK,CAAC,EAAS,GAAW,KAAM,IAAI,OAAO,+BAAgC,IAAW,EACzF,GAAM,GAAS,KAEZ,GAAK,CAAC,EACF,MAAM,GAAO,OAAO,QAAQ,oBACxB,GAAO,OAAO,QAAQ,mBAAqB,CACvC,YAAa,GAAI,SAAS,GAAO,GAAM,KAAM,KAAM,cAAe,CAAI,CAAE,EACxE,SAAU,GAAI,SAAS,GAAO,GAAM,KAAM,KAAM,WAAY,CAAI,CAAE,CACtE,GAEG,EAAO,OAAO,QAAQ,mBAAoB,GAGxD,GAAK,EAAS,GAAS,SAAU,EAAO,SAAS,UAAW,EAAI,MAAO,GAAU,CAAO,EACrF,AAAM,EAAO,OAAO,QAAQ,qBACxB,GAAO,OAAO,QAAQ,oBAAsB,CAAE,YAAa,CAAC,EAAG,SAAU,CAAC,CAAE,EAC5E,EAAO,SAAS,iBAAkB,mBAAoB,IAAM,CACxD,GAAM,GAAQ,EAAO,SAAS,WAC9B,OAAY,KAAY,GAAO,OAAO,QAAQ,oBAAqB,GAAQ,OAAQ,CAAE,EACjF,EAAU,CAAO,CAEzB,EAAG,EAAM,GAEb,EAAO,OAAO,QAAQ,oBAAqB,GAAS,KAAM,CAAS,CACvE,CASA,YAAe,EAAO,CAClB,GAAM,GAAS,KACX,EAAW,CAAC,EAAG,EACnB,MAAK,GAAM,EAAO,SAAS,cAAe,cAAe,KAAU,IAC/D,GAAa,GAAI,SAAW,IAAK,MAAO,GAAI,EAAE,OAAQ,GAAK,CAAE,EAAE,OAAQ,CAAE,EAAW,IAAe,CAC/F,GAAM,GAAiB,EAAU,MAAO,GAAI,EAAE,IAAK,GAAK,EAAE,KAAK,CAAE,EACjE,UAAM,EAAW,EAAgB,GAAI,MAAO,GAAI,EAAG,EAAgB,KAAQ,OAAS,GAAQ,EAAgB,KAAQ,QAAU,GACtH,EAAY,EAAgB,EAAI,EAAI,SAAU,EAAgB,EAAI,EAAI,EAAgB,EAE9F,EACO,CACX,EAAG,CAAC,CAAE,GAEH,CAAE,GAAI,OAAO,CAAE,MAAO,EAAM,EAAG,GAAI,UAAU,CAAE,MAAO,GAAI,OAAS,EAAG,MAAO,CACtF,MAAO,MAAK,MAAO,KAAK,UAAW,CAAS,CAAE,CAC5C,CAAE,CACN,CCzFO,YAAgB,EAAM,EAAS,EAAY,CAC9C,GAAM,GAAQ,EAAK,YAAY,EAAE,QAAS,IAAK,GAAI,EAC7C,EAAS,KAAM,EAAU,GAAY,KAAM,CAAO,EACxD,SAAO,QAAY,GAAO,OAAS,CAAC,GACpC,EAAO,OAAO,QAAY,GAAO,OAAO,OAAS,CAAC,GAClD,EAAO,OAAO,OAAO,SAAa,GAAO,OAAO,OAAO,QAAU,CAAC,GAClE,EAAO,OAAO,OAAO,QAAS,IAAa,GAAO,OAAO,OAAO,QAAS,GAAU,CAAC,GAEpF,GAAQ,EAAG,EAAO,OAAO,OAAO,QAAS,GAAS,EAAW,EAAS,EAAQ,KAAM,CAAK,EAAE,KAAK,CAAE,EAE3F,CAAE,OAAQ,EAAO,OAAO,OAAO,QAAS,GAAS,UAAS,QAAO,CAC5E,CCEe,YAAe,CAAE,WAAW,CAAC,KAAM,GAAY,CAC1D,GAAM,CAAE,SAAQ,UAAW,GAAM,KAAM,KAAM,YAAa,EAAS,CAC/D,OAAQ,CAAE,UAAW,SAAU,SAAU,EAAG,EAC5C,SAAU,GAAe,CAAS,CACtC,CAAE,EACL,EAAO,eAAmB,OAAM,QAAS,EAAO,OAAO,QAAS,EAAI,EAAO,OAAO,SAAW,CAAE,EAAO,OAAO,QAAS,GAAI,OAAQ,CAAE,EAAU,IAAQ,CAC/I,GAAM,GAAY,EAAK,SAAU,EAAO,IAAI,OAAQ,CAAG,KAAQ,GAC/D,MAAO,GAAS,OAAQ,SAAU,mBAA6B,aAAuB,CAC1F,EAAG,CAAC,CAAE,EAAE,KAAM,GAAI,EAClB,OAAO,OAAQ,EAAO,OAAQ,CAAE,yBAAuB,uBAAqB,kBAAgB,SAAO,WAAS,CAAE,EAC9G,EAAO,OAAO,OAAO,OAAS,CAC1B,aAAc,CAAE,GAAI,KAAK,GAAI,IAAK,EAClC,QAAS,GAAQ,KAAM,EAAQ,CAAO,CAC1C,EACA,GAAS,KAAM,EAAQ,CAAO,CAClC,CAGA,kBAAwB,EAAQ,EAAW,CACvC,GAAM,GAAS,KAAM,CAAE,WAAY,EAAO,OACpC,EAAO,EAAK,SAAU,CAAS,EACrC,GAAK,CAAC,EAAO,KAAM,IAAI,OAAO,qCAAsC,EACpE,GAAM,CAAE,SAAQ,iBAAgB,eAAgB,EAEhD,AAAK,EAAO,OAAO,YAAc,UAC7B,EAAO,OAAO,EACX,AAAK,EAAO,OAAO,YAAc,UACpC,EAAO,YAAc,kBAErB,EAAO,YAAc,KAAM,GAAe,SAAS,EAGvD,GAAM,GAAU,MAAM,GAAe,KAAM,CAAY,GAAI,QAAQ,EACnE,AAAK,EAAO,UAAa,OAAO,eAAgB,EAAQ,QAAS,CAAE,MAAO,CAAM,CAAE,EAClF,EAAQ,SAAU,EAAO,QAAS,EAAE,QAAS,EAAQ,IAAM,CACvD,AAAK,EAAO,UAAa,EAAM,QAAQ,EAClC,EAAO,QAAW,EAAY,QAAQ,OAAQ,EAAY,QAAQ,QAAS,EAAQ,CAAE,CAAE,CAChG,EAAG,CAAE,QAAS,GAAM,OAAQ,OAAQ,WAAY,OAAQ,CAAE,CAC9D,CASA,YAAmB,EAAS,CAC3B,GAAM,GAAS,KAAM,CAAE,SAAQ,WAAY,EAAO,OAC/C,AAAM,EAAO,kBAAkB,UAAa,GAAO,kBAAkB,SAAW,IAAM,IACtF,GAAM,GAAuB,CAAE,QAAS,EAAE,OAAQ,EAAO,OAAO,UAAY,CAAC,CAAE,EAClF,EAAQ,SAAU,EAAO,QAAS,EAAE,QAAuD,EAAO,eAAgB,GAAU,CACrH,EAAO,SAAS,QAAS,GAAU,CAC/B,GAAK,EAAO,OAAS,OAGrB,GAFK,YAAc,IACnB,QAAO,eAAgB,EAAQ,WAAY,CAAE,MAAO,EAAO,aAAc,UAAW,CAAE,CAAE,EACnF,UAAY,IAAS,MAAO,SAAS,CAAO,EACjD,OAAO,eAAgB,EAAQ,SAAU,CAAE,MAAO,EAAO,aAAc,QAAS,CAAE,CAAE,EAEpF,GAAM,GAAgB,GAAO,EAAI,EAAO,YAAY,KAAK,IAAO,EAAO,EAAE,WAAY,uBAAwB,GAAK,EAAO,EAAE,SAAU,cAAe,EAAI,EAAO,EAAE,MAAO,GAAI,GAAI,EAAI,EAAO,YACrL,EAAa,EAAK,OAAQ,CAAY,EACtC,EAAe,EAAO,OAAO,aAAc,EAAO,SAAW,EAAI,GACnE,EACJ,GAAK,CAAG,GAAiB,EAAa,IAAK,CAAW,GAAM,CACxD,GAAM,CAAE,eAAc,iBAAgB,iBAAkB,EAAO,SAC/D,EAAiB,GAAM,GAAO,OAAS,SAAW,GAAiB,IAAuB,EAAa,CACnG,gBAAiB,IAAK,EAAO,KAC7B,SAAU,EAAO,SAAS,IAC1B,eACA,eAAgB,CAAE,GAAG,EAAgB,YAAa,CAAC,EAAO,QAAS,EACnE,eACJ,CAAE,EACF,EAAa,IAAK,EAAY,CAAe,CACjD,CAEA,GAAM,GAAc,EAAO,OAAS,EAAO,YAAc,EAAO,OAAW,EAAO,OAAS,SAAW,OAAY,EAClH,AAAK,EAAO,QACF,GAAY,SAAY,OAAO,eAAgB,EAAa,UAAW,CAAE,MAAO,CAAC,CAAE,CAAE,EAC3F,EAAY,QAAQ,KAAM,CAAO,GAErC,GAAM,GAAW,EAAK,OAAQ,CAAE,SAAQ,iBAAgB,aAAY,CAAE,EAEtE,AADuB,EAAO,OAAS,SAAa,EAAqB,SAAU,EAAO,IAAK,GAAK,CAAC,EAAO,kBAAkB,SAAU,EAAO,IAAK,EAC5H,EAAO,OAAO,QAAS,CAAS,EACpD,EAAO,YAAc,kCAAmC,OAEhE,CAAE,CACT,EAAG,CAAE,KAAM,GAAM,OAAQ,YAAa,WAAY,WAAY,aAAc,EAAK,CAAE,CAEpF,CCtGA,GAAK,KAAM,MAAO",
  "names": []
}
